"""
    obtain_symmetry_related_hoppings(
        Rs::AbstractVector{V}, 
        brₐ::NewBandRep{D}, 
        brᵦ::NewBandRep{D},
        timereversal::Bool = brₐ.timereversal
        ) where {V<:Union{AbstractVector{<:Integer},RVec{D}} where {D}
        --> Vector{HoppingOrbit{D}}

    Compute the symmetry related hopping terms from the points in WP of `brₐ` to the 
    WP of `brᵦ`displaced a set of primitive lattice vectors `Rs`.

    The vectors provided in `Rs` are just representatives. Because of symmetry 
    operations, bigger primitive lattice vectors could be found.

    How it works: 
    1. Take a point `a` in the WP of `brₐ` and a point `b` in the WP of `brᵦ`. We 
    compute the displacement vector `δ = b + R - a`, where `R ∈ Rs`.
    2. If `δ ∈ representatives` then we add `δ => (a, b, R)` to the list of hoppings 
        of that representative and continue. If not then, we search inside of all the 
        representatives for the one that `δ => (a, b, R)` in the list of hoppings. 
        If not found, then we add `δ` as a new representative and add `δ => (a, b, R)` 
        to its list of hoppings.
    3. Take `g ∈ generators` and compute `δ' = g δ` and `(a', b', R') = (g a, g b, g R)`, 
        and repeat step 2.
    4. Repeat all steps 1 to 3 for all pair of points in the WPs of `brₐ` and `brᵦ`.

    Additionally, if we have time-reversal symmetry, we merge orbits that are relate
    `δ` and `-δ`.
"""
function obtain_symmetry_related_hoppings(
    Rs::AbstractVector{V}, # must be specified in the primitive basis
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D},
    timereversal::Bool = brₐ.timereversal
) where {V<:Union{AbstractVector{<:Integer},RVec{D}}} where {D}
    sgnum = num(brₐ)
    num(brᵦ) == sgnum || error("both band representations must be in the same space group")
    brₐ.timereversal == brᵦ.timereversal || error("both band representations must have the same time-reversal symmetry")
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    cntr = centering(sgnum, D)
    ops = primitivize(spacegroup(sgnum, Val{D}()))
    wpsₐ = primitivize.(orbit(group(brₐ)), cntr)
    wpsᵦ = primitivize.(orbit(group(brᵦ)), cntr)

    # we have defined a structure `HoppingOrbit` to gather the information. It is 
    # structured as:
    # 1. `HoppingOrbit.representatives` will store a representative hopping vector δ
    # 2. `HoppingOrbit.orbit` will store the full orbit of symmetry related hopping 
    #   vector generated by δ: {δᵢ}
    # 3. `HoppingOrbit.hoppings` will store the real coordinates `(a,b,R)` of each 
    #   hopping term associated to each `δᵢ`. Note that maybe several `(a,b,R)` could be 
    #   associated to the same `δᵢ`

    h_orbits = HoppingOrbit{D}[]
    for R in Rs
        R = RVec{D}(R) # change the type of R for type consistency
        for (qₐ, qᵦ) in Iterators.product(wpsₐ, wpsᵦ)
            qₐ = parent(qₐ) # work with RVec directly rather than Wyckoff Position
            qᵦ = parent(qᵦ)
            δ = qᵦ + R - qₐ # potential representative in next element of `h_orbits`
            maybe_add_hoppings!(h_orbits, δ, qₐ, qᵦ, R, ops)
        end
    end

    # timereversal could link orbits that spatial symmetries alone would categorize as
    # distinct; in particular, if we have timereversal, a hopping vector `δ` must
    # have a counterpart `-δ` - but those two vectors could have fallen into distinct
    # hopping orbits at this point; if so, we must merge them
    if timereversal
        merge_timereversal_related_orbits(h_orbits)
    end

    return h_orbits
end

"""
    maybe_add_hoppings!(h_orbits, δ, qₐ, qᵦ, R, ops) --> Vector{HoppingOrbit{D}}

Checks if a hopping term `δ` is already in the list of representatives. If not, 
it adds it and its symmetry related partners. If it is, it only adds the symmetry 
related partners.
"""
function maybe_add_hoppings!(h_orbits, δ, qₐ, qᵦ, R, ops::AbstractVector{SymOperation{D}}) where {D}
    δ_idx = findfirst(h_orbits) do h_orbit
        isapproxin(δ, orbit(h_orbit), nothing, false) # check if δ is in h_orbits
    end
    if isnothing(δ_idx)
        # if it wasn't already in `h_orbits`, we add it and its symmetry-related partners
        δ_orbit = HoppingOrbit{D}(δ, [δ], [[(qₐ, qᵦ, R)]])
        push!(h_orbits, δ_orbit)
    else # if it was already in `h_orbits`, we only add its symmetry-related partners
        δ_orbit = h_orbits[δ_idx]
    end
    _maybe_add_hoppings!(δ_orbit, δ, qₐ, qᵦ, R, ops)
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `maybe_add_hoppings!`.

Computes and adds the symmetry related partners of a hopping term `δ` to the 
`δ_orbit`.
"""
function _maybe_add_hoppings!(δ_orbit, δ, qₐ, qᵦ, R, ops::AbstractVector{SymOperation{D}}) where {D}
    for g in ops
        _qₐ′ = g * qₐ
        _qᵦ′ = g * (qᵦ + R)
        # _qₐ′ and _qᵦ′ could include a translation part that is a multiple of the lattice
        # translation, so we reduce it to a unit range and keep that translation part separate
        qₐ′ = RVec(reduce_translation_to_unitrange(constant(_qₐ′)), free(_qₐ′))
        qᵦ′ = RVec(reduce_translation_to_unitrange(constant(_qᵦ′)), free(_qᵦ′))
        dₐ = _qₐ′ - qₐ′ # possible lattice translation part of _qₐ′
        dᵦ = _qᵦ′ - qᵦ′ # possible lattice translation part of _qᵦ′

        R′ = dᵦ - dₐ # total lattice translation part of the symmetry-related hopping term δ'
        g_rotation = SymOperation(rotation(g)) # rotation-only part of g
        δ′ = g_rotation * δ # potential symmetry related partner of `δ` to add to `δ_orbit`

        # several sanity checks:
        #   1. R´ is a lattice translation, i.e., it is integer
        #   2. R´ doesn't have any free parameters - TODO: try to implement it for WPs with free parameters
        #   3. δ′ = qᵦ′ + R′ - qₐ′
        all(Rᵢ′ -> abs(Rᵢ′ - round(Rᵢ′)) < 1e-10, constant(R′)) || error("arrived at non-integer lattice translation R′: should be impossible")
        isspecial(R′) || error("arrived at non-special (nonzero free parameters) lattice translation R′: should be impossible")
        isapprox(δ′, qᵦ′ + R′ - qₐ′, nothing, false) || error("δ′ ≠ qᵦ′ + R′ - qₐ′")

        idx_in_orbit = findfirst(δ′′ -> isapprox(δ′, δ′′, nothing, false), orbit(δ_orbit))
        if isnothing(idx_in_orbit)
            # δ′ is not already included in `orbit(δ_orbit)`
            push!(orbit(δ_orbit), δ′)
            push!(δ_orbit.hoppings, [(qₐ′, qᵦ′, R′)])
        else
            # δ′ already in `orbit(δ_orbit)` but hopping term might not be:
            # evaluate `(qₐ′, qᵦ′, R′) ∉ δ_orbit.hoppings[idx_in_orbit]`, w/
            # approximate equality comparison
            bool = !any(δ_orbit.hoppings[idx_in_orbit]) do (qₐ′′, qᵦ′′, R′′)
                (isapprox(qₐ′, qₐ′′, nothing, false) && isapprox(qᵦ′, qᵦ′′, nothing, false)
                 && isapprox(R′, R′′, nothing, false))
            end
            if bool
                push!(δ_orbit.hoppings[idx_in_orbit], (qₐ′, qᵦ′, R′))
            end
        end
    end
    return δ_orbit
end

function merge_timereversal_related_orbits(h_orbits :: Vector{<:HoppingOrbit})
    # for any orbit that contains a hopping vector `δ`, we check if its time-reversed
    # hopping vector `-δ` is also in the orbit; if not, we go looking for it in another
    # orbit - once we find it, we merge those two orbits

    # below, we assume that "complete" merging can be achieved between just two orbits:
    # that's not obviously the case, but seems likely - if counterexamples arise, we error

    # identify which `h_orbit`s should be merged, and with which partners
    merge_list = Vector{Tuple{Int, Int}}()
    for (n, h_orbit) in enumerate(h_orbits)
        δs = orbit(h_orbit)
        if all(δ -> isapproxin(-δ, δs, nothing, false), δs)
            # all δs have a -δ counterpart in the orbit: orbit is good as-is
            continue
        end
        # there's at least some δ that doesn't have a -δ counterpart: we pick any such
        # example and go looking for a counterpart in another orbit
        idx_δ = something(findfirst(δ′ -> !isapproxin(-δ′, δs, nothing, false), δs))
        δ = δs[idx_δ]
        rev_δ = -δ
        for n′ in n+1:length(h_orbits)
            any(p -> p[2]==n′, merge_list) && continue # already merged
            h_orbit′ = h_orbits[n′]
            δs′ = orbit(h_orbit′)
            found_partner = false
            if isapproxin(rev_δ, δs′, nothing, false)
                # we found a match: add the index of the orbit to the merge list
                push!(merge_list, (n, n′))
                merged_δs = vcat(δs, δs′)
                if any(δ′ -> !isapproxin(-δ′, merged_δs, nothing, false), merged_δs)
                    error("failed to combine δ to -δ orbits in single merger: unhandled case")
                end
                found_partner = true
                break
            end
            found_partner || error(lazy"failed to find a -δ partner for orbit #$n")
        end
    end

    # do the actual merging
    for (n, n′) in merge_list
        # we have to merge the two orbits: we take the first one and add the second
        # one to it, and then remove the second one from the list of hopping orbits
        h_orbit = h_orbits[n]
        h_orbit′ = h_orbits[n′]
        append!(orbit(h_orbit), orbit(h_orbit′))
        append!(h_orbit.hoppings, h_orbit′.hoppings)
    end

    # delete the "old" orbits
    if !isempty(merge_list)
        delete_ns = getindex.(merge_list, 2)
        deleteat!(h_orbits, delete_ns)
    end

    return h_orbits
end

# ---------------------------------------------------------------------------- #
# EBRs: (q|A), (w|B)
# Wyckoff positions: q, w
#   q: q1, ..., qN
#   w: w1, ..., wM
# Site symmetry irreps: A, B
#   A: A1, ..., AJ
#   B: B1, ..., BK
# δs = [δ1, δ2, ..., δn]
#   δ1: qi₁¹ -> wj₁¹, qi₁² -> wj₁², ...
#   δ2: qi₂¹ -> wj₂¹, qi₂² -> wj₂², ...
# v = [exp(ik⋅δ1), exp(ik⋅δ2), ..., exp(ik⋅δn)]
# t = [[t(δ1) ...], [t(δ2) ...], ..., [t(δn) ...]]
#   t(δ1): [t(qi₁ᵅ -> wj₁ᵅ, A_f -> B_g) ...]

# Current example: (1a|E), (2c|A)
#   ___w2__
#  |   x   |
#  |q1 x   x w1
#  |_______|
#   δs = [1/2x, -1/2x, 1/2y, -1/2y]
#      δ1: q1 -> w1 + G1
#      δ2: q1 -> w1 + G2
#      δ3: q1 -> w2 + G3
#      δ4: q1 -> w2 + G4
# t = [t(δ1)..., t(δ2)..., t(δ3)..., t(δ4)...]
#   t(δ1): [t(q1 -> w1, G1, E1 -> A1), t(q1 -> w1, G1, E2 -> A1)]
#   t(δ2): [t(q1 -> w1, G2, E1 -> A1), t(q1 -> w1, G2, E2 -> A1)]
#   t(δ3): [t(q1 -> w2, G3, E1 -> A1), t(q1 -> w2, G3, E2 -> A1)]
#   t(δ4): [t(q1 -> w2, G4, E1 -> A1), t(q1 -> w2, G4, E2 -> A1)]
# ---------------------------------------------------------------------------- #

"""
    OrbitalOrdering(br :: NewBandRep{D}) --> OrbitalOrdering{D}

Establishes a canonical, local ordering for the orbitals associated to a band representation
`br`. This is the default ordering used when associating row/column indices in a
tight-binding Hamiltonian block to specific orbitals in the associated band representations.

The canonical orbital ordering is stored in `.ordering`. The `i`th elements of `ordering`,
`ordering[i]`, is a `NamedTuple` with two fields:
`wp` and `idx`:
- `wp`: stores a Wyckoff position in the orbit of the Wyckoff position associated to
  `br.wp`.
- `idx`: stores the index of the partner function of the site-symmetry irrep associated to
  `br` at `wp`.

I.e., the `i`th orbital associated to `br` is located at `wp` and transforms as the `idx`th
partner function of the site-symmetry irrep of `br.siteir`.
The total number of orbitals associated to a band representation, and hence the length of
`ordering`, is the product of the site-symmetry irrep dimensionality and the number of sites
in the Wyckoff position orbit.
"""
function OrbitalOrdering(
    br::NewBandRep{D}
) where {D}
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    sgnum = num(br)
    cntr = centering(sgnum, D)
    wps = primitivize.(orbit(group(br)), cntr)

    V = length(wps)       # number of Wyckoff positions in orbit
    Q = irdim(br.siteir) # number of orbitals partner functions at each Wyckoff position
    ordering = Vector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}(undef, V * Q)
    for i in 1:V
        for k in 1:Q
            ordering[(i-1)*Q+k] = (; wp=wps[i], idx=k)
        end
    end
    return OrbitalOrdering(ordering)
end

"""
    construct_M_matrix(
        h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D},
        [ordering1, ordering2]) 
        --> Array{Int,4}

Construct a set of matrices that encodes a Hamiltonian's term which resembles the 
hopping from EBR `br1` to EBR `br2`.

The Hamiltonian's order which is implicitly used is returned as output, and the 
matrices are stored on a 4D matrix which last two axes indicate the Hamiltonian 
term position it is describing and the first axis refer to the `orbit(h_orbit)` 
and the second axis to the vector `t`. The idea is:

Hₛₜ = vᵢ Mᵢⱼₛₜ tⱼ

See `devdocs.md` for details.
"""
function construct_M_matrix(
    h_orbit::HoppingOrbit{D},
    br1::NewBandRep{D},
    br2::NewBandRep{D},
    ordering1::OrbitalOrdering{D} = OrbitalOrdering(br1), # canonical orbital orderings for
    ordering2::OrbitalOrdering{D} = OrbitalOrdering(br2)  # `br1` & `br2`, respectively
) where {D}
    V = length(orbit(h_orbit))
    E = length(first(h_orbit.hoppings)) # number of hopping terms per δᵢ (assumed constant for all i)
    foreach(h_orbit.hoppings) do hops
        length(hops) == E || error("Unexpectedly had different counts of hoppings across orbit elements")
    end
    Q1, Q2 = irdim(br1.siteir), irdim(br2.siteir)
    Q = Q1 * Q2

    # matrix of matrices that will store the matrix-encoding for each Hamiltonian element
    Mm = zeros(Int, V, V * E * Q, length(ordering1), length(ordering2))

    # fill in the unit-elements of `Mm`
    for α in eachindex(ordering1), β in eachindex(ordering2)
        (q, i) = ordering1[α]
        (w, j) = ordering2[β]
        q = parent(q)
        w = parent(w)

        # assign a 1 to the correct position of WPs times irreps dimensionality
        for (r, hops) in enumerate(h_orbit.hoppings)
            offset0 = (r - 1) * E * Q
            for (x, hop) in enumerate(hops)
                q′, w′ = hop[1], hop[2]
                if isapprox(q′, q, nothing, false) && isapprox(w′, w, nothing, false)
                    offset1 = (x - 1) * Q
                    c = offset0 + offset1 + (j - 1) * Q1 + i
                    Mm[r, c, α, β] = 1
                end
            end
        end
    end

    return Mm
end

# H_{s,t} = v_i M_{i,j,s,t} t_j

"""
    representation_constraints_matrices(
        Mm::Array{Int,4}, 
        brₐ::NewBandRep{D},
        brᵦ::NewBandRep{D}) --> Vector{Array{ComplexF64,4}}

Build the Q matrix for a particular symmetry operation (or, equivalently, a 
particular matrix from the site-symmetry representation), acting on the M matrix. 
Relative to our white-board notes, Q has swapped indices, in the sense we below 
give `Q[i,j,r,l]`.

(ρₐₐ)ᵣₛ Hₛₜ (ρᵦᵦ⁻¹)ₜₗ = (ρₐₐ)ᵣₛ vᵢ Mᵢⱼₛₜ tⱼ (ρᵦᵦ⁻¹)ₜₗ = vᵢ (ρₐₐ)ᵣₛ Mᵢⱼₛₜ (ρᵦᵦ⁻¹)ₜₗ tⱼ,

then we can define: Qᵢⱼᵣₗ = (ρₐₐ)ᵣₛ Mᵢⱼₛₜ (ρᵦᵦ⁻¹)ₜₗ
"""
function representation_constraint_matrices(
    Mm::AbstractArray{Int, 4},
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D}
) where {D}
    gensₐ, ρsₐₐ = sgrep_induced_by_siteir_generators(brₐ)
    gensᵦ, ρsᵦᵦ = sgrep_induced_by_siteir_generators(brᵦ)
    @assert gensₐ == gensᵦ # check that `sgrep_induced_by_siteir_generators` are consistent

    Qs = [zeros(ComplexF64, size(Mm)) for _ in eachindex(gensₐ)]
    for (n, (ρₐₐ, ρᵦᵦ)) in enumerate(zip(ρsₐₐ, ρsᵦᵦ))
        ρₐₐ = Matrix(ρₐₐ) # since `/` doesn't extend to BlockArrays currently
        ρᵦᵦ = Matrix(ρᵦᵦ) # for type consistency

        # we have constructed the representation matrices such that gΦ(k) = ρᵀ(g)Φ(Rk).
        # then, the Hamiltonian will be transformed due to symmetries as
        # H(RK) = ρₐₐ(g) H(k) ρᵦᵦ⁺(g), this can be translated into the numerical 
        # matrices as
        Q = Qs[n]
        for i in axes(Mm, 1), j in axes(Mm, 2)
            Q[i, j, :, :] .= ρₐₐ * Mm[i, j, :, :] * ρᵦᵦ'
        end
    end

    return Qs
end

"""
    obtain_basis_free_parameters(
        h_orbit::HoppingOrbit{D},
        brₐ::NewBandRep{D}, 
        brᵦ::NewBandRep{D}, 
        [orderingₐ = OrbitalOrdering(brₐ), orderingᵦ = OrbitalOrdering(brᵦ)];
        [timereversal::Bool = true]
        )                            --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}

Obtain the basis of free parameters for the hopping terms between `brₐ` and `brᵦ` 
associated with the hopping orbit `h_orbit`.
"""
function obtain_basis_free_parameters(
    h_orbit::HoppingOrbit{D},
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D},
    orderingₐ::OrbitalOrdering{D} = OrbitalOrdering(brₐ),
    orderingᵦ::OrbitalOrdering{D} = OrbitalOrdering(brᵦ);
    timereversal::Bool = true
) where {D}
    # We obtain the needed representations over the generators of each bandrep
    gensₐ = generators(num(brₐ), SpaceGroup{D})
    gensᵦ = generators(num(brᵦ), SpaceGroup{D})
    @assert gensₐ == gensᵦ # must be from same space group and in same sorting

    # cast generators to primitive basis
    cntr = centering(num(brₐ), D)
    gens = cntr ∈ ('P', 'p') ? gensₐ : primitivize.(gensₐ, cntr)

    # encode Hamiltonian as a coefficient matrix sandwiched by exponentials & hopping ampl.
    Mm = construct_M_matrix(h_orbit, brₐ, brᵦ, orderingₐ, orderingᵦ)

    # encode representation constraints on Hₐᵦ
    Qs = representation_constraint_matrices(Mm, brₐ, brᵦ)

    # encode reciprocal-rotation constraints on Hₐᵦ
    Zs = reciprocal_constraints_matrices(Mm, gens, h_orbit)

    # build an aggregate constraint matrix, over all generators, acting on the hopping
    # coefficient vector tₐᵦ associated with h_orbit
    constraint_vs = Vector{Vector{ComplexF64}}()
    for (Q, Z) in zip(Qs, Zs)
        for s in axes(Q, 3), t in axes(Q, 4)
            q = @view Q[:, :, s, t]
            z = @view Z[:, :, s, t]
            c = q - z
            filtered_rows = filter(r -> norm(r) > 1e-10, eachrow(c))
            isempty(filtered_rows) && continue # don't add empty constraints
            append!(constraint_vs, filtered_rows)
        end
    end
    constraints = stack(constraint_vs, dims=1)
    tₐᵦ_basis_matrix_form = nullspace(constraints; atol=NULLSPACE_ATOL_DEFAULT)

    # convert null-space to a sparse column form
    tₐᵦ_basis_matrix_form′ = _poormans_sparsification(tₐᵦ_basis_matrix_form)
    tₐᵦ_basis = [collect(v) for v in eachcol(tₐᵦ_basis_matrix_form′)]

    # prune near-zero elements of basis vectors
    _prune_at_threshold!(tₐᵦ_basis)

    # if there's no TRS constraints, we're done by now
    timereversal || return Mm, tₐᵦ_basis

    ## ----------------------------------------------------------------------------------- #
    # `timereversal` is `true`: we now "add" the associated TRS constraints

    # ** Step 0 **
    # If the set of basis vectors obtained from symmetry constraints was empty, there's no
    # point in continuing: we then return early
    isempty(tₐᵦ_basis) && return Mm, tₐᵦ_basis

    # ** Step 1 **
    # split up each potentially complex "basis" vector `tᵢ = tₐᵦ_basis[i]` into 2 real
    # vectors `x` and `y``, that represent the possible real and imaginary parts of `tᵢ`
    # multiplied by a complex scalar α, i.e., αtᵢ = Re(α)x + iIm(α)y, where x = real(αtᵢ) and
    # rewrite `tₐᵦ_basis` in the desired form t -> [real(t) real(im*t); imag(t) imag(im*t)] 
    # and store it as columns in a matrix. See `split_complex` details.

    #= 
    suppose we have `t₁ = [im,0]`, `t₂ = [1,im]`, and `tₐᵦ_basis = [t₁,t₂]`, then:
        ```
        julia> tₐᵦ_basis_split = split_complex.(tₐᵦ_basis)
        2-element Vector{Matrix{Int64}}:
         [0 -1; 0 0; 1 0; 0 0]
         [1 0; 0 -1; 0 1; 1 0]

        julia> tₐᵦ_basis_split_matrix = reduce(hcat, tₐᵦ_basis_split)
        4×4 Matrix{Int64}:
         0  -1  1   0
         0   0  0  -1
         1   0  0   1
         0   0  1   0
        ```
    =#
    tₐᵦ_basis_split = split_complex.(tₐᵦ_basis)
    tₐᵦ_basis_split_matrix = reduce(hcat, tₐᵦ_basis_split)

    # ** Step 2 **
    # now we want to construct the TRS constraints, and then intersect the allowable basis
    # terms on that constraint with those corresponding to the previously computed basis
    # NB: Under TRS, `Mm` is "doubled", i.e., `Mm_tr = [Mm Mm]`, to facilitate the splitting
    #     of complex-valued coefficient basis vectors into real-valued vectors.
    Mm_tr, tₐᵦ_basis_tr = obtain_basis_free_parameters_TRS(h_orbit, brₐ, brᵦ, orderingₐ, orderingᵦ, Mm)
    # NB: `tₐᵦ_basis_tr` is already in "doubled" representation (i.e., consequently real),
    #     so no need to split `tₐᵦ_basis_tr` via `split_complex`

    tₐᵦ_basis_tr_matrix = reduce(hcat, tₐᵦ_basis_tr)
    tₐᵦ_basis = zassenhaus_intersection(tₐᵦ_basis_split_matrix, tₐᵦ_basis_tr_matrix)

    return Mm_tr, tₐᵦ_basis
end

"""
    reciprocal_constraints_matrices(
                                    Mm::Array{Int,4}, 
                                    gens::AbstractVector{SymOperation{D}}, 
                                    h_orbit::HoppingOrbit{D}
                                    ) --> Vector{Array{Int,4}}

Compute the reciprocal constraints matrices for the generators of the SG. This is
done by permuting the rows of the M matrix according to the symmetry operation 
acting on k-space. See more details in
`permute_symmetry_related_hoppings_under_symmetry_operation` and `devdocs.md`.
"""
function reciprocal_constraints_matrices(
    Mm::Array{Int,4},
    gens::AbstractVector{SymOperation{D}},
    h_orbit::HoppingOrbit{D}
) where {D}
    Zs = Vector{Array{Int,4}}(undef, length(gens))
    for (i, op) in enumerate(gens)
        Z = zeros(Int, size(Mm))
        P = _permute_symmetry_related_hoppings_under_symmetry_operation(h_orbit, op)
        for l in axes(P, 2), j in axes(Mm, 2), s in axes(Mm, 3), t in axes(Mm, 4)
            Z[l, j, s, t] = sum(P[i, l] * Mm[i, j, s, t] for i in axes(P, 1))
            # vᵀ Ρᵀ Mₛₜ t => vₗ Ρᵀₗᵢ Mᵢⱼₛₜ tⱼ = vₗ Pᵢₗ Mᵢⱼₛₜ tⱼ
        end
        Zs[i] = Z
    end
    return Zs
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
         function for `reciprocal_constraints_matrices`.

Build the P matrix for a particular symmetry operation acting on k-space, which
permutes the rows of the M matrix.

For obtaining the P matrix, we make use that the action is on exponential of the
type: 𝐞(2πk⋅δ), to instead act on δ ∈ `h_orbit.orbit` instead of k, which is a
symbolic variable. Because of that, we need to use the inverse of the rotation
part of the symmetry operation. Sketch of the proof:

Assume g={R|τ} and `Crystalline` implements gk=(R⁻¹)ᵀk. Then (gk)⋅δ = 
((R⁻¹)ᵀk)⋅δ + τ = k⋅(R⁻¹)δ.

WARNING: we assume that the operation is primitive.
"""
function _permute_symmetry_related_hoppings_under_symmetry_operation(
    h_orbit::HoppingOrbit{D},
    op::SymOperation{D}
) where {D}
    # P is a square matrix that acts as `op` on `v`, i.e., represents ``op ∘ v``, via a
    # matrix-vector product `P*v`. Equivalently, `P` can act on `M` (via its transpose)
    # for expressions of the kind (Pv)ᵀM … = vᵀPᵀM …
    P = zeros(Int, length(orbit(h_orbit)), length(orbit(h_orbit)))
    for (i, δᵢ) in enumerate(orbit(h_orbit))
        # crystalline implements gk = [R⁻¹]ᵀk. However, since we don't have access to k,
        # being a symbolic variable, we will translate its action into δ. For this,
        # we implement a simple trick: ([R⁻¹]ᵀ k)·r = R⁻¹ᵢⱼ kᵢ rⱼ = k·(R⁻¹ r)
        R⁻¹ = SymOperation(inv(rotation(op))) # rotation-only part of `op`
        δᵢ′ = compose(R⁻¹, δᵢ)
        j = findfirst(δ′′ -> isapprox(δᵢ′, δ′′, nothing, false), orbit(h_orbit))
        isnothing(j) && error(lazy"hopping element $δᵢ not closed under $op in $(orbit(h_orbit))")
        P[i, j] = 1
        # since P acts as g v = P v, we have (gv)ᵢ = vⱼ = ∑ₖ Pᵢₖ vₖ so Pᵢₖ = δᵢⱼ
    end
    return P
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `obtain_basis_free_parameters`.

Poor man's "matrix sparsification" via the reduced row echelon form.
"""
function _poormans_sparsification(
    A::AbstractMatrix{<:Number};
    rref_tol::Union{Nothing,Float64}=SPARSIFICATION_ATOL_DEFAULT)
    # following appendix E of the Qsymm paper (https://arxiv.org/abs/1806.08363) [copied
    # over from Neumann.jl] [copied over from MPBUtils.jl]
    if !isnothing(rref_tol)
        # use a relatively low tolerance in `rref` to avoid explosions of errors
        # NB: this optional tolerance argument of `rref!` is undocumented :(
        return transpose(rref!(copy(transpose(A)), rref_tol))
    end
    return transpose(rref(transpose(A)))
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `obtain_basis_free_parameters`.

Prune near-zero elements of vectors in `vs`.
"""
function _prune_at_threshold!(
    vs::AbstractVector{<:AbstractVector{T}};
    atol::Real=PRUNE_ATOL_DEFAULT
) where {T<:Complex}
    for v in vs
        for (j, vⱼ) in enumerate(v)
            rⱼ, iⱼ = reim(vⱼ)
            rⱼ′ = ifelse(abs(rⱼ) < atol, zero(real(T)), rⱼ)
            iⱼ′ = ifelse(abs(iⱼ) < atol, zero(real(T)), iⱼ)
            v[j] = T(rⱼ′, iⱼ′)
        end
    end
    return vs
end

function _prune_at_threshold!(
    vs::AbstractVector{<:AbstractVector{T}};
    atol::Real=PRUNE_ATOL_DEFAULT
) where {T<:Real} # needed for type consistency in TRS implementation
    for v in vs
        for (j, vⱼ) in enumerate(v)
            v[j] = abs(vⱼ) < atol ? zero(T) : vⱼ
        end
    end
    return vs
end

# ---------------------------------------------------------------------------- #

"""
    tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) 
        --> Vector{BlockMatrix{TightBindingElementString,Matrix{TightBindingBlock{D}}}}

Construct the TB Hamiltonian matrix from a given composite band representation 
`cbr` and a set of global translation-representatives `Rs`. The Hamiltonian is 
constructed block by block according to the symmetry-related hoppings between the 
band representations in `cbr`. Several model are given back, one of closed in the 
symmetry operations.
"""
function tb_hamiltonian(
    cbr::CompositeBandRep{D},
    Rs::AbstractVector{Vector{Int}}; # "global" translation-representatives of hoppings
    timereversal::Bool=true,
) where {D}
    if any(c -> !isinteger(c) || c < 0, cbr.coefs)
        error("provided composite bandrep is not Wannierizable: contains negative or non-integer coefficients")
        # no TB model can be constructed for such a composite bandrep
    end
    coefs = round.(Int, cbr.coefs)

    # find all band representations involved in the composite band representation and list them
    brs = Vector{NewBandRep{D}}(undef, sum(coefs))
    idx = 0
    for (i, c) in enumerate(coefs)
        for _ in 1:c
            brs[idx+=1] = cbr.brs[i]
        end
    end

    # find all families of hoppings between involved band representations
    # the TB model will be divided into each of these representatives since they will be 
    # symmetry independent
    orbit_representatives = RVec{D}[]
    for br1 in brs
        for br2 in brs
            h_orbits = obtain_symmetry_related_hoppings(Rs, br1, br2)
            # TODO: maybe store them since we are going to use them again bellow
            for δ in Iterators.map(representative, h_orbits)
                if !isapproxin(δ, orbit_representatives, nothing, false)
                    push!(orbit_representatives, δ)
                end
            end
        end
    end

    # one determined the family of hopping terms closed by symmetry operations, we can build
    # the TB Hamiltonian block by block according to the bans representations in `brs`
    Norbs = count_bandrep_orbitals.(brs)
    tbs = [BlockMatrix{TightBindingElementString,Matrix{TightBindingBlock{D}}}(
        undef_blocks, Norbs, Norbs) for _ in orbit_representatives]
    c_idx_start = 1
    for (block_i, br1) in enumerate(brs)
        # TODO: maybe only need to go over upper triangular part of loop cf. hermiticity
        #       (br1 vs br2 ~ br2 vs. br1)?
        for (block_j, br2) in enumerate(brs)
            h_orbits = obtain_symmetry_related_hoppings(Rs, br1, br2)
            ordering1 = OrbitalOrdering(br1)
            ordering2 = OrbitalOrdering(br2)
            seen_n = Set{Int}()
            for h_orbit in h_orbits
                δ = representative(h_orbit)
                n = something(findfirst(δ′ -> isapprox(δ, δ′, nothing, false),
                    orbit_representatives)) # check where this δ is in the list of representatives
                                            # for include it in the right TB model
                push!(seen_n, n)
                Mm, t_αβ_basis = obtain_basis_free_parameters(
                                    h_orbit, br1, br2, ordering1, ordering2; timereversal)

                A = TightBindingBlock{D}(
                    (block_i, block_j),
                    (Norbs[block_i], Norbs[block_j]),
                    br1,
                    br2,
                    ordering1,
                    ordering2,
                    Mm,
                    t_αβ_basis,
                    h_orbit,
                    c_idx_start:c_idx_start+length(t_αβ_basis))
                tbs[n][Block(block_i), Block(block_j)] = A
                c_idx_start += length(t_αβ_basis)
            end
            # blocks for other values of `n` are not featured in `h_orbits` - i.e., vanish,
            # so we manually construct zero blocks for those spots:
            for n in eachindex(orbit_representatives)
                n ∈ seen_n && continue
                tbs[n][Block(block_i), Block(block_j)] = TightBindingBlock{D}(
                    (block_i, block_j), (Norbs[block_i], Norbs[block_j]), br1, br2,
                    ordering1, ordering2,
                    zeros(Int, 0, 0, length(ordering1), length(ordering2)), # Mm
                    Vector{Vector{ComplexF64}}(),                           # t_αβ_basis
                    nothing,                                                # h_orbit
                    1:0)                                                    # c_idxs (empty)
            end
        end
    end
    return tbs
end

"""
    count_bandrep_orbitals(br::NewBandRep{D}) --> Int

Counts the number of orbitals in a band representation `br`. This is done by taking 
the multiplicity of the Wyckoff position associated to `br`, dividing it by the 
centering volume fraction (excluding copies due to conventional setting) and 
multiplying it by the dimension of the site irrep.
"""
function count_bandrep_orbitals(br::NewBandRep{D}) where {D}
    mult = multiplicity(position(br)) # multiplicity in conventional setting
    # we need the Wyckoff multiplicity, excluding conventional-centering copies, so we
    # divide by the the number of centering-translations
    cntr = centering(num(br), D)
    denom = centering_volume_fraction(cntr, Val(D), Val(D))
    mult = div(mult, denom)

    return mult * irdim(br.siteir)
end

# ---------------------------------------------------------------------------- #
