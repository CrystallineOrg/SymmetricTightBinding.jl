"""
        obtain_symmetry_related_hoppings(
                                        Rs::AbstractVector{V}, 
                                        brₐ::NewBandRep{D}, 
                                        brᵦ::NewBandRep{D}
                                        ) where {V<:Union{AbstractVector{<:Integer},RVec{D}} where {D}
                                        --> Vector{HoppingOrbit{D}}

    Compute the symmetry related hopping terms from the points in WP of `brₐ` to the 
    WP of `brᵦ`displaced a set of primitive lattice vectors `Rs`.

    The vectors provided in `Rs` are just representatives. Because of symmetry 
    operations, bigger primitive lattice vectors could be found.

    How it works: 
    1. Take a point `a` in the WP of `brₐ` and a point `b` in the WP of `brᵦ`. We 
    compute the displacement vector `δ = b + R - a`, where `R ∈ Rs`.
    2. If `δ ∈ representatives` then we add `δ => (a, b, R)` to the list of hoppings 
        of that representative and continue. If not then, we search inside of all the 
        representatives for the one that `δ => (a, b, R)` in the list of hoppings. 
        If not found, then we add `δ` as a new representative and add `δ => (a, b, R)` 
        to its list of hoppings.
3. Take `g ∈ generators` and compute `δ' = g δ` and `(a', b', R') = (g a, g b, g R)`, 
    and repeat step 2.
4. Repeat all steps 1 to 3 for all pair of points in the WPs of `brₐ` and `brᵦ`.
"""
function obtain_symmetry_related_hoppings(
    Rs::AbstractVector{V}, # must be specified in the primitive basis
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D}
) where {V<:Union{AbstractVector{<:Integer},RVec{D}}} where {D}

    sgnum = num(brₐ)
    num(brᵦ) == sgnum || error("both band representations must be in the same space group")
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    cntr = centering(sgnum, D)
    ops = primitivize(spacegroup(sgnum, Val{D}()))
    wpsₐ = primitivize.(orbit(group(brₐ)), cntr)
    wpsᵦ = primitivize.(orbit(group(brᵦ)), cntr)


    # we have defined a structure `HoppingOrbit` to gather the information. It is 
    # structured as:
    # 1. `HoppingOrbit.representatives` will store a representative hopping vector δ
    # 2. `HoppingOrbit.orbit` will store the full orbit of symmetry related hopping 
    #   vector generated by δ: {δᵢ}
    # 3. `HoppingOrbit.hoppings` will store the real coordinates `(a,b,R)` of each 
    #   hopping term associated to each `δᵢ`. Note that maybe several `(a,b,R)` could be 
    #   associated to the same `δᵢ`

    h_orbits = HoppingOrbit{D}[]
    for R in Rs
        R = RVec{D}(R) # change the type of R for type consistency
        for (qₐ, qᵦ) in Iterators.product(wpsₐ, wpsᵦ)
            qₐ = parent(qₐ) # work with RVec directly rather than Wyckoff Position
            #                 (type consistent)
            qᵦ = parent(qᵦ)
            δ = qᵦ + R - qₐ # potential representative in next element of `h_orbits`
            maybe_add_hoppings!(h_orbits, δ, qₐ, qᵦ, R, ops)
            maybe_add_hoppings!(h_orbits, -δ, qᵦ, qₐ, -R, ops)
            # TODO (future): check if adding `δ` and `-δ` at the same time is a good idea
            # or it is better to consider it afterwards at hermiticity. Is this 
            # valid for any space group? Well yes, but they might be different if
            # nor inversion nor TRS are present
        end
    end
    return h_orbits
end

"""
    maybe_add_hoppings!(h_orbits, δ, qₐ, qᵦ, R, ops) --> Vector{HoppingOrbit{D}}

Checks if a hopping term `δ` is already in the list of representatives. If not, 
it adds it and its symmetry related partners. If it is, it only adds the symmetry 
related partners.
"""
function maybe_add_hoppings!(h_orbits, δ, qₐ, qᵦ, R, ops::AbstractVector{SymOperation{D}}) where {D}
    δ_idx = findfirst(h_orbits) do h_orbit
        isapproxin(δ, orbit(h_orbit), nothing, false) # check if δ is in h_orbits
    end
    if isnothing(δ_idx)
        # if it wasn't already in `h_orbits`, we add it and its symmetry-related partners
        δ_orbit = HoppingOrbit{D}(δ, [δ], [[(qₐ, qᵦ, R)]])
        _maybe_add_hoppings!(δ_orbit, δ, qₐ, qᵦ, R, ops)
        push!(h_orbits, δ_orbit)
    else # if it was already in `h_orbits`, we only add its symmetry-related partners
        δ_orbit = h_orbits[δ_idx]
        _maybe_add_hoppings!(δ_orbit, δ, qₐ, qᵦ, R, ops)
    end
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `maybe_add_hoppings!`.

Computes and adds the symmetry related partners of a hopping term `δ` to the 
`δ_orbit`.
"""
function _maybe_add_hoppings!(δ_orbit, δ, qₐ, qᵦ, R, ops::AbstractVector{SymOperation{D}}) where {D}
    for g in ops
        _qₐ′ = g * qₐ
        _qᵦ′ = g * (qᵦ + R)
        # _qₐ′ and _qᵦ′ could include a translation part that is a multiple of the lattice
        # translation, so we reduce it to a unit range and keep that translation part separate
        qₐ′ = RVec(reduce_translation_to_unitrange(constant(_qₐ′)), free(_qₐ′))
        qᵦ′ = RVec(reduce_translation_to_unitrange(constant(_qᵦ′)), free(_qᵦ′))
        dₐ = _qₐ′ - qₐ′ # possible lattice translation part of _qₐ′
        dᵦ = _qᵦ′ - qᵦ′ # possible lattice translation part of _qᵦ′

        R′ = dᵦ - dₐ # total lattice translation part of the symmetry-related hopping term δ'
        g_rotation = SymOperation(rotation(g)) # rotation-only part of g
        δ′ = g_rotation * δ # potential symmetry related partner of `δ` to add to `δ_orbit`

        # several sanity checks:
        #   1. R´ is a lattice translation, i.e., it is integer
        #   2. R´ doesn't have any free parameters - TODO: try to implement it for WPs with free parameters
        #   3. δ′ = qᵦ′ + R′ - qₐ′
        all(Rᵢ′ -> abs(Rᵢ′ - round(Rᵢ′)) < 1e-10, constant(R′)) || error("arrived at non-integer lattice translation R′: should be impossible")
        isspecial(R′) || error("arrived at non-special (nonzero free parameters) lattice translation R′: should be impossible")
        isapprox(δ′, qᵦ′ + R′ - qₐ′, nothing, false) || error("δ′ ≠ qᵦ′ + R′ - qₐ′")

        idx_in_orbit = findfirst(δ′′ -> isapprox(δ′, δ′′, nothing, false), orbit(δ_orbit))
        if isnothing(idx_in_orbit)
            # δ′ is not already included in `orbit(δ_orbit)`
            push!(orbit(δ_orbit), δ′)
            push!(δ_orbit.hoppings, [(qₐ′, qᵦ′, R′)])
        else
            # δ′ already in `orbit(δ_orbit)` but hopping term might not be:
            # evaluate `(qₐ′, qᵦ′, R′) ∉ δ_orbit.hoppings[idx_in_orbit]`, w/
            # approximate equality comparison
            bool = !any(δ_orbit.hoppings[idx_in_orbit]) do (qₐ′′, qᵦ′′, R′′)
                (isapprox(qₐ′, qₐ′′, nothing, false) && isapprox(qᵦ′, qᵦ′′, nothing, false)
                 && isapprox(R′, R′′, nothing, false))
            end
            if bool
                push!(δ_orbit.hoppings[idx_in_orbit], (qₐ′, qᵦ′, R′))
            end
        end
    end
    return δ_orbit
end

# ---------------------------------------------------------------------------- #
# EBRs: (q|A), (w|B)
# Wyckoff positions: q, w
#   q: q1, ..., qN
#   w: w1, ..., wM
# Site symmetry irreps: A, B
#   A: A1, ..., AJ
#   B: B1, ..., BK
# δs = [δ1, δ2, ..., δn]
#   δ1: qi₁¹ -> wj₁¹, qi₁² -> wj₁², ...
#   δ2: qi₂¹ -> wj₂¹, qi₂² -> wj₂², ...
# v = [exp(ik⋅δ1), exp(ik⋅δ2), ..., exp(ik⋅δn)]
# t = [[t(δ1) ...], [t(δ2) ...], ..., [t(δn) ...]]
#   t(δ1): [t(qi₁ᵅ -> wj₁ᵅ, A_f -> B_g) ...]

# Current example: (1a|E), (2c|A)
#   ___w2__
#  |   x   |
#  |q1 x   x w1
#  |_______|
#   δs = [1/2x, -1/2x, 1/2y, -1/2y]
#      δ1: q1 -> w1 + G1
#      δ2: q1 -> w1 + G2
#      δ3: q1 -> w2 + G3
#      δ4: q1 -> w2 + G4
# t = [t(δ1)..., t(δ2)..., t(δ3)..., t(δ4)...]
#   t(δ1): [t(q1 -> w1, G1, E1 -> A1), t(q1 -> w1, G1, E2 -> A1)]
#   t(δ2): [t(q1 -> w1, G2, E1 -> A1), t(q1 -> w1, G2, E2 -> A1)]
#   t(δ3): [t(q1 -> w2, G3, E1 -> A1), t(q1 -> w2, G3, E2 -> A1)]
#   t(δ4): [t(q1 -> w2, G4, E1 -> A1), t(q1 -> w2, G4, E2 -> A1)]
# ---------------------------------------------------------------------------- #

"""
    hamiltonian_term_order(br1::NewBandRep{D}, br2::NewBandRep{D}) 
        --> Matrix{Pair{Tuple{Int64,WyckoffPosition{D}}, Tuple{Int64,WyckoffPosition{D}}}}

Gives an order for the Hamiltonian's term concerning hopping between `br1` and 
`br2`. This is the default order used for building the TB Hamiltonian in 
`tb_hamiltonian`.

A matrix with the dimensions of the Hamiltonian is given back where each term 
indicates the hopping term considered in the Hamiltonian at that position.
"""
function hamiltonian_term_order(
    br1::NewBandRep{D},
    br2::NewBandRep{D},
) where {D}

    sgnum = num(br1)
    num(br2) == sgnum || error("Both band representations must be in the same space group")
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    cntr = centering(sgnum, D)
    wp1 = primitivize.(orbit(group(br1)), cntr)
    wp2 = primitivize.(orbit(group(br2)), cntr)

    V1, V2 = length(wp1), length(wp2)
    Q1, Q2 = irdim(br1.siteir), irdim(br2.siteir)
    T_pair_eltype = Tuple{Int64,WyckoffPosition{D}}
    order = Matrix{Pair{T_pair_eltype,T_pair_eltype}}(undef, V1 * Q1, V2 * Q2)
    for i in 1:V1
        for j in 1:V2
            for k in 1:Q1
                for l in 1:Q2
                    order[(i-1)*Q1+k, (j-1)*Q2+l] = (k, wp1[i]) => (l, wp2[j])
                end
            end
        end
    end
    return order
end

"""
    construct_M_matrix(h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D}, order) 
        --> Array{Int,4}

Construct a set of matrices that encodes a Hamiltonian's term which resembles the 
hopping from EBR `br1` to EBR `br2`.

The Hamiltonian's order which is implicitly used is returned as output, and the 
matrices are stored on a 4D matrix which last two axes indicate the Hamiltonian 
term position it is describing and the first axis refer to the `orbit(h_orbit)` 
and the second axis to the vector `t`. The idea is:

Hₛₜ = vᵢ Mᵢⱼₛₜ tⱼ

See `devdocs.md` for details.
"""
function construct_M_matrix(
    h_orbit::HoppingOrbit{D},
    br1::NewBandRep{D},
    br2::NewBandRep{D},
    order=hamiltonian_term_order(br1, br2) # an internal order for the Hamiltonian's terms
) where {D}
    V = length(orbit(h_orbit))
    E = length(first(h_orbit.hoppings)) # number of hopping terms per δᵢ (assumed constant for all i)
    foreach(h_orbit.hoppings) do hops
        length(hops) == E || error("Unexpectedly had different counts of hoppings across orbit elements")
    end
    Q1, Q2 = irdim(br1.siteir), irdim(br2.siteir)
    Q = Q1 * Q2

    # matrix of matrices that will store the matrices for each
    # Hamiltonian's term
    Mm = zeros(Int, V, V * E * Q, size(order, 1), size(order, 2))

    # fill in the unit-elements of `Mm`
    for α in axes(order, 1), β in axes(order, 2)
        (i, q), (j, w) = order[α, β]
        q = parent(q)
        w = parent(w)

        # assign a 1 to the correct position of WPs times irreps dimensionality
        for (r, hops) in enumerate(h_orbit.hoppings)
            offset0 = (r - 1) * E * Q
            for (x, hop) in enumerate(hops)
                if isapprox(hop[1], q, nothing, false) && isapprox(hop[2], w, nothing, false)
                    offset1 = (x - 1) * Q
                    c = offset0 + offset1 + (j - 1) * Q1 + i
                    Mm[r, c, α, β] = 1
                end
            end
        end
    end

    return Mm
end

# H_{s,t} = v_i M_{i,j,s,t} t_j

"""
    representation_constraints_matrices(
                                    Mm::Array{Int,4}, 
                                    gens::AbstractVector{SymOperation{D}}, 
                                    h_orbit::HoppingOrbit{D}
                                    ) --> Vector{Array{Complex,4}}

Build the Q matrix for a particular symmetry operation (or, equivalently, a 
particular matrix from the site-symmetry representation), acting on the M matrix. 
Relative to our white-board notes, Q has swapped indices, in the sense we below 
give `Q[i,j,r,l]`.

(ρₐₐ)ᵣₛ Hₛₜ / (ρᵦᵦ⁻¹)ₜₗ = (ρₐₐ)ᵣₛ vᵢ Mᵢⱼₛₜ tⱼ / (ρᵦᵦ⁻¹)ₜₗ = vᵢ (ρₐₐ)ᵣₛ Mᵢⱼₛₜ / 
(ρᵦᵦ⁻¹)ₜₗ tⱼ,

then we can define: Qᵢⱼᵣₗ = (ρₐₐ)ᵣₛ Mᵢⱼₛₜ / (ρᵦᵦ⁻¹)ₜₗ
"""
function representation_constraint_matrices(
    Mm::AbstractArray{<:Number,4},
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D}
) where {D}
    gensₐ, ρsₐₐ = sgrep_induced_by_siteir_generators(brₐ)
    gensᵦ, ρsᵦᵦ = sgrep_induced_by_siteir_generators(brᵦ)
    @assert gensₐ == gensᵦ # just a sanity check that `sgrep_induced_by_siteir_generators` is consistent

    Qs = Vector{Array{Complex,4}}(undef, length(gensₐ))
    for (n, (ρₐₐ, ρᵦᵦ)) in enumerate(zip(ρsₐₐ, ρsᵦᵦ))

        ρₐₐ = Matrix(ρₐₐ) # since `/` doesn't extend to BlockArrays currently
        ρᵦᵦ = Matrix(ρᵦᵦ) # for type consistency

        Q = zeros(ComplexF64, size(Mm))
        for i in axes(Mm, 1), j in axes(Mm, 2)
            Q[i, j, :, :] .= ρₐₐ * Mm[i, j, :, :] / ρᵦᵦ # = ρₐₐ * Mm[i, j, :, :] * inv(ρᵦᵦ)
        end
        Qs[n] = Q
    end
    return Qs
end

"""
    obtain_basis_free_parameters(
                                brₐ::NewBandRep{D}, 
                                brᵦ::NewBandRep{D}, 
                                h_orbit::HoppingOrbit{D}, 
                                order=hamiltonian_term_order(brₐ, brᵦ)
                                ) --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}, 
                                            Matrix{Pair{Tuple{Int,WyckoffPosition{D}},
                                                        Tuple{Int,WyckoffPosition{D}}}}

Obtain the basis of free parameters for the hopping terms between `brₐ` and `brᵦ` 
associated with the hopping orbit `h_orbit`. The Hamiltonian's default order is 
given by `order`.
"""
function obtain_basis_free_parameters(
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D},
    h_orbit::HoppingOrbit{D},
    order=hamiltonian_term_order(brₐ, brᵦ);
    time_reversal=false,
    hermiticity=false
) where {D}
    # We obtain the needed representations over the generators of each bandrep
    gensₐ = generators(num(brₐ), SpaceGroup{D})
    gensᵦ = generators(num(brᵦ), SpaceGroup{D})
    @assert gensₐ == gensᵦ # must be from same space group and in same sorting

    # cast generators to primitive basis
    cntr = centering(num(brₐ), D)
    gens = cntr ∈ ('P', 'p') ? gensₐ : primitivize.(gensₐ, cntr)

    # TODO: 

    # compute the tensor M that encodes the Hamiltonian as a numerical matrix
    Mm = construct_M_matrix(h_orbit, brₐ, brᵦ, order)

    # compute the Q tensor, encoding representation constraints on Hₐᵦ
    Qs = representation_constraint_matrices(Mm, brₐ, brᵦ)

    # compute the Z tensor, encoding reciprocal-rotation constraints on Hₐᵦ
    Zs = reciprocal_constraints_matrices(Mm, gens, h_orbit)

    # build an aggregate constraint matrix, over all generators, acting on the hopping
    # coefficient vector tₐᵦ associated with h_orbit
    constraint_vs = Vector{Vector{ComplexF64}}()
    for (Q, Z) in zip(Qs, Zs)
        for s in axes(Q, 3), t in axes(Q, 4)
            q = @view Q[:, :, s, t]
            z = @view Z[:, :, s, t]
            c = q - z
            filtered_rows = filter(r -> norm(r) > 1e-10, eachrow(c))
            isempty(filtered_rows) && continue # don't add empty constraints
            append!(constraint_vs, filtered_rows)
        end
    end
    constraints = stack(constraint_vs, dims=1)
    tₐᵦ_basis_matrix_form = nullspace(constraints; atol=NULLSPACE_ATOL_DEFAULT)

    # convert null-space to a sparse column form
    tₐᵦ_basis_matrix_form′ = _poormans_sparsification(tₐᵦ_basis_matrix_form)
    tₐᵦ_basis = [collect(v) for v in eachcol(tₐᵦ_basis_matrix_form′)]

    # prune near-zero elements of basis vectors
    _prune_at_threshold!(tₐᵦ_basis)

    Mm_final = Mm

    if time_reversal
        # rewrite `tₐᵦ_basis` in the desired form t -> [real(t) real(im*t); imag(t) imag(im*t)] 
        # and store it as columns in a matrix. Read `split_complex` docstring for details.
        tₐᵦ_basis_split = split_complex.(tₐᵦ_basis)
        tₐᵦ_basis_split_matrix = reduce(hcat, tₐᵦ_basis_split)

        # this works the following way:
        # julia> t₁ = [im,0]
        # 2-element Vector{Complex{Int64}}:
        # 0 + 1im
        # 0 + 0im

        # julia> t₂ = [1,im]
        # 2-element Vector{Complex{Int64}}:
        # 1 + 0im
        # 0 + 1im

        # julia> t_basis = [t₁,t₂]
        # 2-element Vector{Vector{Complex{Int64}}}:
        # [0 + 1im, 0 + 0im]
        # [1 + 0im, 0 + 1im]

        # julia> t_basis_split = TETB.split_complex.(t_basis)
        # 2-element Vector{Matrix{Int64}}:
        # [0 -1; 0 0; 1 0; 0 0]
        # [1 0; 0 -1; 0 1; 1 0]
        # julia> TETB.split_complex(t)
        # 4×2 Matrix{Int64}:
        # 1   0
        # 0  -1
        # 0   1
        # 1   0

        # julia> tₐᵦ_basis_split_matrix = reduce(hcat, t_basis_split)
        # 4×4 Matrix{Int64}:
        # 0  -1  1   0
        # 0   0  0  -1
        # 1   0  0   1
        # 0   0  1   0

        # julia>

        # obtain the TRS basis and intersect
        Mm_final, tₐᵦ_extra, _ = obtain_basis_free_parameters_TRS(brₐ, brᵦ, h_orbit, order)
        # WARNING: we are assuming that the returned `tₐᵦ_extra` is real, so no need to split

        tₐᵦ_extra_matrix = reduce(hcat, tₐᵦ_extra)
        tₐᵦ_basis = zassenhaus_intersection(tₐᵦ_basis_split_matrix, tₐᵦ_extra_matrix)
    end

    return Mm_final, tₐᵦ_basis, order
end

"""
    reciprocal_constraints_matrices(
                                    Mm::Array{Int,4}, 
                                    gens::AbstractVector{SymOperation{D}}, 
                                    h_orbit::HoppingOrbit{D}
                                    ) --> Vector{Array{Int,4}}

Compute the reciprocal constraints matrices for the generators of the SG. This is
done by permuting the rows of the M matrix according to the symmetry operation 
acting on k-space. See more details in
`permute_symmetry_related_hoppings_under_symmetry_operation` and `devdocs.md`.
"""
function reciprocal_constraints_matrices(
    Mm::Array{Int,4},
    gens::AbstractVector{SymOperation{D}},
    h_orbit::HoppingOrbit{D}
) where {D}
    Zs = Vector{Array{Int,4}}(undef, length(gens))
    for (i, op) in enumerate(gens)
        Z = zeros(Int, size(Mm))
        P = _permute_symmetry_related_hoppings_under_symmetry_operation(h_orbit, op)
        for l in axes(P, 2), j in axes(Mm, 2), s in axes(Mm, 3), t in axes(Mm, 4)
            Z[l, j, s, t] = sum(P[i, l] * Mm[i, j, s, t] for i in axes(P, 1))
            # vᵀ Ρᵀ Mₛₜ t => vₗ Ρᵀₗᵢ Mᵢⱼₛₜ tⱼ = vₗ Pᵢₗ Mᵢⱼₛₜ tⱼ
        end
        Zs[i] = Z
    end
    return Zs
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
         function for `reciprocal_constraints_matrices`.

Build the P matrix for a particular symmetry operation acting on k-space, which
permutes the rows of the M matrix.

For obtaining the P matrix, we make use that the action is on exponential of the
type: 𝐞(2πk⋅δ), to instead act on δ ∈ `h_orbit.orbit` instead of k, which is a
symbolic variable. Because of that, we need to use the inverse of the rotation
part of the symmetry operation. Sketch of the proof:

Assume g={R|τ} and `Crystalline` implements gk=(R⁻¹)ᵀk. Then (gk)⋅δ = 
((R⁻¹)ᵀk)⋅δ + τ = k⋅(R⁻¹)δ.

WARNING: we assume that the operation is primitive.
"""
function _permute_symmetry_related_hoppings_under_symmetry_operation(
    h_orbit::HoppingOrbit{D},
    op::SymOperation{D}
) where {D}
    P = zeros(Int, length(orbit(h_orbit)), length(orbit(h_orbit))) # square matrix acting on the rows of M (formally v)
    for (i, δᵢ) in enumerate(orbit(h_orbit))
        # crystalline implements that gk = (R⁻¹)ᵀk, then if we translate this operation into 
        # δ, we have that (gk)⋅δ = ((R⁻¹)ᵀk)⋅δ + τ = k⋅(R⁻¹)δ
        R⁻¹ = SymOperation(inv(rotation(op))) # inverse of rotation-only parts of `op`
        δᵢ′ = compose(R⁻¹, δᵢ)
        j = findfirst(δ′′ -> isapprox(δᵢ′, δ′′, nothing, false), orbit(h_orbit))
        isnothing(j) && error(lazy"hopping element $δᵢ not closed under $op in $(orbit(h_orbit))")
        P[i, j] = 1
        # P acts as g on v: g v = P v so (gv)ᵢ = vⱼ = ∑ₖ Pᵢₖ vₖ so Pᵢₖ = δᵢⱼ
    end
    return P
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `obtain_basis_free_parameters`.

Poor man's "matrix sparsification" via the reduced row echelon form.
"""
function _poormans_sparsification(
    A::AbstractMatrix{<:Number};
    rref_tol::Union{Nothing,Float64}=SPARSIFICATION_ATOL_DEFAULT)
    # following appendix E of the Qsymm paper (https://arxiv.org/abs/1806.08363) [copied
    # over from Neumann.jl] [copied over from MPBUtils.jl]
    if !isnothing(rref_tol)
        # use a relatively low tolerance in `rref` to avoid explosions of errors
        # NB: this optional tolerance argument of `rref!` is undocumented :(
        return transpose(rref!(copy(transpose(A)), rref_tol))
    end
    return transpose(rref(transpose(A)))
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `obtain_basis_free_parameters`.

Prune near-zero elements of vectors in `vs`.
"""
function _prune_at_threshold!(
    vs::AbstractVector{<:AbstractVector{T}};
    atol::Real=PRUNE_ATOL_DEFAULT
) where {T<:Complex}

    for v in vs
        for (j, vⱼ) in enumerate(v)
            rⱼ, iⱼ = reim(vⱼ)
            rⱼ′ = ifelse(abs(rⱼ) < atol, zero(real(T)), rⱼ)
            iⱼ′ = ifelse(abs(iⱼ) < atol, zero(real(T)), iⱼ)
            v[j] = T(rⱼ′, iⱼ′)
        end
    end
    return vs
end

# ---------------------------------------------------------------------------- #

"""
    tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) 
        --> Vector{BlockMatrix{TightBindingElementString,Matrix{TightBindingBlock{D}}}}

Construct the TB Hamiltonian matrix from a given composite band representation 
`cbr` and a set of global translation-representatives `Rs`. The Hamiltonian is 
constructed block by block according to the symmetry-related hoppings between the 
band representations in `cbr`. Several model are given back, one of closed in the 
symmetry operations.
"""
function tb_hamiltonian(
    cbr::CompositeBandRep{D},
    Rs::AbstractVector{Vector{Int}} # "global" translation-representatives of hoppings to
    # consider
) where {D}
    if any(c -> !isinteger(c) || c < 0, cbr.coefs)
        error("provided composite bandrep is not Wannierizable: contains negative or non-integer coefficients")
        # no TB model can be constructed for such a composite bandrep
    end
    coefs = round.(Int, cbr.coefs)

    # find all band representations involved in the composite band representation and list them
    brs = Vector{NewBandRep{D}}(undef, sum(coefs))
    idx = 0
    for (i, c) in enumerate(coefs)
        for _ in 1:c
            brs[idx+=1] = cbr.brs[i]
        end
    end

    # find all families of hoppings between involved band representations
    # the TB model will be divided into each of these representatives since they will be 
    # symmetry independent
    orbit_representatives = RVec{D}[]
    for br1 in brs
        for br2 in brs
            h_orbits = obtain_symmetry_related_hoppings(Rs, br1, br2)
            # TODO: maybe store them since we are going to use them again bellow
            for δ in Iterators.map(representative, h_orbits)
                if !isapproxin(δ, orbit_representatives, nothing, false)
                    push!(orbit_representatives, δ)
                end
            end
        end
    end

    # one determined the family of hopping terms closed by symmetry operations, we can build
    # the TB Hamiltonian block by block according to the bans representations in `brs`
    Norbs = count_bandrep_orbitals.(brs)
    tbs = [BlockMatrix{TightBindingElementString,Matrix{TightBindingBlock{D}}}(
        undef_blocks, Norbs, Norbs) for _ in orbit_representatives]
    c_idx_start = 1
    for (block_i, br1) in enumerate(brs)
        # TODO: maybe only need to go over upper triangular part of loop cf. hermiticity
        #       (br1 vs br2 ~ br2 vs. br1)?
        for (block_j, br2) in enumerate(brs)
            h_orbits = obtain_symmetry_related_hoppings(Rs, br1, br2)
            seen_n = Set{Int}()
            order = hamiltonian_term_order(br1, br2)
            for h_orbit in h_orbits
                δ = representative(h_orbit)
                n = something(findfirst(δ′ -> isapprox(δ, δ′, nothing, false),
                    orbit_representatives)) # check where this δ is in the list of representatives
                #                             for include it in the right TB model
                push!(seen_n, n)
                Mm, t_αβ_basis, _ = obtain_basis_free_parameters(br1, br2, h_orbit, order)

                A = TightBindingBlock{D}(
                    (block_i, block_j), (Norbs[block_i], Norbs[block_j]), br1, br2,
                    order, Mm, t_αβ_basis, h_orbit,
                    c_idx_start:c_idx_start+length(t_αβ_basis))
                tbs[n][Block(block_i), Block(block_j)] = A
                c_idx_start += length(t_αβ_basis)
            end
            # blocks for other values of `n` are not featured in `h_orbits` - i.e., vanish,
            # so we manually construct zero blocks for those spots:
            for n in eachindex(orbit_representatives)
                n ∈ seen_n && continue
                tbs[n][Block(block_i), Block(block_j)] = TightBindingBlock{D}(
                    (block_i, block_j), (Norbs[block_i], Norbs[block_j]), br1, br2,
                    order,
                    zeros(Int, 0, 0, size(order, 1), size(order, 2)), # Mm
                    Vector{Vector{ComplexF64}}(),                     # t_αβ_basis
                    nothing,                                          # h_orbit
                    1:0)                                              # c_idxs (empty)
            end
        end
    end
    return tbs
end

"""
    count_bandrep_orbitals(br::NewBandRep{D}) --> Int

Counts the number of orbitals in a band representation `br`. This is done by taking 
the multiplicity of the Wyckoff position associated to `br`, dividing it by the 
centering volume fraction (excluding copies due to conventional setting) and 
multiplying it by the dimension of the site irrep.
"""
function count_bandrep_orbitals(br::NewBandRep{D}) where {D}
    mult = multiplicity(position(br)) # multiplicity in conventional setting
    # we need the Wyckoff multiplicity, excluding conventional-centering copies, so we
    # divide by the the number of centering-translations
    cntr = centering(num(br), D)
    denom = centering_volume_fraction(cntr, Val(D), Val(D))
    mult = div(mult, denom)

    return mult * irdim(br.siteir)
end

# ---------------------------------------------------------------------------- #
