"""
    obtain_symmetry_related_hoppings(
        Rs::AbstractVector{V}, 
        br‚Çê::NewBandRep{D}, 
        br·µ¶::NewBandRep{D},
        timereversal::Bool = br‚Çê.timereversal
        ) where {V<:Union{AbstractVector{<:Integer},RVec{D}} where {D}
        --> Vector{HoppingOrbit{D}}

    Compute the symmetry related hopping terms from the points in WP of `br‚Çê` to the 
    WP of `br·µ¶`displaced a set of primitive lattice vectors `Rs`.

    The vectors provided in `Rs` are just representatives. Because of symmetry 
    operations, bigger primitive lattice vectors could be found.

    How it works: 
    1. Take a point `a` in the WP of `br‚Çê` and a point `b` in the WP of `br·µ¶`. We 
    compute the displacement vector `Œ¥ = b + R - a`, where `R ‚àà Rs`.
    2. If `Œ¥ ‚àà representatives` then we add `Œ¥ => (a, b, R)` to the list of hoppings 
        of that representative and continue. If not then, we search inside of all the 
        representatives for the one that `Œ¥ => (a, b, R)` in the list of hoppings. 
        If not found, then we add `Œ¥` as a new representative and add `Œ¥ => (a, b, R)` 
        to its list of hoppings.
    3. Take `g ‚àà generators` and compute `Œ¥' = g Œ¥` and `(a', b', R') = (g a, g b, g R)`, 
        and repeat step 2.
    4. Repeat all steps 1 to 3 for all pair of points in the WPs of `br‚Çê` and `br·µ¶`.

    Additionally, if we have time-reversal symmetry, we check if orbits that relate `Œ¥` and 
    `-Œ¥` are present if not we add them.
"""
function obtain_symmetry_related_hoppings(
    Rs::AbstractVector{V}, # must be specified in the primitive basis
    br‚Çê::NewBandRep{D},
    br·µ¶::NewBandRep{D},
    timereversal::Bool = br‚Çê.timereversal,
) where {V <: Union{AbstractVector{<:Integer}, RVec{D}}} where {D}
    sgnum = num(br‚Çê)
    num(br·µ¶) == sgnum || error("both band representations must be in the same space group")
    br‚Çê.timereversal == br·µ¶.timereversal ||
        error("both band representations must have the same time-reversal symmetry")
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    cntr = centering(sgnum, D)
    ops = primitivize(spacegroup(sgnum, Val{D}()))
    wps‚Çê = primitivize.(orbit(group(br‚Çê)), cntr)
    wps·µ¶ = primitivize.(orbit(group(br·µ¶)), cntr)

    # we have defined a structure `HoppingOrbit` to gather the information. It is 
    # structured as:
    # 1. `HoppingOrbit.representatives` will store a representative hopping vector Œ¥
    # 2. `HoppingOrbit.orbit` will store the full orbit of symmetry related hopping 
    #   vector generated by Œ¥: {Œ¥·µ¢}
    # 3. `HoppingOrbit.hoppings` will store the real coordinates `(a,b,R)` of each 
    #   hopping term associated to each `Œ¥·µ¢`. Note that maybe several `(a,b,R)` could be 
    #   associated to the same `Œ¥·µ¢`

    h_orbits = HoppingOrbit{D}[]
    for R in Rs
        R = RVec{D}(R) # change the type of R for type consistency
        for (q‚Çê, q·µ¶) in Iterators.product(wps‚Çê, wps·µ¶)
            q‚Çê = parent(q‚Çê) # work with RVec directly rather than Wyckoff Position
            q·µ¶ = parent(q·µ¶)
            Œ¥ = q·µ¶ + R - q‚Çê # potential representative in next element of `h_orbits`
            maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops)
        end
    end

    # timereversal could link orbits that spatial symmetries alone would categorize as
    # distinct; in particular, if we have timereversal, a hopping vector `Œ¥` must
    # have a counterpart `-Œ¥` - but those two vectors could have fallen into distinct
    # hopping orbits at this point; if so, we must merge them
    if timereversal
        add_timereversal_related_orbits!(h_orbits)
    end

    return h_orbits
end

"""
    maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops) --> Vector{HoppingOrbit{D}}

Checks if a hopping term `Œ¥` is already in the list of representatives. If not, 
it adds it and its symmetry related partners. If it is, it only adds the symmetry 
related partners.
"""
function maybe_add_hoppings!(
    h_orbits,
    Œ¥,
    q‚Çê,
    q·µ¶,
    R,
    ops::AbstractVector{SymOperation{D}},
) where {D}
    Œ¥_idx = findfirst(h_orbits) do h_orbit
        isapproxin(Œ¥, orbit(h_orbit), nothing, false) # check if Œ¥ is in h_orbits
    end
    if isnothing(Œ¥_idx)
        # if it wasn't already in `h_orbits`, we add it and its symmetry-related partners
        Œ¥_orbit = HoppingOrbit{D}(Œ¥, [Œ¥], [[(q‚Çê, q·µ¶, R)]])
        push!(h_orbits, Œ¥_orbit)
    else # if it was already in `h_orbits`, we only add its symmetry-related partners
        Œ¥_orbit = h_orbits[Œ¥_idx]
    end
    _maybe_add_hoppings!(Œ¥_orbit, Œ¥, q‚Çê, q·µ¶, R, ops)
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `maybe_add_hoppings!`.

Computes and adds the symmetry related partners of a hopping term `Œ¥` to the 
`Œ¥_orbit`.
"""
function _maybe_add_hoppings!(
    Œ¥_orbit,
    Œ¥,
    q‚Çê,
    q·µ¶,
    R,
    ops::AbstractVector{SymOperation{D}},
) where {D}
    for g in ops
        _q‚Çê‚Ä≤ = g * q‚Çê
        _q·µ¶‚Ä≤ = g * (q·µ¶ + R)
        # _q‚Çê‚Ä≤ and _q·µ¶‚Ä≤ could include a translation part that is a multiple of the lattice
        # translation, so we reduce it to a unit range and keep that translation part separate
        q‚Çê‚Ä≤ = RVec(reduce_translation_to_unitrange(constant(_q‚Çê‚Ä≤)), free(_q‚Çê‚Ä≤))
        q·µ¶‚Ä≤ = RVec(reduce_translation_to_unitrange(constant(_q·µ¶‚Ä≤)), free(_q·µ¶‚Ä≤))
        d‚Çê = _q‚Çê‚Ä≤ - q‚Çê‚Ä≤ # possible lattice translation part of _q‚Çê‚Ä≤
        d·µ¶ = _q·µ¶‚Ä≤ - q·µ¶‚Ä≤ # possible lattice translation part of _q·µ¶‚Ä≤

        R‚Ä≤ = d·µ¶ - d‚Çê # total lattice translation part of the symmetry-related hopping term Œ¥'
        g_rotation = SymOperation(rotation(g)) # rotation-only part of g
        Œ¥‚Ä≤ = g_rotation * Œ¥ # potential symmetry related partner of `Œ¥` to add to `Œ¥_orbit`

        # several sanity checks:
        #   1. R¬¥ is a lattice translation, i.e., it is integer
        #   2. R¬¥ doesn't have any free parameters - TODO: try to implement it for WPs with free parameters
        #   3. Œ¥‚Ä≤ = q·µ¶‚Ä≤ + R‚Ä≤ - q‚Çê‚Ä≤
        all(R·µ¢‚Ä≤ -> abs(R·µ¢‚Ä≤ - round(R·µ¢‚Ä≤)) < 1e-10, constant(R‚Ä≤)) ||
            error("arrived at non-integer lattice translation R‚Ä≤: should be impossible")
        isspecial(R‚Ä≤) || error(
            "arrived at non-special (nonzero free parameters) lattice translation R‚Ä≤: should be impossible",
        )
        isapprox(Œ¥‚Ä≤, q·µ¶‚Ä≤ + R‚Ä≤ - q‚Çê‚Ä≤, nothing, false) || error("Œ¥‚Ä≤ ‚â† q·µ¶‚Ä≤ + R‚Ä≤ - q‚Çê‚Ä≤")

        idx_in_orbit = findfirst(Œ¥‚Ä≤‚Ä≤ -> isapprox(Œ¥‚Ä≤, Œ¥‚Ä≤‚Ä≤, nothing, false), orbit(Œ¥_orbit))
        if isnothing(idx_in_orbit)
            # Œ¥‚Ä≤ is not already included in `orbit(Œ¥_orbit)`
            push!(orbit(Œ¥_orbit), Œ¥‚Ä≤)
            push!(Œ¥_orbit.hoppings, [(q‚Çê‚Ä≤, q·µ¶‚Ä≤, R‚Ä≤)])
        else
            # Œ¥‚Ä≤ already in `orbit(Œ¥_orbit)` but hopping term might not be:
            # evaluate `(q‚Çê‚Ä≤, q·µ¶‚Ä≤, R‚Ä≤) ‚àâ Œ¥_orbit.hoppings[idx_in_orbit]`, w/
            # approximate equality comparison
            bool =
                !any(Œ¥_orbit.hoppings[idx_in_orbit]) do (q‚Çê‚Ä≤‚Ä≤, q·µ¶‚Ä≤‚Ä≤, R‚Ä≤‚Ä≤)
                    (
                        isapprox(q‚Çê‚Ä≤, q‚Çê‚Ä≤‚Ä≤, nothing, false) &&
                        isapprox(q·µ¶‚Ä≤, q·µ¶‚Ä≤‚Ä≤, nothing, false) &&
                        isapprox(R‚Ä≤, R‚Ä≤‚Ä≤, nothing, false)
                    )
                end
            if bool
                push!(Œ¥_orbit.hoppings[idx_in_orbit], (q‚Çê‚Ä≤, q·µ¶‚Ä≤, R‚Ä≤))
            end
        end
    end
    return Œ¥_orbit
end

function add_timereversal_related_orbits!(h_orbits::Vector{HoppingOrbit{D}}) where {D}
    # for any orbit that contains a hopping vector `Œ¥`, we check if its time-reversed
    # hopping vector `-Œ¥` is also in the orbit; if not, we check if it is in any other
    # orbit to merge them, and, if not, we add it manually to the orbit

    # below, we assume that if for some Œ¥ no counterpart is found, then no other Œ¥ in the
    # orbit has a counterpart, so we can just add it manually

    # determine if `h_orbit`s should be modified
    for (n, h_orbit) in enumerate(h_orbits)
        Œ¥s = orbit(h_orbit) # Œ¥s in the current orbit

        # check if the orbit is already "good" (i.e., all Œ¥s have a -Œ¥ counterpart)
        if all(Œ¥ -> isapproxin(-Œ¥, Œ¥s, nothing, false), Œ¥s)
            # all Œ¥s have a -Œ¥ counterpart in the orbit: orbit is good as-is
            continue
        end
        
        merge_idx = findfirst(
            h_orbit‚Ä≤-> isapproxin(Œ¥s[1], orbit(h_orbit‚Ä≤), nothing, false)),
            @view h_orbits[n+1:end],
        )
        if !isnothing(merge_idx)
            # at least one Œ¥ has a -Œ¥ counterpart in another orbit - we need to merge them
            # TODO: I will assume that if one Œ¥ has a -Œ¥ counterpart in another orbit, then all
            # Œ¥s in the orbit have a -Œ¥ counterpart in the same orbit, so we merge them
            n‚Ä≤ = something(idx_merge) + n
            h_orbit‚Ä≤ = h_orbits[n‚Ä≤]

            # merge the orbits
            append!(h_orbit.orbit, h_orbit‚Ä≤.orbit)
            append!(h_orbit.hoppings, h_orbit‚Ä≤.hoppings)

            # remove the merged orbit
            deleteat!(h_orbits, n‚Ä≤)
            continue
        end
        # we now know that at least some Œ¥ doesn't have a -Œ¥ counterpart: we assume that
        # this implies that none of the Œ¥s have a -Œ¥ counterpart, so we need to add them all
        @assert all(Œ¥ -> !isapproxin(-Œ¥, Œ¥s, nothing, false), Œ¥s)

        # first append the new Œ¥s into the orbit
        append!(Œ¥s, -Œ¥s)

        # add the "reversed" hopping terms: i.e., for every a + Œ¥ = b + R, add b + (-Œ¥) = a + (-R)
        hops_orbit = h_orbit.hoppings
        hops_orbit‚Ä≤ = Vector{Tuple{RVec, RVec, RVec}}[] # TODO: maybe to many (unnecessary) allocations
        for hops in hops_orbit
            hops‚Ä≤ = Tuple{RVec, RVec, RVec}[] # new vector to store the new hopping terms
            for (q‚Çê, q·µ¶, R) in hops
                # we need to add the new hopping terms to the vector. the term will be the 
                # reversed hopping term, i.e., b - Œ¥ = a - R, which gives rise to -Œ¥
                push!(hops‚Ä≤, (q·µ¶, q‚Çê, -R))
            end
            push!(hops_orbit‚Ä≤, hops‚Ä≤)
        end
        append!(hops_orbit, hops_orbit‚Ä≤)
    end
end

# ---------------------------------------------------------------------------- #
# EBRs: (q|A), (w|B)
# Wyckoff positions: q, w
#   q: q1, ..., qN
#   w: w1, ..., wM
# Site symmetry irreps: A, B
#   A: A1, ..., AJ
#   B: B1, ..., BK
# Œ¥s = [Œ¥1, Œ¥2, ..., Œ¥n]
#   Œ¥1: qi‚ÇÅ¬π -> wj‚ÇÅ¬π, qi‚ÇÅ¬≤ -> wj‚ÇÅ¬≤, ...
#   Œ¥2: qi‚ÇÇ¬π -> wj‚ÇÇ¬π, qi‚ÇÇ¬≤ -> wj‚ÇÇ¬≤, ...
# v = [exp(ik‚ãÖŒ¥1), exp(ik‚ãÖŒ¥2), ..., exp(ik‚ãÖŒ¥n)]
# t = [[t(Œ¥1) ...], [t(Œ¥2) ...], ..., [t(Œ¥n) ...]]
#   t(Œ¥1): [t(qi‚ÇÅ·µÖ -> wj‚ÇÅ·µÖ, A_f -> B_g) ...]

# Current example: (1a|E), (2c|A)
#   ___w2__
#  |   x   |
#  |q1 x   x w1
#  |_______|
#   Œ¥s = [1/2x, -1/2x, 1/2y, -1/2y]
#      Œ¥1: q1 -> w1 + G1
#      Œ¥2: q1 -> w1 + G2
#      Œ¥3: q1 -> w2 + G3
#      Œ¥4: q1 -> w2 + G4
# t = [t(Œ¥1)..., t(Œ¥2)..., t(Œ¥3)..., t(Œ¥4)...]
#   t(Œ¥1): [t(q1 -> w1, G1, E1 -> A1), t(q1 -> w1, G1, E2 -> A1)]
#   t(Œ¥2): [t(q1 -> w1, G2, E1 -> A1), t(q1 -> w1, G2, E2 -> A1)]
#   t(Œ¥3): [t(q1 -> w2, G3, E1 -> A1), t(q1 -> w2, G3, E2 -> A1)]
#   t(Œ¥4): [t(q1 -> w2, G4, E1 -> A1), t(q1 -> w2, G4, E2 -> A1)]
# ---------------------------------------------------------------------------- #

"""
    OrbitalOrdering(br :: NewBandRep{D}) --> OrbitalOrdering{D}

Establishes a canonical, local ordering for the orbitals associated to a band representation
`br`. This is the default ordering used when associating row/column indices in a
tight-binding Hamiltonian block to specific orbitals in the associated band representations.

The canonical orbital ordering is stored in `.ordering`. The `i`th elements of `ordering`,
`ordering[i]`, is a `NamedTuple` with two fields:
`wp` and `idx`:
- `wp`: stores a Wyckoff position in the orbit of the Wyckoff position associated to
  `br.wp`.
- `idx`: stores the index of the partner function of the site-symmetry irrep associated to
  `br` at `wp`.

I.e., the `i`th orbital associated to `br` is located at `wp` and transforms as the `idx`th
partner function of the site-symmetry irrep of `br.siteir`.
The total number of orbitals associated to a band representation, and hence the length of
`ordering`, is the product of the site-symmetry irrep dimensionality and the number of sites
in the Wyckoff position orbit.
"""
function OrbitalOrdering(br::NewBandRep{D}) where {D}
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    sgnum = num(br)
    cntr = centering(sgnum, D)
    wps = primitivize.(orbit(group(br)), cntr)

    V = length(wps)       # number of Wyckoff positions in orbit
    Q = irdim(br.siteir) # number of orbitals partner functions at each Wyckoff position
    ordering = Vector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}(undef, V * Q)
    for i in 1:V
        for k in 1:Q
            ordering[(i-1)*Q+k] = (; wp = wps[i], idx = k)
        end
    end
    return OrbitalOrdering(ordering)
end

"""
    construct_M_matrix(
        h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D},
        [ordering1, ordering2]) 
        --> Array{Int,4}

Construct a set of matrices that encodes a Hamiltonian's term which resembles the 
hopping from EBR `br1` to EBR `br2`.

The encoding is stored as a 4D matrix. Its last two axes correspond to elements of the
Bloch Hamiltonian H(k); its first axis corresponds to `orbit(h_orbit)` and the associated
complex exponentials stored in `v`; and its second axis to the elements of the vector `t`.
That is:

    H‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º

See `devdocs.md` for details.
"""
function construct_M_matrix(
    h_orbit::HoppingOrbit{D},
    br1::NewBandRep{D},
    br2::NewBandRep{D},
    ordering1::OrbitalOrdering{D} = OrbitalOrdering(br1), # canonical orbital orderings for
    ordering2::OrbitalOrdering{D} = OrbitalOrdering(br2),  # `br1` & `br2`, respectively
) where {D}
    V = length(orbit(h_orbit))
    E = length(first(h_orbit.hoppings)) # number of hopping terms per Œ¥·µ¢ (assumed constant for all i)
    foreach(h_orbit.hoppings) do hops
        length(hops) == E ||
            error("Unexpectedly had different counts of hoppings across orbit elements")
    end
    Q1, Q2 = irdim(br1.siteir), irdim(br2.siteir)
    Q = Q1 * Q2

    # matrix of matrices that will store the matrix-encoding for each Hamiltonian element
    Mm = zeros(Int, V, V * E * Q, length(ordering1), length(ordering2))

    # fill in the unit-elements of `Mm`
    for Œ± in eachindex(ordering1), Œ≤ in eachindex(ordering2)
        (q, i) = ordering1[Œ±]
        (w, j) = ordering2[Œ≤]
        q = parent(q)
        w = parent(w)

        # assign a 1 to the correct position of WPs times irreps dimensionality
        for (r, hops) in enumerate(h_orbit.hoppings)
            offset0 = (r - 1) * E * Q
            for (x, hop) in enumerate(hops)
                q‚Ä≤, w‚Ä≤ = hop[1], hop[2]
                if isapprox(q‚Ä≤, q, nothing, false) && isapprox(w‚Ä≤, w, nothing, false)
                    offset1 = (x - 1) * Q
                    c = offset0 + offset1 + (j - 1) * Q1 + i
                    Mm[r, c, Œ±, Œ≤] = 1
                end
            end
        end
    end

    return Mm
end

# H_{s,t} = v_i M_{i,j,s,t} t_j

"""
    representation_constraints_matrices(
        Mm::Array{Int,4}, 
        br‚Çê::NewBandRep{D},
        br·µ¶::NewBandRep{D}) --> Vector{Array{ComplexF64,4}}

Build the Q matrix for a particular symmetry operation (or, equivalently, a 
particular matrix from the site-symmetry representation), acting on the M matrix. 
Relative to our white-board notes, Q has swapped indices, in the sense we below 
give `Q[i,j,r,l]`.

(œÅ‚Çê‚Çê)·µ£‚Çõ H‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ v·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = v·µ¢ (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó t‚±º,

then we can define: Q·µ¢‚±º·µ£‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó
"""
function representation_constraint_matrices(
    Mm::AbstractArray{Int, 4},
    br‚Çê::NewBandRep{D},
    br·µ¶::NewBandRep{D},
) where {D}
    gens‚Çê, œÅs‚Çê‚Çê = sgrep_induced_by_siteir_generators(br‚Çê)
    gens·µ¶, œÅs·µ¶·µ¶ = sgrep_induced_by_siteir_generators(br·µ¶)
    @assert gens‚Çê == gens·µ¶ # check that `sgrep_induced_by_siteir_generators` are consistent

    Qs = [similar(Mm, ComplexF64) for _ in eachindex(gens‚Çê)]
    for (n, (œÅ‚Çê‚Çê, œÅ·µ¶·µ¶)) in enumerate(zip(œÅs‚Çê‚Çê, œÅs·µ¶·µ¶))
        œÅ‚Çê‚Çê = Matrix(œÅ‚Çê‚Çê) # since `/` doesn't extend to BlockArrays currently
        œÅ·µ¶·µ¶ = Matrix(œÅ·µ¶·µ¶) # for type consistency

        # we have constructed the representation matrices such that gŒ¶(k) = œÅ·µÄ(g)Œ¶(Rk).
        # then, the Hamiltonian will be transformed due to symmetries as
        # H(RK) = œÅ‚Çê‚Çê(g) H(k) œÅ·µ¶·µ¶‚Å∫(g), this can be translated into the numerical 
        # matrices as
        Q = Qs[n]
        for i in axes(Mm, 1), j in axes(Mm, 2)
            Q[i, j, :, :] .= œÅ‚Çê‚Çê * (@view Mm[i, j, :, :]) * œÅ·µ¶·µ¶'
        end
    end

    return Qs
end

"""
    obtain_basis_free_parameters(
        h_orbit::HoppingOrbit{D},
        br‚Çê::NewBandRep{D}, 
        br·µ¶::NewBandRep{D}, 
        [ordering‚Çê = OrbitalOrdering(br‚Çê), ordering·µ¶ = OrbitalOrdering(br·µ¶)];
        [timereversal::Bool = true]
        )                            --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}

Obtain the basis of free parameters for the hopping terms between `br‚Çê` and `br·µ¶` 
associated with the hopping orbit `h_orbit`.
"""
function obtain_basis_free_parameters(
    h_orbit::HoppingOrbit{D},
    br‚Çê::NewBandRep{D},
    br·µ¶::NewBandRep{D},
    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),
    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶);
    timereversal::Bool = true,
    diagonal_block::Bool = true,
    antihermitian::Bool = true,
) where {D}
    # We obtain the needed representations over the generators of each bandrep
    gens‚Çê = generators(num(br‚Çê), SpaceGroup{D})
    gens·µ¶ = generators(num(br·µ¶), SpaceGroup{D})
    @assert gens‚Çê == gens·µ¶ # must be from same space group and in same sorting

    # cast generators to primitive basis
    cntr = centering(num(br‚Çê), D)
    gens = cntr ‚àà ('P', 'p') ? gens‚Çê : primitivize.(gens‚Çê, cntr)

    # encode Hamiltonian as a coefficient matrix sandwiched by exponentials & hopping ampl.
    Mm = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶)

    # encode representation constraints on H‚Çê·µ¶
    Qs = representation_constraint_matrices(Mm, br‚Çê, br·µ¶)

    # encode reciprocal-rotation constraints on H‚Çê·µ¶
    Zs = reciprocal_constraints_matrices(Mm, gens, h_orbit)

    # build an aggregate constraint matrix, over all generators, acting on the hopping
    # coefficient vector t‚Çê·µ¶ associated with h_orbit
    constraints = _aggregate_constraints(Qs, Zs)
    t‚Çê·µ¶_basis_matrix = nullspace(constraints; atol = NULLSPACE_ATOL_DEFAULT)

    # at this point, the coefficient-space spanning `t‚Çê·µ¶_basis` is implicitly complex; this
    # is conceptually not too nice for a Hamiltonian, and we'd like to work with strictly
    # real coefficients. To that end, we "split" the possible products of such complex
    # coefficients with a complex basis vector into two vectors, where the lower half of
    # each represents the imaginary part of the product. The benefit of this is that it
    # becomes possible to take the complex conjugate of each element "symbolically" by
    # simply multiplying with [1 0; 0 -1] (block matrix). We need to do this anyway if we
    # we have `timereversal = true`, but it's nice to just have a shared representation
    # of the basis vectors, so we do it here as well.

    # If the set of basis vectors obtained from symmetry constraints was empty, there's no
    # point in continuing: we then return early
    isempty(t‚Çê·µ¶_basis_matrix) && return Mm, Vector{Vector{Float64}}()

    # Details: we split up each potentially complex "basis" vector `t = t‚Çê·µ¶_basis[i]` into
    # two real vectors `x` and `y`, such that the _real_ span of `x` and `y` is equivalent
    # to the complex span of `t`; the key is that we must interpret the lower halfs of `x`
    # and `y` as representing imaginary numbers. Crucially, this must be kept in mind
    # everywhere that we use a coefficient vector. In particular, we now must always
    # interpret `Mm` as acting like `[Mm Mm]` when meeting a "doubled" basis vector of this
    # kind.
    # Example: we have `t‚ÇÅ = [im,0]`, `t‚ÇÇ = [1,im]`, and `t‚Çê·µ¶_basis = [t‚ÇÅ,t‚ÇÇ]`, then:
    #    ```
    #    julia> t‚Çê·µ¶_basis_split = split_complex.(t‚Çê·µ¶_basis)
    #    2-element Vector{Matrix{Int64}}:
    #     [0 -1; 0 0; 1 0; 0 0]
    #     [1 0; 0 -1; 0 1; 1 0]
    #
    #    julia> t‚Çê·µ¶_basis_split_matrix = reduce(hcat, t‚Çê·µ¶_basis_split)
    #    4√ó4 Matrix{Int64}:
    #     0  -1  1   0
    #     0   0  0  -1
    #     1   0  0   1
    #     0   0  1   0
    #    ```
    # See `split_complex` for more details on the real/imaginary splitting.
    N = 2size(Mm, 2) # number of elements per `t`-vector, when doubled
    t‚Çê·µ¶_basis_reim = split_complex.(collect(eachcol(t‚Çê·µ¶_basis_matrix)))
    t‚Çê·µ¶_basis_reim_matrix =
        reduce(hcat, t‚Çê·µ¶_basis_reim; init = Matrix{Float64}(undef, N, 0))

    ## ----------------------------------------------------------------------------------- #
    if timereversal # "add" & "intersect" the associated TRS constraints
        # now we want to construct the TRS constraints, and then intersect the allowable basis
        # terms on that constraint with those corresponding to the previously computed basis
        t‚Çê·µ¶_basis_tr_reim_matrix =
            obtain_basis_free_parameters_TRS(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶, Mm)
        t‚Çê·µ¶_basis_reim =
            zassenhaus_intersection(t‚Çê·µ¶_basis_reim_matrix, t‚Çê·µ¶_basis_tr_reim_matrix)
        t‚Çê·µ¶_basis_reim_matrix =
            reduce(hcat, t‚Çê·µ¶_basis_reim; init = Matrix{Float64}(undef, N, 0))
    end
    isempty(t‚Çê·µ¶_basis_reim_matrix) && return Mm, Vector{Vector{Float64}}()

    # ------------------------------------------------------------------------------------ #
    # "add" & "intersect" the associated hermiticity constraints if this is a diagonal block
    if diagonal_block
        t‚Çê·µ¶_basis_herm_reim_matrix = obtain_basis_free_parameters_hermiticity(
            h_orbit,
            br‚Çê,
            br·µ¶,
            ordering‚Çê,
            ordering·µ¶,
            Mm;
            antihermitian,
        )

        t‚Çê·µ¶_basis_reim =
            zassenhaus_intersection(t‚Çê·µ¶_basis_reim_matrix, t‚Çê·µ¶_basis_herm_reim_matrix)
        t‚Çê·µ¶_basis_reim_matrix =
            reduce(hcat, t‚Çê·µ¶_basis_reim; init = Matrix{Float64}(undef, N, 0))
    end
    isempty(t‚Çê·µ¶_basis_reim_matrix) && return Mm, Vector{Vector{Float64}}()

    # ------------------------------------------------------------------------------------ #
    # Make sure we have a reasonably pretty-looking basis in the end by sparsifying &
    # dropping near-zero elements explicitly

    # convert null-space to a sparse column form
    t‚Çê·µ¶_basis_reim_matrix_form‚Ä≤ = _poormans_sparsification(t‚Çê·µ¶_basis_reim_matrix)
    t‚Çê·µ¶_basis_reim = [collect(v) for v in eachcol(t‚Çê·µ¶_basis_reim_matrix_form‚Ä≤)]

    # prune near-zero elements of basis vectors
    _prune_at_threshold!(t‚Çê·µ¶_basis_reim)

    return return Mm, t‚Çê·µ¶_basis_reim
end

function _aggregate_constraints(
    Q::AbstractArray{<:Number, 4},
    Z::AbstractArray{<:Number, 4},
    row_atol::Real = 1e-10,
)
    # store constraints in one big vector initially; then we reshape to a matrix after
    constraint_vs = Vector{promote_type(eltype(Q), eltype(Z))}()
    _aggregate_constraints!(constraint_vs, Q, Z, row_atol)

    # return a C√óJ matrix where each row is a constraint, across C constraints
    J = size(Q, 2) # number of elements per constraint
    return _reshape_aggregate_constraints(constraint_vs, J)
end

function _aggregate_constraints(
    # same as `_aggregate_constraints(Q, V)` but for a vector of Qs and Zs
    Qs::AbstractVector{<:AbstractArray{<:Number, 4}},
    Zs::AbstractVector{<:AbstractArray{<:Number, 4}},
    row_atol::Real = 1e-10,
)
    constraint_vs = Vector{promote_type(eltype(eltype(Qs)), eltype(eltype(Zs)))}()
    for (Q, Z) in zip(Qs, Zs)
        _aggregate_constraints!(constraint_vs, Q, Z, row_atol)
    end
    J = size(first(Qs), 2)
    return _reshape_aggregate_constraints(constraint_vs, J)
end

function _aggregate_constraints!( # modifies `constraint_vs` in place
    constraint_vs::Vector{<:Number},
    Q::AbstractArray{<:Number, 4},
    Z::AbstractArray{<:Number, 4},
    row_atol::Real = 1e-10,
)
    # store constraints in one big vector initially; then we reshape to a matrix after
    c = Vector{eltype(constraint_vs)}(undef, size(Q, 2))
    for i in axes(Q, 1), s in axes(Q, 3), t in axes(Q, 4)
        q = @view Q[i, :, s, t]
        z = @view Z[i, :, s, t]
        c .= q .- z
        norm(c) > row_atol || continue # don't add empty or near-empty constraints
        append!(constraint_vs, c) # add the constraint to the list
    end

    return constraint_vs
end

function _reshape_aggregate_constraints(
    constraint_vs::Vector{<:Number}, # vector of inline-concatenated constraints
    J::Int, # number of elements per constraint: ‚â° size(Mm,2) = size(Q,2) = size(Z,2)
)
    C = length(constraint_vs) √∑ J # number of constraints
    return permutedims(reshape(constraint_vs, J, C))
end

"""
    reciprocal_constraints_matrices(
                                    Mm::Array{Int,4}, 
                                    gens::AbstractVector{SymOperation{D}}, 
                                    h_orbit::HoppingOrbit{D}
                                    ) --> Vector{Array{Int,4}}

Compute the reciprocal constraints matrices for the generators of the SG. This is
done by permuting the rows of the M matrix according to the symmetry operation 
acting on k-space. See more details in
`permute_symmetry_related_hoppings_under_symmetry_operation` and `devdocs.md`.
"""
function reciprocal_constraints_matrices(
    Mm::Array{Int, 4},
    gens::AbstractVector{SymOperation{D}},
    h_orbit::HoppingOrbit{D},
) where {D}
    Zs = Vector{Array{Int, 4}}(undef, length(gens))
    for (i, op) in enumerate(gens)
        Z = similar(Mm)
        P·µÄ = transpose(
            _permute_symmetry_related_hoppings_under_symmetry_operation(h_orbit, op),
        )
        for s in axes(Mm, 3)
            for t in axes(Mm, 4) # v·µÄ Œ°·µÄ M‚Çõ‚Çú t => v‚Çó Œ°·µÄ‚Çó·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º = v‚Çó P·µ¢‚Çó M·µ¢‚±º‚Çõ‚Çú t‚±º
                Z[:, :, s, t] .= P·µÄ * @view Mm[:, :, s, t] # P·µÄ M‚ÅΩÀ¢·µó‚Åæ
            end
        end
        Zs[i] = Z
    end
    return Zs
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
         function for `reciprocal_constraints_matrices`.

Build the P matrix for a particular symmetry operation acting on k-space, which
permutes the rows of the M matrix.

For obtaining the P matrix, we make use that the action is on exponential of the
type: ùêû(2œÄk‚ãÖŒ¥), to instead act on Œ¥ ‚àà `h_orbit.orbit` instead of k, which is a
symbolic variable. Because of that, we need to use the inverse of the rotation
part of the symmetry operation. Sketch of the proof:

Assume g={R|œÑ} and `Crystalline` implements gk=(R‚Åª¬π)·µÄk. Then (gk)‚ãÖŒ¥ = 
((R‚Åª¬π)·µÄk)‚ãÖŒ¥ + œÑ = k‚ãÖ(R‚Åª¬π)Œ¥.

WARNING: we assume that the operation is primitive.
"""
function _permute_symmetry_related_hoppings_under_symmetry_operation(
    h_orbit::HoppingOrbit{D},
    op::SymOperation{D},
) where {D}
    # P is a square matrix that acts as `op` on `v`, i.e., represents ``op ‚àò v``, via a
    # matrix-vector product `P*v`. Equivalently, `P` can act on `M` (via its transpose)
    # for expressions of the kind (Pv)·µÄM ‚Ä¶ = v·µÄP·µÄM ‚Ä¶
    P = zeros(Int, length(orbit(h_orbit)), length(orbit(h_orbit)))
    for (i, Œ¥·µ¢) in enumerate(orbit(h_orbit))
        # crystalline implements gk = [R‚Åª¬π]·µÄk. However, since we don't have access to k,
        # being a symbolic variable, we will translate its action into Œ¥. For this,
        # we implement a simple trick: ([R‚Åª¬π]·µÄ k)¬∑r = R‚Åª¬π·µ¢‚±º k·µ¢ r‚±º = k¬∑(R‚Åª¬π r)
        R‚Åª¬π = SymOperation(inv(rotation(op))) # rotation-only part of `op`
        Œ¥·µ¢‚Ä≤ = compose(R‚Åª¬π, Œ¥·µ¢)
        j = findfirst(Œ¥‚Ä≤‚Ä≤ -> isapprox(Œ¥·µ¢‚Ä≤, Œ¥‚Ä≤‚Ä≤, nothing, false), orbit(h_orbit))
        isnothing(j) &&
            error(lazy"hopping element $Œ¥·µ¢ not closed under $op in $(orbit(h_orbit))")
        P[i, j] = 1
        # since P acts as g v = P v, we have (gv)·µ¢ = v‚±º = ‚àë‚Çñ P·µ¢‚Çñ v‚Çñ so P·µ¢‚Çñ = Œ¥·µ¢‚±º
    end
    return P
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `obtain_basis_free_parameters`.

Poor man's "matrix sparsification" via the reduced row echelon form.
"""
function _poormans_sparsification(
    A::AbstractMatrix{<:Number};
    rref_tol::Union{Nothing, Float64} = SPARSIFICATION_ATOL_DEFAULT,
)
    # following appendix E of the Qsymm paper (https://arxiv.org/abs/1806.08363) [copied
    # over from Neumann.jl] [copied over from MPBUtils.jl]
    if !isnothing(rref_tol)
        # use a relatively low tolerance in `rref` to avoid explosions of errors
        # NB: this optional tolerance argument of `rref!` is undocumented :(
        return transpose(rref!(copy(transpose(A)), rref_tol))
    end
    return transpose(rref(transpose(A)))
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `obtain_basis_free_parameters`.

Prune near-zero elements of vectors in `vs`.
"""
function _prune_at_threshold!(
    vs::AbstractVector{<:AbstractVector{T}};
    atol::Real = PRUNE_ATOL_DEFAULT,
) where {T <: Complex}
    for v in vs
        for (j, v‚±º) in enumerate(v)
            r‚±º, i‚±º = reim(v‚±º)
            r‚±º‚Ä≤ = ifelse(abs(r‚±º) < atol, zero(real(T)), r‚±º)
            i‚±º‚Ä≤ = ifelse(abs(i‚±º) < atol, zero(real(T)), i‚±º)
            v[j] = T(r‚±º‚Ä≤, i‚±º‚Ä≤)
        end
    end
    return vs
end

function _prune_at_threshold!(
    vs::AbstractVector{<:AbstractVector{T}};
    atol::Real = PRUNE_ATOL_DEFAULT,
) where {T <: Real} # needed for type consistency in TRS implementation
    for v in vs
        for (j, v‚±º) in enumerate(v)
            v[j] = abs(v‚±º) < atol ? zero(T) : v‚±º
        end
    end
    return vs
end

# ---------------------------------------------------------------------------- #

"""
    tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) 
        --> Vector{TightBindingTerm{D}}

Construct the TB Hamiltonian matrix from a given composite band representation 
`cbr` and a set of global translation-representatives `Rs`. The Hamiltonian is 
constructed block by block according to the symmetry-related hoppings between the 
band representations in `cbr`. Several model are given back, one of closed in the 
symmetry operations.
"""
function tb_hamiltonian(
    cbr::CompositeBandRep{D},
    Rs::AbstractVector{Vector{Int}}; # "global" translation-representatives of hoppings
    timereversal::Bool = true,
    antihermitian::Bool = false,
) where {D}
    if any(c -> !isinteger(c) || c < 0, cbr.coefs)
        error(
            "provided composite bandrep is not Wannierizable: contains negative or non-integer coefficients",
        )
        # no TB model can be constructed for such a composite bandrep
    end
    coefs = round.(Int, cbr.coefs)

    # find all band representations involved in the composite band representation and list them
    brs = Vector{NewBandRep{D}}(undef, sum(coefs))
    idx = 0
    for (i, c) in enumerate(coefs)
        for _ in 1:c
            brs[idx+=1] = cbr.brs[i]
        end
    end

    # find all families of hoppings between involved band representations
    # the TB model will be divided into each of these representatives since they will be 
    # symmetry independent
    hermiticity = antihermitian ? ANTIHERMITIAN : HERMITIAN
    B = length(brs)
    axis = BlockArrays.BlockedOneTo(cumsum((count_bandrep_orbitals(br) for br in brs)))
    tbs = Vector{TightBindingTerm{D}}()
    for d in 0:B-1 # offset from main diagonal (at 0)
        for block_i in 1:B-d
            # we iterate here across diagonal blocks, going from the main diagonal and up
            # toward the upper block-diagonals: we do this to get a more natural sorting of
            # the terms in the model, with self-hoppings first
            # we only go over the upper triangular part cf. hermicity/anti-hermicity
            block_j = block_i + d
            br1 = brs[block_i]
            br2 = brs[block_j]
            ordering1 = OrbitalOrdering(br1)
            ordering2 = OrbitalOrdering(br2)
            h_orbits = obtain_symmetry_related_hoppings(Rs, br1, br2, timereversal)
            for h_orbit in h_orbits
                Mm, t_Œ±Œ≤_basis = obtain_basis_free_parameters(
                    h_orbit,
                    br1,
                    br2,
                    ordering1,
                    ordering2;
                    timereversal,
                    diagonal_block = d == 0,
                    antihermitian,
                )
                for t in t_Œ±Œ≤_basis
                    block =
                        TightBindingBlock{D}(br1, br2, ordering1, ordering2, h_orbit, Mm, t)
                    h = TightBindingTerm{D}(
                        axis,
                        (block_i, block_j),
                        block,
                        hermiticity,
                        brs,
                    )
                    push!(tbs, h)
                end
            end
        end
    end

    return TightBindingModel(tbs)
end

"""
    count_bandrep_orbitals(br::NewBandRep{D}) --> Int

Counts the number of orbitals in a band representation `br`. This is done by taking 
the multiplicity of the Wyckoff position associated to `br`, dividing it by the 
centering volume fraction (excluding copies due to conventional setting) and 
multiplying it by the dimension of the site irrep.
"""
function count_bandrep_orbitals(br::NewBandRep{D}) where {D}
    mult = multiplicity(position(br)) # multiplicity in conventional setting
    # we need the Wyckoff multiplicity, excluding conventional-centering copies, so we
    # divide by the the number of centering-translations
    cntr = centering(num(br), D)
    denom = centering_volume_fraction(cntr, Val(D), Val(D))
    mult = div(mult, denom)

    return mult * irdim(br.siteir)
end

# ---------------------------------------------------------------------------- #
