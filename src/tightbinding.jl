"""
        obtain_symmetry_related_hoppings(
                                        Rs::AbstractVector{V}, 
                                        br‚Çê::NewBandRep{D}, 
                                        br·µ¶::NewBandRep{D}
                                        ) where {V<:Union{AbstractVector{<:Integer},RVec{D}} where {D}
                                        --> Vector{HoppingOrbit{D}}

    Compute the symmetry related hopping terms from the points in WP of `br‚Çê` to the 
    WP of `br·µ¶`displaced a set of primitive lattice vectors `Rs`.

    The vectors provided in `Rs` are just representatives. Because of symmetry 
    operations, bigger primitive lattice vectors could be found.

    How it works: 
    1. Take a point `a` in the WP of `br‚Çê` and a point `b` in the WP of `br·µ¶`. We 
    compute the displacement vector `Œ¥ = b + R - a`, where `R ‚àà Rs`.
    2. If `Œ¥ ‚àà representatives` then we add `Œ¥ => (a, b, R)` to the list of hoppings 
        of that representative and continue. If not then, we search inside of all the 
        representatives for the one that `Œ¥ => (a, b, R)` in the list of hoppings. 
        If not found, then we add `Œ¥` as a new representative and add `Œ¥ => (a, b, R)` 
        to its list of hoppings.
3. Take `g ‚àà generators` and compute `Œ¥' = g Œ¥` and `(a', b', R') = (g a, g b, g R)`, 
    and repeat step 2.
4. Repeat all steps 1 to 3 for all pair of points in the WPs of `br‚Çê` and `br·µ¶`.
"""
function obtain_symmetry_related_hoppings(
    Rs::AbstractVector{V}, # must be specified in the primitive basis
    br‚Çê::NewBandRep{D},
    br·µ¶::NewBandRep{D}
) where {V<:Union{AbstractVector{<:Integer},RVec{D}}} where {D}

    sgnum = num(br‚Çê)
    num(br·µ¶) == sgnum || error("both band representations must be in the same space group")
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    cntr = centering(sgnum, D)
    ops = primitivize(spacegroup(sgnum, Val{D}()))
    wps‚Çê = primitivize.(orbit(group(br‚Çê)), cntr)
    wps·µ¶ = primitivize.(orbit(group(br·µ¶)), cntr)


    # we have defined a structure `HoppingOrbit` to gather the information. It is 
    # structured as:
    # 1. `HoppingOrbit.representatives` will store a representative hopping vector Œ¥
    # 2. `HoppingOrbit.orbit` will store the full orbit of symmetry related hopping 
    #   vector generated by Œ¥: {Œ¥·µ¢}
    # 3. `HoppingOrbit.hoppings` will store the real coordinates `(a,b,R)` of each 
    #   hopping term associated to each `Œ¥·µ¢`. Note that maybe several `(a,b,R)` could be 
    #   associated to the same `Œ¥·µ¢`

    h_orbits = HoppingOrbit{D}[]
    for R in Rs
        R = RVec{D}(R) # change the type of R for type consistency
        for (q‚Çê, q·µ¶) in Iterators.product(wps‚Çê, wps·µ¶)
            q‚Çê = parent(q‚Çê) # work with RVec directly rather than Wyckoff Position
            #                 (type consistent)
            q·µ¶ = parent(q·µ¶)
            Œ¥ = q·µ¶ + R - q‚Çê # potential representative in next element of `h_orbits`
            maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops)
            maybe_add_hoppings!(h_orbits, -Œ¥, q·µ¶, q‚Çê, -R, ops)
            # TODO (future): check if adding `Œ¥` and `-Œ¥` at the same time is a good idea
            # or it is better to consider it afterwards at hermiticity. Is this 
            # valid for any space group? Well yes, but they might be different if
            # nor inversion nor TRS are present
        end
    end
    return h_orbits
end

"""
    maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops) --> Vector{HoppingOrbit{D}}

Checks if a hopping term `Œ¥` is already in the list of representatives. If not, 
it adds it and its symmetry related partners. If it is, it only adds the symmetry 
related partners.
"""
function maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops::AbstractVector{SymOperation{D}}) where {D}
    Œ¥_idx = findfirst(h_orbits) do h_orbit
        isapproxin(Œ¥, orbit(h_orbit), nothing, false) # check if Œ¥ is in h_orbits
    end
    if isnothing(Œ¥_idx)
        # if it wasn't already in `h_orbits`, we add it and its symmetry-related partners
        Œ¥_orbit = HoppingOrbit{D}(Œ¥, [Œ¥], [[(q‚Çê, q·µ¶, R)]])
        _maybe_add_hoppings!(Œ¥_orbit, Œ¥, q‚Çê, q·µ¶, R, ops)
        push!(h_orbits, Œ¥_orbit)
    else # if it was already in `h_orbits`, we only add its symmetry-related partners
        Œ¥_orbit = h_orbits[Œ¥_idx]
        _maybe_add_hoppings!(Œ¥_orbit, Œ¥, q‚Çê, q·µ¶, R, ops)
    end
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `maybe_add_hoppings!`.

Computes and adds the symmetry related partners of a hopping term `Œ¥` to the 
`Œ¥_orbit`.
"""
function _maybe_add_hoppings!(Œ¥_orbit, Œ¥, q‚Çê, q·µ¶, R, ops::AbstractVector{SymOperation{D}}) where {D}
    for g in ops
        _q‚Çê‚Ä≤ = g * q‚Çê
        _q·µ¶‚Ä≤ = g * (q·µ¶ + R)
        # _q‚Çê‚Ä≤ and _q·µ¶‚Ä≤ could include a translation part that is a multiple of the lattice
        # translation, so we reduce it to a unit range and keep that translation part separate
        q‚Çê‚Ä≤ = RVec(reduce_translation_to_unitrange(constant(_q‚Çê‚Ä≤)), free(_q‚Çê‚Ä≤))
        q·µ¶‚Ä≤ = RVec(reduce_translation_to_unitrange(constant(_q·µ¶‚Ä≤)), free(_q·µ¶‚Ä≤))
        d‚Çê = _q‚Çê‚Ä≤ - q‚Çê‚Ä≤ # possible lattice translation part of _q‚Çê‚Ä≤
        d·µ¶ = _q·µ¶‚Ä≤ - q·µ¶‚Ä≤ # possible lattice translation part of _q·µ¶‚Ä≤

        R‚Ä≤ = d·µ¶ - d‚Çê # total lattice translation part of the symmetry-related hopping term Œ¥'
        g_rotation = SymOperation(rotation(g)) # rotation-only part of g
        Œ¥‚Ä≤ = g_rotation * Œ¥ # potential symmetry related partner of `Œ¥` to add to `Œ¥_orbit`

        # several sanity checks:
        #   1. R¬¥ is a lattice translation, i.e., it is integer
        #   2. R¬¥ doesn't have any free parameters - TODO: try to implement it for WPs with free parameters
        #   3. Œ¥‚Ä≤ = q·µ¶‚Ä≤ + R‚Ä≤ - q‚Çê‚Ä≤
        all(R·µ¢‚Ä≤ -> abs(R·µ¢‚Ä≤ - round(R·µ¢‚Ä≤)) < 1e-10, constant(R‚Ä≤)) || error("arrived at non-integer lattice translation R‚Ä≤: should be impossible")
        isspecial(R‚Ä≤) || error("arrived at non-special (nonzero free parameters) lattice translation R‚Ä≤: should be impossible")
        isapprox(Œ¥‚Ä≤, q·µ¶‚Ä≤ + R‚Ä≤ - q‚Çê‚Ä≤, nothing, false) || error("Œ¥‚Ä≤ ‚â† q·µ¶‚Ä≤ + R‚Ä≤ - q‚Çê‚Ä≤")

        idx_in_orbit = findfirst(Œ¥‚Ä≤‚Ä≤ -> isapprox(Œ¥‚Ä≤, Œ¥‚Ä≤‚Ä≤, nothing, false), orbit(Œ¥_orbit))
        if isnothing(idx_in_orbit)
            # Œ¥‚Ä≤ is not already included in `orbit(Œ¥_orbit)`
            push!(orbit(Œ¥_orbit), Œ¥‚Ä≤)
            push!(Œ¥_orbit.hoppings, [(q‚Çê‚Ä≤, q·µ¶‚Ä≤, R‚Ä≤)])
        else
            # Œ¥‚Ä≤ already in `orbit(Œ¥_orbit)` but hopping term might not be:
            # evaluate `(q‚Çê‚Ä≤, q·µ¶‚Ä≤, R‚Ä≤) ‚àâ Œ¥_orbit.hoppings[idx_in_orbit]`, w/
            # approximate equality comparison
            bool = !any(Œ¥_orbit.hoppings[idx_in_orbit]) do (q‚Çê‚Ä≤‚Ä≤, q·µ¶‚Ä≤‚Ä≤, R‚Ä≤‚Ä≤)
                (isapprox(q‚Çê‚Ä≤, q‚Çê‚Ä≤‚Ä≤, nothing, false) && isapprox(q·µ¶‚Ä≤, q·µ¶‚Ä≤‚Ä≤, nothing, false)
                 && isapprox(R‚Ä≤, R‚Ä≤‚Ä≤, nothing, false))
            end
            if bool
                push!(Œ¥_orbit.hoppings[idx_in_orbit], (q‚Çê‚Ä≤, q·µ¶‚Ä≤, R‚Ä≤))
            end
        end
    end
    return Œ¥_orbit
end

# ---------------------------------------------------------------------------- #
# EBRs: (q|A), (w|B)
# Wyckoff positions: q, w
#   q: q1, ..., qN
#   w: w1, ..., wM
# Site symmetry irreps: A, B
#   A: A1, ..., AJ
#   B: B1, ..., BK
# Œ¥s = [Œ¥1, Œ¥2, ..., Œ¥n]
#   Œ¥1: qi‚ÇÅ¬π -> wj‚ÇÅ¬π, qi‚ÇÅ¬≤ -> wj‚ÇÅ¬≤, ...
#   Œ¥2: qi‚ÇÇ¬π -> wj‚ÇÇ¬π, qi‚ÇÇ¬≤ -> wj‚ÇÇ¬≤, ...
# v = [exp(ik‚ãÖŒ¥1), exp(ik‚ãÖŒ¥2), ..., exp(ik‚ãÖŒ¥n)]
# t = [[t(Œ¥1) ...], [t(Œ¥2) ...], ..., [t(Œ¥n) ...]]
#   t(Œ¥1): [t(qi‚ÇÅ·µÖ -> wj‚ÇÅ·µÖ, A_f -> B_g) ...]

# Current example: (1a|E), (2c|A)
#   ___w2__
#  |   x   |
#  |q1 x   x w1
#  |_______|
#   Œ¥s = [1/2x, -1/2x, 1/2y, -1/2y]
#      Œ¥1: q1 -> w1 + G1
#      Œ¥2: q1 -> w1 + G2
#      Œ¥3: q1 -> w2 + G3
#      Œ¥4: q1 -> w2 + G4
# t = [t(Œ¥1)..., t(Œ¥2)..., t(Œ¥3)..., t(Œ¥4)...]
#   t(Œ¥1): [t(q1 -> w1, G1, E1 -> A1), t(q1 -> w1, G1, E2 -> A1)]
#   t(Œ¥2): [t(q1 -> w1, G2, E1 -> A1), t(q1 -> w1, G2, E2 -> A1)]
#   t(Œ¥3): [t(q1 -> w2, G3, E1 -> A1), t(q1 -> w2, G3, E2 -> A1)]
#   t(Œ¥4): [t(q1 -> w2, G4, E1 -> A1), t(q1 -> w2, G4, E2 -> A1)]
# ---------------------------------------------------------------------------- #

"""
    hamiltonian_term_order(br1::NewBandRep{D}, br2::NewBandRep{D}) 
        --> Matrix{Pair{Tuple{Int64,WyckoffPosition{D}}, Tuple{Int64,WyckoffPosition{D}}}}

Gives an order for the Hamiltonian's term concerning hopping between `br1` and 
`br2`. This is the default order used for building the TB Hamiltonian in 
`tb_hamiltonian`.

A matrix with the dimensions of the Hamiltonian is given back where each term 
indicates the hopping term considered in the Hamiltonian at that position.
"""
function hamiltonian_term_order(
    br1::NewBandRep{D},
    br2::NewBandRep{D},
) where {D}

    sgnum = num(br1)
    num(br2) == sgnum || error("Both band representations must be in the same space group")
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    cntr = centering(sgnum, D)
    wp1 = primitivize.(orbit(group(br1)), cntr)
    wp2 = primitivize.(orbit(group(br2)), cntr)

    V1, V2 = length(wp1), length(wp2)
    Q1, Q2 = irdim(br1.siteir), irdim(br2.siteir)
    T_pair_eltype = Tuple{Int64,WyckoffPosition{D}}
    order = Matrix{Pair{T_pair_eltype,T_pair_eltype}}(undef, V1 * Q1, V2 * Q2)
    for i in 1:V1
        for j in 1:V2
            for k in 1:Q1
                for l in 1:Q2
                    order[(i-1)*Q1+k, (j-1)*Q2+l] = (k, wp1[i]) => (l, wp2[j])
                end
            end
        end
    end
    return order
end

"""
    construct_M_matrix(h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D}, order) 
        --> Array{Int,4}

Construct a set of matrices that encodes a Hamiltonian's term which resembles the 
hopping from EBR `br1` to EBR `br2`.

The Hamiltonian's order which is implicitly used is returned as output, and the 
matrices are stored on a 4D matrix which last two axes indicate the Hamiltonian 
term position it is describing and the first axis refer to the `orbit(h_orbit)` 
and the second axis to the vector `t`. The idea is:

H‚Çõ‚Çú = v·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º

See `devdocs.md` for details.
"""
function construct_M_matrix(
    h_orbit::HoppingOrbit{D},
    br1::NewBandRep{D},
    br2::NewBandRep{D},
    order=hamiltonian_term_order(br1, br2) # an internal order for the Hamiltonian's terms
) where {D}
    V = length(orbit(h_orbit))
    E = length(first(h_orbit.hoppings)) # number of hopping terms per Œ¥·µ¢ (assumed constant for all i)
    foreach(h_orbit.hoppings) do hops
        length(hops) == E || error("Unexpectedly had different counts of hoppings across orbit elements")
    end
    Q1, Q2 = irdim(br1.siteir), irdim(br2.siteir)
    Q = Q1 * Q2

    # matrix of matrices that will store the matrices for each
    # Hamiltonian's term
    Mm = zeros(Int, V, V * E * Q, size(order, 1), size(order, 2))

    # fill in the unit-elements of `Mm`
    for Œ± in axes(order, 1), Œ≤ in axes(order, 2)
        (i, q), (j, w) = order[Œ±, Œ≤]
        q = parent(q)
        w = parent(w)

        # assign a 1 to the correct position of WPs times irreps dimensionality
        for (r, hops) in enumerate(h_orbit.hoppings)
            offset0 = (r - 1) * E * Q
            for (x, hop) in enumerate(hops)
                if isapprox(hop[1], q, nothing, false) && isapprox(hop[2], w, nothing, false)
                    offset1 = (x - 1) * Q
                    c = offset0 + offset1 + (j - 1) * Q1 + i
                    Mm[r, c, Œ±, Œ≤] = 1
                end
            end
        end
    end

    return Mm
end

# H_{s,t} = v_i M_{i,j,s,t} t_j

"""
    representation_constraints_matrices(
                                    Mm::Array{Int,4}, 
                                    gens::AbstractVector{SymOperation{D}}, 
                                    h_orbit::HoppingOrbit{D}
                                    ) --> Vector{Array{Complex,4}}

Build the Q matrix for a particular symmetry operation (or, equivalently, a 
particular matrix from the site-symmetry representation), acting on the M matrix. 
Relative to our white-board notes, Q has swapped indices, in the sense we below 
give `Q[i,j,r,l]`.

(œÅ‚Çê‚Çê)·µ£‚Çõ H‚Çõ‚Çú / (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ v·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º / (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = v·µ¢ (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú / 
(œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó t‚±º,

then we can define: Q·µ¢‚±º·µ£‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú / (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó
"""
function representation_constraint_matrices(
    Mm::AbstractArray{<:Number,4},
    br‚Çê::NewBandRep{D},
    br·µ¶::NewBandRep{D}
) where {D}
    gens‚Çê, œÅs‚Çê‚Çê = sgrep_induced_by_siteir_generators(br‚Çê)
    gens·µ¶, œÅs·µ¶·µ¶ = sgrep_induced_by_siteir_generators(br·µ¶)
    @assert gens‚Çê == gens·µ¶ # just a sanity check that `sgrep_induced_by_siteir_generators` is consistent

    Qs = Vector{Array{Complex,4}}(undef, length(gens‚Çê))
    for (n, (œÅ‚Çê‚Çê, œÅ·µ¶·µ¶)) in enumerate(zip(œÅs‚Çê‚Çê, œÅs·µ¶·µ¶))

        œÅ‚Çê‚Çê = Matrix(œÅ‚Çê‚Çê) # since `/` doesn't extend to BlockArrays currently
        œÅ·µ¶·µ¶ = Matrix(œÅ·µ¶·µ¶) # for type consistency

        Q = zeros(ComplexF64, size(Mm))
        for i in axes(Mm, 1), j in axes(Mm, 2)
            Q[i, j, :, :] .= œÅ‚Çê‚Çê * Mm[i, j, :, :] / œÅ·µ¶·µ¶ # = œÅ‚Çê‚Çê * Mm[i, j, :, :] * inv(œÅ·µ¶·µ¶)
        end
        Qs[n] = Q
    end
    return Qs
end

"""
    obtain_basis_free_parameters(
                                br‚Çê::NewBandRep{D}, 
                                br·µ¶::NewBandRep{D}, 
                                h_orbit::HoppingOrbit{D}, 
                                order=hamiltonian_term_order(br‚Çê, br·µ¶)
                                ) --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}, 
                                            Matrix{Pair{Tuple{Int,WyckoffPosition{D}},
                                                        Tuple{Int,WyckoffPosition{D}}}}

Obtain the basis of free parameters for the hopping terms between `br‚Çê` and `br·µ¶` 
associated with the hopping orbit `h_orbit`. The Hamiltonian's default order is 
given by `order`.
"""
function obtain_basis_free_parameters(
    br‚Çê::NewBandRep{D},
    br·µ¶::NewBandRep{D},
    h_orbit::HoppingOrbit{D},
    order=hamiltonian_term_order(br‚Çê, br·µ¶);
    time_reversal=false,
    hermiticity=false
) where {D}
    # We obtain the needed representations over the generators of each bandrep
    gens‚Çê = generators(num(br‚Çê), SpaceGroup{D})
    gens·µ¶ = generators(num(br·µ¶), SpaceGroup{D})
    @assert gens‚Çê == gens·µ¶ # must be from same space group and in same sorting

    # cast generators to primitive basis
    cntr = centering(num(br‚Çê), D)
    gens = cntr ‚àà ('P', 'p') ? gens‚Çê : primitivize.(gens‚Çê, cntr)

    # TODO: 

    # compute the tensor M that encodes the Hamiltonian as a numerical matrix
    Mm = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, order)

    # compute the Q tensor, encoding representation constraints on H‚Çê·µ¶
    Qs = representation_constraint_matrices(Mm, br‚Çê, br·µ¶)

    # compute the Z tensor, encoding reciprocal-rotation constraints on H‚Çê·µ¶
    Zs = reciprocal_constraints_matrices(Mm, gens, h_orbit)

    # build an aggregate constraint matrix, over all generators, acting on the hopping
    # coefficient vector t‚Çê·µ¶ associated with h_orbit
    constraint_vs = Vector{Vector{ComplexF64}}()
    for (Q, Z) in zip(Qs, Zs)
        for s in axes(Q, 3), t in axes(Q, 4)
            q = @view Q[:, :, s, t]
            z = @view Z[:, :, s, t]
            c = q - z
            filtered_rows = filter(r -> norm(r) > 1e-10, eachrow(c))
            isempty(filtered_rows) && continue # don't add empty constraints
            append!(constraint_vs, filtered_rows)
        end
    end
    constraints = stack(constraint_vs, dims=1)
    t‚Çê·µ¶_basis_matrix_form = nullspace(constraints; atol=NULLSPACE_ATOL_DEFAULT)

    # convert null-space to a sparse column form
    t‚Çê·µ¶_basis_matrix_form‚Ä≤ = _poormans_sparsification(t‚Çê·µ¶_basis_matrix_form)
    t‚Çê·µ¶_basis = [collect(v) for v in eachcol(t‚Çê·µ¶_basis_matrix_form‚Ä≤)]

    # prune near-zero elements of basis vectors
    _prune_at_threshold!(t‚Çê·µ¶_basis)

    Mm_final = Mm

    if time_reversal
        # rewrite `t‚Çê·µ¶_basis` in the desired form t -> [real(t) real(im*t); imag(t) imag(im*t)] 
        # and store it as columns in a matrix. Read `split_complex` docstring for details.
        t‚Çê·µ¶_basis_split = split_complex.(t‚Çê·µ¶_basis)
        t‚Çê·µ¶_basis_split_matrix = reduce(hcat, t‚Çê·µ¶_basis_split)

        # this works the following way:
        # julia> t‚ÇÅ = [im,0]
        # 2-element Vector{Complex{Int64}}:
        # 0 + 1im
        # 0 + 0im

        # julia> t‚ÇÇ = [1,im]
        # 2-element Vector{Complex{Int64}}:
        # 1 + 0im
        # 0 + 1im

        # julia> t_basis = [t‚ÇÅ,t‚ÇÇ]
        # 2-element Vector{Vector{Complex{Int64}}}:
        # [0 + 1im, 0 + 0im]
        # [1 + 0im, 0 + 1im]

        # julia> t_basis_split = TETB.split_complex.(t_basis)
        # 2-element Vector{Matrix{Int64}}:
        # [0 -1; 0 0; 1 0; 0 0]
        # [1 0; 0 -1; 0 1; 1 0]
        # julia> TETB.split_complex(t)
        # 4√ó2 Matrix{Int64}:
        # 1   0
        # 0  -1
        # 0   1
        # 1   0

        # julia> t‚Çê·µ¶_basis_split_matrix = reduce(hcat, t_basis_split)
        # 4√ó4 Matrix{Int64}:
        # 0  -1  1   0
        # 0   0  0  -1
        # 1   0  0   1
        # 0   0  1   0

        # julia>

        # obtain the TRS basis and intersect
        Mm_final, t‚Çê·µ¶_extra, _ = obtain_basis_free_parameters_TRS(br‚Çê, br·µ¶, h_orbit, order)
        # WARNING: we are assuming that the returned `t‚Çê·µ¶_extra` is real, so no need to split

        t‚Çê·µ¶_extra_matrix = reduce(hcat, t‚Çê·µ¶_extra)
        t‚Çê·µ¶_basis = zassenhaus_intersection(t‚Çê·µ¶_basis_split_matrix, t‚Çê·µ¶_extra_matrix)
    end

    return Mm_final, t‚Çê·µ¶_basis, order
end

"""
    reciprocal_constraints_matrices(
                                    Mm::Array{Int,4}, 
                                    gens::AbstractVector{SymOperation{D}}, 
                                    h_orbit::HoppingOrbit{D}
                                    ) --> Vector{Array{Int,4}}

Compute the reciprocal constraints matrices for the generators of the SG. This is
done by permuting the rows of the M matrix according to the symmetry operation 
acting on k-space. See more details in
`permute_symmetry_related_hoppings_under_symmetry_operation` and `devdocs.md`.
"""
function reciprocal_constraints_matrices(
    Mm::Array{Int,4},
    gens::AbstractVector{SymOperation{D}},
    h_orbit::HoppingOrbit{D}
) where {D}
    Zs = Vector{Array{Int,4}}(undef, length(gens))
    for (i, op) in enumerate(gens)
        Z = zeros(Int, size(Mm))
        P = _permute_symmetry_related_hoppings_under_symmetry_operation(h_orbit, op)
        for l in axes(P, 2), j in axes(Mm, 2), s in axes(Mm, 3), t in axes(Mm, 4)
            Z[l, j, s, t] = sum(P[i, l] * Mm[i, j, s, t] for i in axes(P, 1))
            # v·µÄ Œ°·µÄ M‚Çõ‚Çú t => v‚Çó Œ°·µÄ‚Çó·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º = v‚Çó P·µ¢‚Çó M·µ¢‚±º‚Çõ‚Çú t‚±º
        end
        Zs[i] = Z
    end
    return Zs
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
         function for `reciprocal_constraints_matrices`.

Build the P matrix for a particular symmetry operation acting on k-space, which
permutes the rows of the M matrix.

For obtaining the P matrix, we make use that the action is on exponential of the
type: ùêû(2œÄk‚ãÖŒ¥), to instead act on Œ¥ ‚àà `h_orbit.orbit` instead of k, which is a
symbolic variable. Because of that, we need to use the inverse of the rotation
part of the symmetry operation. Sketch of the proof:

Assume g={R|œÑ} and `Crystalline` implements gk=(R‚Åª¬π)·µÄk. Then (gk)‚ãÖŒ¥ = 
((R‚Åª¬π)·µÄk)‚ãÖŒ¥ + œÑ = k‚ãÖ(R‚Åª¬π)Œ¥.

WARNING: we assume that the operation is primitive.
"""
function _permute_symmetry_related_hoppings_under_symmetry_operation(
    h_orbit::HoppingOrbit{D},
    op::SymOperation{D}
) where {D}
    P = zeros(Int, length(orbit(h_orbit)), length(orbit(h_orbit))) # square matrix acting on the rows of M (formally v)
    for (i, Œ¥·µ¢) in enumerate(orbit(h_orbit))
        # crystalline implements that gk = (R‚Åª¬π)·µÄk, then if we translate this operation into 
        # Œ¥, we have that (gk)‚ãÖŒ¥ = ((R‚Åª¬π)·µÄk)‚ãÖŒ¥ + œÑ = k‚ãÖ(R‚Åª¬π)Œ¥
        R‚Åª¬π = SymOperation(inv(rotation(op))) # inverse of rotation-only parts of `op`
        Œ¥·µ¢‚Ä≤ = compose(R‚Åª¬π, Œ¥·µ¢)
        j = findfirst(Œ¥‚Ä≤‚Ä≤ -> isapprox(Œ¥·µ¢‚Ä≤, Œ¥‚Ä≤‚Ä≤, nothing, false), orbit(h_orbit))
        isnothing(j) && error(lazy"hopping element $Œ¥·µ¢ not closed under $op in $(orbit(h_orbit))")
        P[i, j] = 1
        # P acts as g on v: g v = P v so (gv)·µ¢ = v‚±º = ‚àë‚Çñ P·µ¢‚Çñ v‚Çñ so P·µ¢‚Çñ = Œ¥·µ¢‚±º
    end
    return P
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `obtain_basis_free_parameters`.

Poor man's "matrix sparsification" via the reduced row echelon form.
"""
function _poormans_sparsification(
    A::AbstractMatrix{<:Number};
    rref_tol::Union{Nothing,Float64}=SPARSIFICATION_ATOL_DEFAULT)
    # following appendix E of the Qsymm paper (https://arxiv.org/abs/1806.08363) [copied
    # over from Neumann.jl] [copied over from MPBUtils.jl]
    if !isnothing(rref_tol)
        # use a relatively low tolerance in `rref` to avoid explosions of errors
        # NB: this optional tolerance argument of `rref!` is undocumented :(
        return transpose(rref!(copy(transpose(A)), rref_tol))
    end
    return transpose(rref(transpose(A)))
end

"""
WARNING: This function is not intended to be called directly. It is a helper 
function for `obtain_basis_free_parameters`.

Prune near-zero elements of vectors in `vs`.
"""
function _prune_at_threshold!(
    vs::AbstractVector{<:AbstractVector{T}};
    atol::Real=PRUNE_ATOL_DEFAULT
) where {T<:Complex}

    for v in vs
        for (j, v‚±º) in enumerate(v)
            r‚±º, i‚±º = reim(v‚±º)
            r‚±º‚Ä≤ = ifelse(abs(r‚±º) < atol, zero(real(T)), r‚±º)
            i‚±º‚Ä≤ = ifelse(abs(i‚±º) < atol, zero(real(T)), i‚±º)
            v[j] = T(r‚±º‚Ä≤, i‚±º‚Ä≤)
        end
    end
    return vs
end

# ---------------------------------------------------------------------------- #

"""
    tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) 
        --> Vector{BlockMatrix{TightBindingElementString,Matrix{TightBindingBlock{D}}}}

Construct the TB Hamiltonian matrix from a given composite band representation 
`cbr` and a set of global translation-representatives `Rs`. The Hamiltonian is 
constructed block by block according to the symmetry-related hoppings between the 
band representations in `cbr`. Several model are given back, one of closed in the 
symmetry operations.
"""
function tb_hamiltonian(
    cbr::CompositeBandRep{D},
    Rs::AbstractVector{Vector{Int}} # "global" translation-representatives of hoppings to
    # consider
) where {D}
    if any(c -> !isinteger(c) || c < 0, cbr.coefs)
        error("provided composite bandrep is not Wannierizable: contains negative or non-integer coefficients")
        # no TB model can be constructed for such a composite bandrep
    end
    coefs = round.(Int, cbr.coefs)

    # find all band representations involved in the composite band representation and list them
    brs = Vector{NewBandRep{D}}(undef, sum(coefs))
    idx = 0
    for (i, c) in enumerate(coefs)
        for _ in 1:c
            brs[idx+=1] = cbr.brs[i]
        end
    end

    # find all families of hoppings between involved band representations
    # the TB model will be divided into each of these representatives since they will be 
    # symmetry independent
    orbit_representatives = RVec{D}[]
    for br1 in brs
        for br2 in brs
            h_orbits = obtain_symmetry_related_hoppings(Rs, br1, br2)
            # TODO: maybe store them since we are going to use them again bellow
            for Œ¥ in Iterators.map(representative, h_orbits)
                if !isapproxin(Œ¥, orbit_representatives, nothing, false)
                    push!(orbit_representatives, Œ¥)
                end
            end
        end
    end

    # one determined the family of hopping terms closed by symmetry operations, we can build
    # the TB Hamiltonian block by block according to the bans representations in `brs`
    Norbs = count_bandrep_orbitals.(brs)
    tbs = [BlockMatrix{TightBindingElementString,Matrix{TightBindingBlock{D}}}(
        undef_blocks, Norbs, Norbs) for _ in orbit_representatives]
    c_idx_start = 1
    for (block_i, br1) in enumerate(brs)
        # TODO: maybe only need to go over upper triangular part of loop cf. hermiticity
        #       (br1 vs br2 ~ br2 vs. br1)?
        for (block_j, br2) in enumerate(brs)
            h_orbits = obtain_symmetry_related_hoppings(Rs, br1, br2)
            seen_n = Set{Int}()
            order = hamiltonian_term_order(br1, br2)
            for h_orbit in h_orbits
                Œ¥ = representative(h_orbit)
                n = something(findfirst(Œ¥‚Ä≤ -> isapprox(Œ¥, Œ¥‚Ä≤, nothing, false),
                    orbit_representatives)) # check where this Œ¥ is in the list of representatives
                #                             for include it in the right TB model
                push!(seen_n, n)
                Mm, t_Œ±Œ≤_basis, _ = obtain_basis_free_parameters(br1, br2, h_orbit, order)

                A = TightBindingBlock{D}(
                    (block_i, block_j), (Norbs[block_i], Norbs[block_j]), br1, br2,
                    order, Mm, t_Œ±Œ≤_basis, h_orbit,
                    c_idx_start:c_idx_start+length(t_Œ±Œ≤_basis))
                tbs[n][Block(block_i), Block(block_j)] = A
                c_idx_start += length(t_Œ±Œ≤_basis)
            end
            # blocks for other values of `n` are not featured in `h_orbits` - i.e., vanish,
            # so we manually construct zero blocks for those spots:
            for n in eachindex(orbit_representatives)
                n ‚àà seen_n && continue
                tbs[n][Block(block_i), Block(block_j)] = TightBindingBlock{D}(
                    (block_i, block_j), (Norbs[block_i], Norbs[block_j]), br1, br2,
                    order,
                    zeros(Int, 0, 0, size(order, 1), size(order, 2)), # Mm
                    Vector{Vector{ComplexF64}}(),                     # t_Œ±Œ≤_basis
                    nothing,                                          # h_orbit
                    1:0)                                              # c_idxs (empty)
            end
        end
    end
    return tbs
end

"""
    count_bandrep_orbitals(br::NewBandRep{D}) --> Int

Counts the number of orbitals in a band representation `br`. This is done by taking 
the multiplicity of the Wyckoff position associated to `br`, dividing it by the 
centering volume fraction (excluding copies due to conventional setting) and 
multiplying it by the dimension of the site irrep.
"""
function count_bandrep_orbitals(br::NewBandRep{D}) where {D}
    mult = multiplicity(position(br)) # multiplicity in conventional setting
    # we need the Wyckoff multiplicity, excluding conventional-centering copies, so we
    # divide by the the number of centering-translations
    cntr = centering(num(br), D)
    denom = centering_volume_fraction(cntr, Val(D), Val(D))
    mult = div(mult, denom)

    return mult * irdim(br.siteir)
end

# ---------------------------------------------------------------------------- #
