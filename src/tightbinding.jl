"""
    obtain_symmetry_related_hoppings(
        Rs::AbstractVector{V}, 
        brₐ::NewBandRep{D}, 
        brᵦ::NewBandRep{D},
    ) --> Vector{HoppingOrbit{D}}

Compute the symmetry related hopping terms from the points in WP of `brₐ` to the 
WP of `brᵦ` displaced a set of primitive lattice vectors representatives `Rs`.

## Implementation
1. Take a point `a` in the WP of `brₐ` and a point `b` in the WP of `brᵦ`. We 
compute the displacement vector `δ = b + R - a`, where `R ∈ Rs`.
2. If `δ ∈ representatives` then we add `δ => (a, b, R)` to the list of hoppings 
    of that representative and continue. If not then, we search inside of all the 
    representatives for the one that `δ => (a, b, R)` in the list of hoppings. 
    If not found, then we add `δ` as a new representative and add `δ => (a, b, R)` 
    to its list of hoppings.
3. Take `g ∈ generators` and compute `δ' = g δ` and `(a', b', R') = (g a, g b, g R)`, 
    and repeat step 2.
4. Repeat all steps 1 to 3 for all pair of points in the WPs of `brₐ` and `brᵦ`.

Additionally, if we have time-reversal symmetry, we check if orbits that relate `δ` and 
`-δ` are present; if not, we add them. The presence or absence of time-reversal symmetry
is automatically inferred from `brₐ` and `brᵦ` (which must be identical).
"""
function obtain_symmetry_related_hoppings(
    Rs::AbstractVector{V}, # must be specified in the primitive basis
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D},
) where {V <: Union{AbstractVector{<:Integer}, RVec{D}}} where {D}
    sgnum = num(brₐ)
    num(brᵦ) == sgnum ||
        error("both band representations must belong to the same space group")
    brₐ.timereversal == brᵦ.timereversal ||
        error("input band representations must have identical time-reversal symmetry")
    timereversal = brₐ.timereversal

    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    cntr = centering(sgnum, D)
    ops = primitivize(spacegroup(sgnum, Val{D}()))
    wpsₐ = primitivize.(orbit(group(brₐ)), cntr)
    wpsᵦ = primitivize.(orbit(group(brᵦ)), cntr)

    # we have defined a structure `HoppingOrbit` to gather the information. It is 
    # structured as:
    # 1. `HoppingOrbit.representatives` will store a representative hopping vector δ
    # 2. `HoppingOrbit.orbit` will store the full orbit of symmetry related hopping 
    #   vector generated by δ: {δᵢ}
    # 3. `HoppingOrbit.hoppings` will store the real coordinates `(a,b,R)` of each 
    #   hopping term associated to each `δᵢ`. Note that maybe several `(a,b,R)` could be 
    #   associated to the same `δᵢ`

    h_orbits = HoppingOrbit{D}[]
    for R in Rs
        R = RVec{D}(R) # change the type of R for type consistency
        for (qₐ, qᵦ) in Iterators.product(wpsₐ, wpsᵦ)
            qₐ = parent(qₐ) # work with RVec directly rather than Wyckoff Position
            qᵦ = parent(qᵦ)
            δ = qᵦ + R - qₐ # potential representative in next element of `h_orbits`
            maybe_add_hoppings!(h_orbits, δ, qₐ, qᵦ, R, ops)
        end
    end

    # timereversal could link orbits that spatial symmetries alone would categorize as
    # distinct; in particular, if we have timereversal, a hopping vector `δ` must
    # have a counterpart `-δ` - but those two vectors could have fallen into distinct
    # hopping orbits at this point; if so, we must merge them
    if timereversal
        add_timereversal_related_orbits!(h_orbits)
    end

    return h_orbits
end

"""
    maybe_add_hoppings!(h_orbits, δ, qₐ, qᵦ, R, ops) --> Vector{HoppingOrbit{D}}

Checks if a hopping term `δ` is already in the list of representatives. If not, it adds it
and its symmetry related partners. If it is, it only adds the symmetry related partners.
"""
function maybe_add_hoppings!(
    h_orbits,
    δ,
    qₐ,
    qᵦ,
    R,
    ops::AbstractVector{SymOperation{D}},
) where {D}
    δ_idx = findfirst(h_orbits) do h_orbit
        isapproxin(δ, orbit(h_orbit), nothing, false) # check if δ is in h_orbits
    end
    if isnothing(δ_idx)
        # if it wasn't already in `h_orbits`, we add it and its symmetry-related partners
        δ_orbit = HoppingOrbit{D}(δ, [δ], [[(qₐ, qᵦ, R)]])
        push!(h_orbits, δ_orbit)
    else # if it was already in `h_orbits`, we only add its symmetry-related partners
        δ_orbit = h_orbits[δ_idx]
    end
    _maybe_add_hoppings!(δ_orbit, δ, qₐ, qᵦ, R, ops)
end

"""
Computes and adds the symmetry related partners of a hopping term `δ` to the `δ_orbit`.

!!! warning
    This function is an internal helper function for `maybe_add_hoppings!` and
    is not part of the public API.
"""
function _maybe_add_hoppings!(
    δ_orbit,
    δ,
    qₐ,
    qᵦ,
    R,
    ops::AbstractVector{SymOperation{D}},
) where {D}
    for g in ops
        _qₐ′ = g * qₐ
        _qᵦ′ = g * (qᵦ + R)
        # _qₐ′ and _qᵦ′ could include a translation part that is a multiple of the lattice
        # translation, so we reduce it to a unit range and keep that translation part separate
        qₐ′ = RVec(reduce_translation_to_unitrange(constant(_qₐ′)), free(_qₐ′))
        qᵦ′ = RVec(reduce_translation_to_unitrange(constant(_qᵦ′)), free(_qᵦ′))
        dₐ = _qₐ′ - qₐ′ # possible lattice translation part of _qₐ′
        dᵦ = _qᵦ′ - qᵦ′ # possible lattice translation part of _qᵦ′

        R′ = dᵦ - dₐ # total lattice translation part of the symmetry-related hopping term δ'
        g_rotation = SymOperation(rotation(g)) # rotation-only part of g
        δ′ = g_rotation * δ # potential symmetry related partner of `δ` to add to `δ_orbit`

        # several sanity checks:
        #   1. R´ is a lattice translation, i.e., it is integer
        #   2. R´ doesn't have any free parameters - TODO: try to implement it for WPs with free parameters
        #   3. δ′ = qᵦ′ + R′ - qₐ′
        all(Rᵢ′ -> abs(Rᵢ′ - round(Rᵢ′)) < 1e-10, constant(R′)) ||
            error("arrived at non-integer lattice translation R′: should be impossible")
        isspecial(R′) || error(
            "arrived at non-special (nonzero free parameters) lattice translation R′: should be impossible",
        )
        isapprox(δ′, qᵦ′ + R′ - qₐ′, nothing, false) || error("δ′ ≠ qᵦ′ + R′ - qₐ′")

        idx_in_orbit = findfirst(δ′′ -> isapprox(δ′, δ′′, nothing, false), orbit(δ_orbit))
        if isnothing(idx_in_orbit)
            # δ′ is not already included in `orbit(δ_orbit)`
            push!(orbit(δ_orbit), δ′)
            push!(δ_orbit.hoppings, [(qₐ′, qᵦ′, R′)])
        else
            # δ′ already in `orbit(δ_orbit)` but hopping term might not be:
            # evaluate `(qₐ′, qᵦ′, R′) ∉ δ_orbit.hoppings[idx_in_orbit]`, w/
            # approximate equality comparison
            bool =
                !any(δ_orbit.hoppings[idx_in_orbit]) do (qₐ′′, qᵦ′′, R′′)
                    (
                        isapprox(qₐ′, qₐ′′, nothing, false) &&
                        isapprox(qᵦ′, qᵦ′′, nothing, false) &&
                        isapprox(R′, R′′, nothing, false)
                    )
                end
            if bool
                push!(δ_orbit.hoppings[idx_in_orbit], (qₐ′, qᵦ′, R′))
            end
        end
    end
    return δ_orbit
end

"""
    add_timereversal_related_orbits!(h_orbits::Vector{HoppingOrbit{D}}) where {D}

Adds the time-reversed hopping terms to the hopping orbits in `h_orbits`. The time-reversed
hopping terms are added to the orbit of the hopping term they are related to, and if they are
already present in another orbit, the two orbits are merged.
"""
function add_timereversal_related_orbits!(h_orbits::Vector{HoppingOrbit{D}}) where {D}
    # for any orbit that contains a hopping vector `δ`, we check if its time-reversed
    # hopping vector `-δ` is also in the orbit; if not, we check if it is in any other
    # orbit to merge them, and, if not, we add it manually to the orbit

    # below, we assume that if for some δ no counterpart is found, then no other δ in the
    # orbit has a counterpart, so we can just add it manually

    # determine if `h_orbit`s should be modified
    for (n, h_orbit) in enumerate(h_orbits)
        δs = orbit(h_orbit) # δs in the current orbit

        # check if the orbit is already "good" (i.e., all δs have a -δ counterpart)
        if all(δ -> isapproxin(-δ, δs, nothing, false), δs)
            # all δs have a -δ counterpart in the orbit: orbit is good as-is
            continue
        end

        merge_idx = findfirst(
            h_orbit′ -> isapproxin(δs[1], orbit(h_orbit′), nothing, false),
            @view h_orbits[n+1:end]
        )
        if !isnothing(merge_idx)
            # at least one δ has a -δ counterpart in another orbit - we need to merge them
            # TODO: I will assume that if one δ has a -δ counterpart in another orbit, then all
            # δs in the orbit have a -δ counterpart in the same orbit, so we merge them
            n′ = something(idx_merge) + n
            h_orbit′ = h_orbits[n′]

            # merge the orbits
            append!(h_orbit.orbit, h_orbit′.orbit)
            append!(h_orbit.hoppings, h_orbit′.hoppings)

            # remove the merged orbit
            deleteat!(h_orbits, n′)
            continue
        end
        # we now know that at least some δ doesn't have a -δ counterpart: we assume that
        # this implies that none of the δs have a -δ counterpart, so we need to add them all
        @assert all(δ -> !isapproxin(-δ, δs, nothing, false), δs)

        # first append the new δs into the orbit
        append!(δs, -δs)

        # add the "reversed" hopping terms: i.e., for every a + δ = b + R, add b + (-δ) = a + (-R)
        hoppings = h_orbit.hoppings
        hoppings′ = map(hoppings) do hops
            map(hops) do (qₐ, qᵦ, R)
                (qᵦ, qₐ, -R) # reverse the hopping term
            end
        end
        append!(hoppings, hoppings′)
    end
end

# ---------------------------------------------------------------------------- #
# EBRs: (q|A), (w|B)
# Wyckoff positions: q, w
#   q: q1, ..., qN
#   w: w1, ..., wM
# Site symmetry irreps: A, B
#   A: A1, ..., AJ
#   B: B1, ..., BK
# δs = [δ1, δ2, ..., δn]
#   δ1: qi₁¹ -> wj₁¹, qi₁² -> wj₁², ...
#   δ2: qi₂¹ -> wj₂¹, qi₂² -> wj₂², ...
# v = [exp(ik⋅δ1), exp(ik⋅δ2), ..., exp(ik⋅δn)]
# t = [[t(δ1) ...], [t(δ2) ...], ..., [t(δn) ...]]
#   t(δ1): [t(qi₁ᵅ -> wj₁ᵅ, A_f -> B_g) ...]

# Current example: (1a|E), (2c|A)
#   ___w2__
#  |   x   |
#  |q1 x   x w1
#  |_______|
#   δs = [1/2x, -1/2x, 1/2y, -1/2y]
#      δ1: q1 -> w1 + G1
#      δ2: q1 -> w1 + G2
#      δ3: q1 -> w2 + G3
#      δ4: q1 -> w2 + G4
# t = [t(δ1)..., t(δ2)..., t(δ3)..., t(δ4)...]
#   t(δ1): [t(q1 -> w1, G1, E1 -> A1), t(q1 -> w1, G1, E2 -> A1)]
#   t(δ2): [t(q1 -> w1, G2, E1 -> A1), t(q1 -> w1, G2, E2 -> A1)]
#   t(δ3): [t(q1 -> w2, G3, E1 -> A1), t(q1 -> w2, G3, E2 -> A1)]
#   t(δ4): [t(q1 -> w2, G4, E1 -> A1), t(q1 -> w2, G4, E2 -> A1)]
# ---------------------------------------------------------------------------- #

"""
    OrbitalOrdering(br::NewBandRep{D}) --> OrbitalOrdering{D}

Establishes a canonical, local ordering for the orbitals associated to a band representation
`br`. This is the default ordering used when associating row/column indices in a
tight-binding Hamiltonian block to specific orbitals in the associated band representations.

The canonical orbital ordering is stored in `.ordering`. The `i`th elements of `ordering`,
`ordering[i]`, is a `NamedTuple` with two fields:
`wp` and `idx`:
- `wp`: stores a Wyckoff position in the orbit of the Wyckoff position associated to
  `br.wp`.
- `idx`: stores the index of the partner function of the site-symmetry irrep associated to
  `br` at `wp`.

I.e., the `i`th orbital associated to `br` is located at `wp` and transforms as the `idx`th
partner function of the site-symmetry irrep of `br.siteir`.
The total number of orbitals associated to a band representation, and hence the length of
`ordering`, is the product of the site-symmetry irrep dimensionality and the number of sites
in the Wyckoff position orbit.
"""
function OrbitalOrdering(br::NewBandRep{D}) where {D}
    # we only want to include the wyckoff positions in the primitive cell - but the default
    # listings from `spacegroup` include operations that are "centering translations";
    # fortunately, the orbit returned for a `NewBandRep` do not include these redundant
    # operations - but is still specified in a conventional basis. So, below, we remove
    # redundant operations from the space group, and also change both the operations and the
    # positions from a conventional to a primitive basis
    sgnum = num(br)
    cntr = centering(sgnum, D)
    wps = primitivize.(orbit(group(br)), cntr)

    V = length(wps)       # number of Wyckoff positions in orbit
    Q = irdim(br.siteir) # number of orbitals partner functions at each Wyckoff position
    ordering = Vector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}(undef, V * Q)
    for i in 1:V
        for k in 1:Q
            ordering[(i-1)*Q+k] = (; wp = wps[i], idx = k)
        end
    end
    return OrbitalOrdering(ordering)
end

"""
    construct_M_matrix(
        h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D},
        [ordering1, ordering2]) 
        --> Array{Int,4}

Construct a set of matrices that encodes a Hamiltonian's term which resembles the hopping
from EBR `br1` to EBR `br2`.

The encoding is stored as a 4D matrix. Its last two axes correspond to elements of the
Bloch Hamiltonian H(k); its first axis corresponds to `orbit(h_orbit)` and the associated
complex exponentials stored in `v`; and its second axis to the elements of the vector `t`.
That is:

    Hₛₜ(k) = vᵢ(k) Mᵢⱼₛₜ tⱼ

See `devdocs.md` for details.
"""
function construct_M_matrix(
    h_orbit::HoppingOrbit{D},
    br1::NewBandRep{D},
    br2::NewBandRep{D},
    ordering1::OrbitalOrdering{D} = OrbitalOrdering(br1), # canonical orbital orderings for
    ordering2::OrbitalOrdering{D} = OrbitalOrdering(br2),  # `br1` & `br2`, respectively
) where {D}
    V = length(orbit(h_orbit))
    E = length(first(h_orbit.hoppings)) # number of hopping terms per δᵢ (assumed constant for all i)
    foreach(h_orbit.hoppings) do hops
        if length(hops) ≠ E
            error("Unexpectedly had different counts of hoppings across orbit elements")
        end
    end
    Q1, Q2 = irdim(br1.siteir), irdim(br2.siteir)
    Q = Q1 * Q2

    # matrix of matrices that will store the matrix-encoding for each Hamiltonian element
    Mm = zeros(Int, V, V * E * Q, length(ordering1), length(ordering2))

    # fill in the unit-elements of `Mm`
    for α in eachindex(ordering1), β in eachindex(ordering2)
        (q, i) = ordering1[α]
        (w, j) = ordering2[β]
        q = parent(q)
        w = parent(w)

        # assign a 1 to the correct position of WPs times irreps dimensionality
        for (r, hops) in enumerate(h_orbit.hoppings)
            offset0 = (r - 1) * E * Q
            for (x, hop) in enumerate(hops)
                q′, w′ = hop[1], hop[2]
                if isapprox(q′, q, nothing, false) && isapprox(w′, w, nothing, false)
                    offset1 = (x - 1) * Q
                    c = offset0 + offset1 + (j - 1) * Q1 + i
                    Mm[r, c, α, β] = 1
                end
            end
        end
    end

    return Mm
end

# H_{s,t} = v_i M_{i,j,s,t} t_j

"""
    representation_constraints_matrices(
        Mm::AbstractArray{Int,4}, 
        brₐ::NewBandRep{D},
        brᵦ::NewBandRep{D}) --> Vector{Array{ComplexF64,4}}

Build the Q matrix for a particular symmetry operation (or, equivalently, a particular matrix
from the site-symmetry representation), acting on the M matrix.
Relative to our white-board notes, Q has swapped indices, in the sense we below give `Q[i,j,r,l]`.

(ρₐₐ)ᵣₛ Hₛₜ (ρᵦᵦ⁻¹)ₜₗ = (ρₐₐ)ᵣₛ vᵢ Mᵢⱼₛₜ tⱼ (ρᵦᵦ⁻¹)ₜₗ = vᵢ (ρₐₐ)ᵣₛ Mᵢⱼₛₜ (ρᵦᵦ⁻¹)ₜₗ tⱼ,

then we can define: Qᵢⱼᵣₗ = (ρₐₐ)ᵣₛ Mᵢⱼₛₜ (ρᵦᵦ⁻¹)ₜₗ
"""
function representation_constraint_matrices(
    Mm::AbstractArray{Int, 4},
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D},
    gens::AbstractVector{SymOperation{D}},
) where {D}
    ρsₐₐ = sgrep_induced_by_siteir_excl_phase.(Ref(brₐ), gens)
    ρsᵦᵦ = sgrep_induced_by_siteir_excl_phase.(Ref(brᵦ), gens)

    Qs = [similar(Mm, ComplexF64) for _ in eachindex(gens)]
    for (n, (ρₐₐ, ρᵦᵦ)) in enumerate(zip(ρsₐₐ, ρsᵦᵦ))
        ρₐₐ = Matrix(ρₐₐ) # since `/` doesn't extend to BlockArrays currently
        ρᵦᵦ = Matrix(ρᵦᵦ) # for type consistency

        # we have constructed the representation matrices such that gΦ(k) = ρᵀ(g)Φ(Rk).
        # then, the Hamiltonian will be transformed due to symmetries as
        # H(RK) = ρₐₐ(g) H(k) ρᵦᵦ⁺(g), this can be translated into the numerical 
        # matrices as
        Q = Qs[n]
        for i in axes(Mm, 1), j in axes(Mm, 2)
            Q[i, j, :, :] .= ρₐₐ * (@view Mm[i, j, :, :]) * ρᵦᵦ'
        end
    end

    return Qs
end

"""
    obtain_basis_free_parameters(
        h_orbit::HoppingOrbit{D},
        brₐ::NewBandRep{D}, 
        brᵦ::NewBandRep{D}, 
        [orderingₐ = OrbitalOrdering(brₐ), orderingᵦ = OrbitalOrdering(brᵦ)]
        )                            --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}

Obtain the basis of free parameters for the hopping terms between `brₐ` and `brᵦ` 
associated with the hopping orbit `h_orbit`.

## Note

The presence or absence of time-reversal symmetry is inferred implicitly from `brₐ` and `brᵦ`.
"""
function obtain_basis_free_parameters(
    h_orbit::HoppingOrbit{D},
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D},
    orderingₐ::OrbitalOrdering{D} = OrbitalOrdering(brₐ),
    orderingᵦ::OrbitalOrdering{D} = OrbitalOrdering(brᵦ);
    diagonal_block::Bool = true,
    antihermitian::Bool = true,
) where {D}
    # obtain the needed representations over the generators of each bandrep
    gensₐ = generators(num(brₐ), SpaceGroup{D})
    gensᵦ = generators(num(brᵦ), SpaceGroup{D})
    @assert gensₐ == gensᵦ # must be from same space group and in same sorting
    brₐ.timereversal == brᵦ.timereversal ||
        error("input band representations must have identical time-reversal symmetry")
    timereversal = brₐ.timereversal

    # cast generators to primitive basis
    cntr = centering(num(brₐ), D)
    gens = cntr ∈ ('P', 'p') ? gensₐ : primitivize.(gensₐ, cntr)

    # encode Hamiltonian as a coefficient matrix sandwiched by exponentials & hopping ampl.
    Mm = construct_M_matrix(h_orbit, brₐ, brᵦ, orderingₐ, orderingᵦ)

    # actual computation
    tₐᵦ_basis_reim = _obtain_basis_free_parameters(
        h_orbit, brₐ, brᵦ, orderingₐ, orderingᵦ, Mm, gens, 
        timereversal, diagonal_block, antihermitian
    )

    return Mm, tₐᵦ_basis_reim
end

function _obtain_basis_free_parameters(
    h_orbit::HoppingOrbit{D},
    brₐ::NewBandRep{D},
    brᵦ::NewBandRep{D},
    orderingₐ::OrbitalOrdering{D},
    orderingᵦ::OrbitalOrdering{D},
    Mm::Array{Int, 4},
    gens::AbstractVector{SymOperation{D}},
    timereversal::Bool,
    diagonal_block::Bool,
    antihermitian::Bool,
) where {D}
    # encode representation constraints on Hₐᵦ
    Qs = representation_constraint_matrices(Mm, brₐ, brᵦ, gens)

    # encode reciprocal-rotation constraints on Hₐᵦ
    Zs = reciprocal_constraints_matrices(Mm, gens, h_orbit)

    # build an aggregate constraint matrix, over all generators, acting on the hopping
    # coefficient vector tₐᵦ associated with h_orbit
    constraints = _aggregate_constraints(Qs, Zs)
    tₐᵦ_basis_matrix = nullspace(constraints; atol = NULLSPACE_ATOL_DEFAULT)

    # at this point, the coefficient-space spanning `tₐᵦ_basis` is implicitly complex; this
    # is conceptually not too nice for a Hamiltonian, and we'd like to work with strictly
    # real coefficients. To that end, we "split" the possible products of such complex
    # coefficients with a complex basis vector into two vectors, where the lower half of
    # each represents the imaginary part of the product. The benefit of this is that it
    # becomes possible to take the complex conjugate of each element "symbolically" by
    # simply multiplying with [1 0; 0 -1] (block matrix). We need to do this anyway if we
    # we have `timereversal = true`, but it's nice to just have a shared representation
    # of the basis vectors, so we do it here as well.

    # If the set of basis vectors obtained from symmetry constraints was empty, there's no
    # point in continuing: we then return early
    isempty(tₐᵦ_basis_matrix) && return Vector{Vector{Float64}}()

    # Details: we split up each potentially complex "basis" vector `t = tₐᵦ_basis[i]` into
    # two real vectors `x` and `y`, such that the _real_ span of `x` and `y` is equivalent
    # to the complex span of `t`; the key is that we must interpret the lower halfs of `x`
    # and `y` as representing imaginary numbers. Crucially, this must be kept in mind
    # everywhere that we use a coefficient vector. In particular, we now must always
    # interpret `Mm` as acting like `[Mm Mm]` when meeting a "doubled" basis vector of this
    # kind.
    # Example: we have `t₁ = [im,0]`, `t₂ = [1,im]`, and `tₐᵦ_basis = [t₁,t₂]`, then:
    #    ```
    #    julia> tₐᵦ_basis_split = split_complex.(tₐᵦ_basis)
    #    2-element Vector{Matrix{Int64}}:
    #     [0 -1; 0 0; 1 0; 0 0]
    #     [1 0; 0 -1; 0 1; 1 0]
    #
    #    julia> tₐᵦ_basis_split_matrix = reduce(hcat, tₐᵦ_basis_split)
    #    4×4 Matrix{Int64}:
    #     0  -1  1   0
    #     0   0  0  -1
    #     1   0  0   1
    #     0   0  1   0
    #    ```
    # See `split_complex` for more details on the real/imaginary splitting.
    N = 2size(Mm, 2) # number of elements per `t`-vector, when doubled
    tₐᵦ_basis_reim = split_complex.(eachcol(tₐᵦ_basis_matrix))
    tₐᵦ_basis_reim_matrix =
        reduce(hcat, tₐᵦ_basis_reim; init = Matrix{Float64}(undef, N, 0))

    ## ----------------------------------------------------------------------------------- #
    if timereversal # "add" & "intersect" the associated TRS constraints
        # now we want to construct the TRS constraints, and then intersect the allowable basis
        # terms on that constraint with those corresponding to the previously computed basis
        tₐᵦ_basis_tr_reim_matrix =
            obtain_basis_free_parameters_TRS(h_orbit, brₐ, brᵦ, orderingₐ, orderingᵦ, Mm)
        tₐᵦ_basis_reim =
            zassenhaus_intersection(tₐᵦ_basis_reim_matrix, tₐᵦ_basis_tr_reim_matrix)
        tₐᵦ_basis_reim_matrix =
            reduce(hcat, tₐᵦ_basis_reim; init = Matrix{Float64}(undef, N, 0))
    end
    isempty(tₐᵦ_basis_reim_matrix) && return Vector{Vector{Float64}}()

    # ------------------------------------------------------------------------------------ #
    # "add" & "intersect" the associated hermiticity constraints if this is a diagonal block
    if diagonal_block
        tₐᵦ_basis_herm_reim_matrix = obtain_basis_free_parameters_hermiticity(
            h_orbit,
            brₐ,
            brᵦ,
            orderingₐ,
            orderingᵦ,
            Mm;
            antihermitian,
        )

        tₐᵦ_basis_reim =
            zassenhaus_intersection(tₐᵦ_basis_reim_matrix, tₐᵦ_basis_herm_reim_matrix)
        tₐᵦ_basis_reim_matrix =
            reduce(hcat, tₐᵦ_basis_reim; init = Matrix{Float64}(undef, N, 0))
    end
    isempty(tₐᵦ_basis_reim_matrix) && return Vector{Vector{Float64}}()

    # ------------------------------------------------------------------------------------ #
    # Make sure we have a reasonably pretty-looking basis in the end by sparsifying &
    # dropping near-zero elements explicitly

    # convert null-space to a sparse column form
    tₐᵦ_basis_reim_matrix_form′ = _poormans_sparsification(tₐᵦ_basis_reim_matrix)
    tₐᵦ_basis_reim = [collect(v) for v in eachcol(tₐᵦ_basis_reim_matrix_form′)]

    # prune near-zero elements of basis vectors
    _prune_at_threshold!(tₐᵦ_basis_reim)

    return tₐᵦ_basis_reim
end

function _aggregate_constraints(
    Q::AbstractArray{<:Number, 4},
    Z::AbstractArray{<:Number, 4},
    row_atol::Real = 1e-10,
)
    # store constraints in one big vector initially; then we reshape to a matrix after
    constraint_vs = Vector{promote_type(eltype(Q), eltype(Z))}()
    _aggregate_constraints!(constraint_vs, Q, Z, row_atol)

    # return a C×J matrix where each row is a constraint, across C constraints
    J = size(Q, 2) # number of elements per constraint
    return _reshape_aggregate_constraints(constraint_vs, J)
end

function _aggregate_constraints(
    # same as `_aggregate_constraints(Q, V)` but for a vector of Qs and Zs
    Qs::AbstractVector{<:AbstractArray{<:Number, 4}},
    Zs::AbstractVector{<:AbstractArray{<:Number, 4}},
    row_atol::Real = 1e-10,
)
    constraint_vs = Vector{promote_type(eltype(eltype(Qs)), eltype(eltype(Zs)))}()
    for (Q, Z) in zip(Qs, Zs)
        _aggregate_constraints!(constraint_vs, Q, Z, row_atol)
    end
    J = size(first(Qs), 2)
    return _reshape_aggregate_constraints(constraint_vs, J)
end

function _aggregate_constraints!( # modifies `constraint_vs` in place
    constraint_vs::Vector{<:Number},
    Q::AbstractArray{<:Number, 4},
    Z::AbstractArray{<:Number, 4},
    row_atol::Real = 1e-10,
)
    # store constraints in one big vector initially; then we reshape to a matrix after
    J = size(Q, 2)
    c = Vector{eltype(constraint_vs)}(undef, J)

    # avoid repeated recomputation of `norm(c′)` in collinearity check below
    norms = if isempty(constraint_vs)
        Vector{typeof(norm(c))}()
    else # `constraint_vs` is not empty
        map(1:J:length(constraint_vs)) do n
            c′ = @view constraint_vs[n:n+J-1]
            norm(c′)
        end
    end

    # aggregate constraints into `constraint_vs`
    for i in axes(Q, 1), s in axes(Q, 3), t in axes(Q, 4)
        q = @view Q[i, :, s, t]
        z = @view Z[i, :, s, t]
        c .= q .- z

        # don't add empty or near-empty constraints
        norm_c = norm(c)
        norm_c < row_atol && continue

        # check whether `c` is collinear w/ any existing constraint; if so, don't add again
        c_dot_c′s = reshape(constraint_vs, J, length(constraint_vs) ÷ J)' * c # elements are `dot(c, c′)`, with `c′` and existing constraint
        collinear = any(zip(c_dot_c′s, norms)) do (c_dot_c′, norm_c′)
            # NB: works also if zip(…) is empty, cf. `any("empty iterator") = false`
            abs(c_dot_c′) ≈ norm_c * norm_c′ # collinear if true
        end
        collinear && continue

        # add the constraint to the list
        append!(constraint_vs, c)
        append!(norms, norm_c)
    end

    return constraint_vs
end

function _reshape_aggregate_constraints(
    constraint_vs::Vector{<:Number}, # vector of inline-concatenated constraints
    J::Int, # number of elements per constraint: ≡ size(Mm,2) = size(Q,2) = size(Z,2)
)
    C = length(constraint_vs) ÷ J # number of constraints
    return permutedims(reshape(constraint_vs, J, C))
end

"""
    reciprocal_constraints_matrices(
                                    Mm::AbstractArray{Int,4}, 
                                    gens::AbstractVector{SymOperation{D}}, 
                                    h_orbit::HoppingOrbit{D}
                                    ) --> Vector{Array{Int,4}}

Compute the reciprocal constraints matrices for the generators of the SG. This is done by
permuting the rows of the M matrix according to the symmetry operation acting on k-space.
See more details in
`permute_symmetry_related_hoppings_under_symmetry_operation` and `devdocs.md`.
"""
function reciprocal_constraints_matrices(
    Mm::AbstractArray{Int, 4},
    gens::AbstractVector{SymOperation{D}},
    h_orbit::HoppingOrbit{D},
) where {D}
    Zs = Vector{Array{Int, 4}}(undef, length(gens))
    for (i, op) in enumerate(gens)
        Z = similar(Mm)
        Pᵀ = transpose(
            _permute_symmetry_related_hoppings_under_symmetry_operation(h_orbit, op),
        )
        for s in axes(Mm, 3)
            for t in axes(Mm, 4) # vᵀ Ρᵀ Mₛₜ t => vₗ Ρᵀₗᵢ Mᵢⱼₛₜ tⱼ = vₗ Pᵢₗ Mᵢⱼₛₜ tⱼ
                Z[:, :, s, t] .= Pᵀ * @view Mm[:, :, s, t] # Pᵀ M⁽ˢᵗ⁾
            end
        end
        Zs[i] = Z
    end
    return Zs
end

"""
Build the P matrix for a particular symmetry operation acting on k-space, which permutes the
rows of the M matrix.

For obtaining the P matrix, we make use that the action is on exponential of the type:
``𝐞xp(2πk⋅δ)``, to instead act on δ ∈ `h_orbit.orbit` instead of k, which is a symbolic
variable. Because of that, we need to use the inverse of the rotation part of the symmetry
operation.

!!! details "Sketch of proof"
    Assume g={R|τ} and `Crystalline` implements gk=(R⁻¹)ᵀk. Then
    (gk)⋅δ = ((R⁻¹)ᵀk)⋅δ + τ = k⋅(R⁻¹)δ.

!!! info
    It is assumed that the operation `op` is provided in a primitive setting.

!!! warning
    This function is an internal helper function for `reciprocal_constraints_matrices` and
    is not part of the public API.
"""
function _permute_symmetry_related_hoppings_under_symmetry_operation(
    h_orbit::HoppingOrbit{D},
    op::SymOperation{D},
) where {D}
    # P is a square matrix that acts as `op` on `v`, i.e., represents ``op ∘ v``, via a
    # matrix-vector product `P*v`. Equivalently, `P` can act on `M` (via its transpose)
    # for expressions of the kind (Pv)ᵀ M … = vᵀ Pᵀ M …
    P = zeros(Int, length(orbit(h_orbit)), length(orbit(h_orbit)))
    for (i, δᵢ) in enumerate(orbit(h_orbit))
        # crystalline implements gk = [R⁻¹]ᵀk. However, since we don't have access to k,
        # being a symbolic variable, we will translate its action into δ. For this,
        # we implement a simple trick: ([R⁻¹]ᵀ k)·r = R⁻¹ᵢⱼ kᵢ rⱼ = k·(R⁻¹ r)
        R⁻¹ = SymOperation(inv(rotation(op))) # rotation-only part of `op`
        δᵢ′ = compose(R⁻¹, δᵢ)
        j = findfirst(δ′′ -> isapprox(δᵢ′, δ′′, nothing, false), orbit(h_orbit))
        isnothing(j) &&
            error(lazy"hopping element $δᵢ not closed under $op in $(orbit(h_orbit))")
        P[i, j] = 1
        # since P acts as g v = P v, we have (gv)ᵢ = vⱼ = ∑ₖ Pᵢₖ vₖ so Pᵢₖ = δᵢⱼ
    end
    return P
end

"""
Poor man's "matrix sparsification" via the reduced row echelon form.

!!! warning
    This function is an internal helper function for `obtain_basis_free_parameters` and
    is not part of the public API.
"""
function _poormans_sparsification(
    A::AbstractMatrix{<:Number};
    rref_tol::Union{Nothing, Float64} = SPARSIFICATION_ATOL_DEFAULT,
)
    # following appendix E of the Qsymm paper (https://arxiv.org/abs/1806.08363) [copied
    # over from Neumann.jl] [copied over from MPBUtils.jl]
    if !isnothing(rref_tol)
        # use a relatively low tolerance in `rref` to avoid explosions of errors
        # NB: this optional tolerance argument of `rref!` is undocumented :(
        return transpose(rref!(copy(transpose(A)), rref_tol))
    end
    return transpose(rref(transpose(A)))
end

"""
Prune near-zero elements of vectors in `vs`.

!!! warning
    This function is an internal helper function for `obtain_basis_free_parameters` and
    is not part of the public API.
"""
function _prune_at_threshold!(
    vs::AbstractVector{<:AbstractVector{T}};
    atol::Real = PRUNE_ATOL_DEFAULT,
) where {T <: Complex}
    for v in vs
        for (j, vⱼ) in enumerate(v)
            rⱼ, iⱼ = reim(vⱼ)
            rⱼ′ = ifelse(abs(rⱼ) < atol, zero(real(T)), rⱼ)
            iⱼ′ = ifelse(abs(iⱼ) < atol, zero(real(T)), iⱼ)
            v[j] = T(rⱼ′, iⱼ′)
        end
    end
    return vs
end

function _prune_at_threshold!(
    vs::AbstractVector{<:AbstractVector{T}};
    atol::Real = PRUNE_ATOL_DEFAULT,
) where {T <: Real} # needed for type consistency in TRS implementation
    for v in vs
        for (j, vⱼ) in enumerate(v)
            v[j] = abs(vⱼ) < atol ? zero(T) : vⱼ
        end
    end
    return vs
end

# ---------------------------------------------------------------------------- #

"""
    tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) 
        --> Vector{TightBindingTerm{D}}

Construct the TB Hamiltonian matrix from a given composite band representation `cbr` and a
set of global translation-representatives `Rs`.
The Hamiltonian is constructed block by block according to the symmetry-related hoppings
between the band representations in `cbr`.
Several models returned, each representing a term that is closed under the symmetry operations of 
the underlying space group.
"""
function tb_hamiltonian(
    cbr::CompositeBandRep{D},
    Rs::AbstractVector{Vector{Int}} = [zeros(Int, D)]; # "global" hopping translation-representatives
    antihermitian::Bool = false,
) where {D}
    if any(c -> !isinteger(c) || c < 0, cbr.coefs)
        error("the input composite band representation does not have a symmetric \
               tight-binding model: its expansion in EBRs contain negative or \
               fractional coefficients")
    end
    coefs = round.(Int, cbr.coefs)

    # find all bandreps featured in the composite bandrep and build a "repeated" entry list
    brs = Vector{NewBandRep{D}}(undef, sum(coefs))
    idx = 0
    for (i, c) in enumerate(coefs)
        for _ in 1:c
            brs[idx+=1] = cbr.brs[i]
        end
    end

    if any(br -> !iszero(free(position(br))), brs)
        error("free parameters in Wyckoff positions are not supported; any non-special \
               Wyckoff position must have its free parameters pinned to a definite value \
               prior to calling `tb_hamiltonian`: see `pin_free!`")
    end

    # find all families of hoppings between involved band representations: the TB model will
    # be divided into each of these representatives since they will be symmetry independent
    hermiticity = antihermitian ? ANTIHERMITIAN : HERMITIAN
    B = length(brs)
    axis = BlockArrays.BlockedOneTo((cumsum(occupation(br) for br in brs)))
    tbs = Vector{TightBindingTerm{D}}()
    for d in 0:B-1 # offset from main diagonal (at 0)
        for block_i in 1:B-d
            # we iterate here across diagonal blocks, going from the main diagonal and up
            # toward the upper block-diagonals: we do this to get a more natural sorting of
            # the terms in the model, with self-hoppings first
            # we only go over the upper triangular part cf. hermiticity/anti-hermiticity
            block_j = block_i + d
            br1 = brs[block_i]
            br2 = brs[block_j]
            ordering1 = OrbitalOrdering(br1)
            ordering2 = OrbitalOrdering(br2)
            h_orbits = obtain_symmetry_related_hoppings(Rs, br1, br2)
            for h_orbit in h_orbits
                Mm, t_αβ_basis = obtain_basis_free_parameters(
                    h_orbit,
                    br1,
                    br2,
                    ordering1,
                    ordering2;
                    diagonal_block = d == 0,
                    antihermitian,
                )
                for t in t_αβ_basis
                    block =
                        TightBindingBlock{D}(br1, br2, ordering1, ordering2, h_orbit, Mm, t)
                    h = TightBindingTerm{D}(
                        axis,
                        (block_i, block_j),
                        block,
                        hermiticity,
                        brs,
                    )
                    push!(tbs, h)
                end
            end
        end
    end

    return TightBindingModel(tbs, cbr)
end

#=
"""
    occupation(br::NewBandRep{D}) --> Int

Counts the number of orbitals in a band representation `br`. This is done by taking 
the multiplicity of the Wyckoff position associated to `br`, dividing it by the 
centering volume fraction (excluding copies due to conventional setting) and 
multiplying it by the dimension of the site irrep.

NB: This is equivalent to `occupation(br)`..!
"""
function occupation(br::NewBandRep{D}) where {D}
    mult = multiplicity(position(br)) # multiplicity in conventional setting
    # we need the Wyckoff multiplicity, excluding conventional-centering copies, so we
    # divide by the the number of centering-translations
    cntr = centering(num(br), D)
    denom = centering_volume_fraction(cntr, Val(D), Val(D))
    mult = div(mult, denom)

    return mult * irdim(br.siteir)
end
=#
