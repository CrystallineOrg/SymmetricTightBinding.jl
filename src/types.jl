"""
    TightBindingCandidateSet

A structure for storing information about a set of tight-binding candidates for the photonic
crystal.
"""
struct TightBindingCandidateSet <: AbstractVector{CompositeBandRep{3}}
  longitudinal::CompositeBandRep{3}    # `n·¥∏`
  apolarv::Vector{CompositeBandRep{3}} # `n·µÄ‚Å∫·¥∏[i]` over `i ‚àà eachindex(apolarv)`    
  ps::Vector{Vector{Float64}}          # `ps[i]` associates to `n·µÄ‚Å∫·¥∏[i]`; w/ n·µÄ(œâ=0) = n_fixed + Q*p
end
Base.size(tbc::TightBindingCandidateSet) = (length(tbc.apolarv),)
longitudinal(tbc::TightBindingCandidateSet) = tbc.longitudinal
Base.getindex(tbc::TightBindingCandidateSet, i::Int) = tbc.apolarv[i]
Base.setindex!(::TightBindingCandidateSet, v, i::Int) = error("setindex! is not supported")

"""
    HoppingOrbit{D}

A structure holding information about symmetry-related spatial hopping vectors.

An orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the
symmetry operations of the underlying space group to a representative vector Œ¥.

For each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site `a` to site
`b`, possibly related by a lattice translation `R`. Each such set of possible hopping term
`(a, b, R)` is for each `Œ¥·µ¢` is stored elements as the `i`th element of the vector
`hoppings`.

## Fields
- `representative :: RVec{D}`: the representative hopping vector Œ¥
- `orbit :: Vector{RVec{D}}`: the Œ¥·µ¢ elements of the orbit generated by Œ¥.
  Generally `orbit[1] == representative`, i.e., `Œ¥‚ÇÅ = Œ¥`
- `hoppings :: Vector{Vector{NTuple{3,RVec{D}}}}`: the `i`th element gives the possible
  physical hopping terms `(a,b,R)` associated to `orbit[i]`. Multiple physical hopping terms
  may correspond to each element of the orbit. 
  For `(a, b, R) = hoppings[i][j]`, we have `orbit[i] = Œ¥·µ¢ = b + R - a`
"""
struct HoppingOrbit{D}
  representative::RVec{D} # representative hopping vector Œ¥
  orbit::Vector{RVec{D}}  # orbit of the hopping vector {Œ¥·µ¢ ‚Ä¶}
  hoppings::Vector{Vector{NTuple{3,RVec{D}}}} # `[(a,b,R), ...]` for every `orbit[i]`
end
representative(s::HoppingOrbit) = s.representative
Crystalline.orbit(s::HoppingOrbit) = s.orbit # extend to avoid clash w/ Crystalline's `orbit`



# ---------------------------------------------------------------------------------------- #
# constructor defined in /src/tightbinding.jl

struct OrbitalOrdering{D} <: AbstractVector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
  ordering :: Vector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
end
Base.getindex(o::OrbitalOrdering, i::Int) = o.ordering[i]
Base.size(o::OrbitalOrdering) = size(o.ordering)
Base.setindex!(::OrbitalOrdering, v, i::Int) = error("setindex! is not supported")

# ---------------------------------------------------------------------------------------- #

"""
    TightBindingElementString

A structure for pretty-printing tight-binding matrix elements.

## Fields
- `s :: String`: the string representing the tight-binding matrix element
"""
struct TightBindingElementString
  s::String
end
function Base.show(io::IO, tbe_str::TightBindingElementString)
  if tbe_str.s == "0"
    # TODO: change to `printstyled(io, "0"; color=:light_black)` if/when
    #       https://github.com/JuliaArrays/BlockArrays.jl/pull/443 is merged    
    print(io, "0")
  else
    print(io, tbe_str.s)
  end
end

"""
    TightBindingBlock{D}

A structure for storing information about a matrix block of a tight-binding Hamiltonian.

A block will represent the hopping terms between two band representations `br1` and `br2`. 
For this hopping we store the order of the hopping terms, the matrix codifying the Hamiltonian
`Mm` and the basis vectors `t_Œ±Œ≤_basis` which indicates the symmetry related free-coefficients.

## Fields
- `block_ij :: Tuple{Int,Int}`: indices of the block in the full tight-binding matrix
- `global_ij :: Tuple{Int,Int}`: indices of the particular block 
- `br1 :: NewBandRep{D}`: first band representation
- `br2 :: NewBandRep{D}`: second band representation
- `ordering1 :: OrbitalOrdering{D}`: ordering of the orbitals in `br1`
- `ordering2 :: OrbitalOrdering{D}`: ordering of the orbitals in `br2`
- `Mm :: Array{Int,4}`: matrix codifying Hamiltonian
- `t_Œ±Œ≤_basis :: Vector{Vector{ComplexF64}}`: basis vectors for the free coefficients
- `h_orbit :: Union{Nothing,HoppingOrbit{D}}`: hopping orbit associated to the block
- `c_idxs :: UnitRange{Int}`: indices of the free coefficients
"""
struct TightBindingBlock{D} <: AbstractMatrix{TightBindingElementString}
  block_ij::Tuple{Int,Int}
  global_ij::Tuple{Int,Int}
  br1::NewBandRep{D}
  br2::NewBandRep{D}
  ordering1::OrbitalOrdering{D}
  ordering2::OrbitalOrdering{D}
  Mm::Array{Int,4}
  t_Œ±Œ≤_basis::Vector{Vector{ComplexF64}}
  h_orbit::Union{Nothing,HoppingOrbit{D}}
  c_idxs::UnitRange{Int}
  #  hermiticity::Bool
  # TODO: figure out how much of this is needed, e.g.:
  # TODO: find better schema for naming the free coefficients than the arbitrary `c_idxs`
  # TODO: do we need the indexing information in `block_ij` and `global_ij`? Probably not
  # -> global_ij isn't even used in the code, not even block_ij, br1, br2, ordering1, ordering2...
end
Base.size(tbb::TightBindingBlock) = (size(tbb.Mm, 3), size(tbb.Mm, 4))
function Base.getindex(tbb::TightBindingBlock, i::Int, j::Int)
  h_orbit = tbb.h_orbit
  isnothing(h_orbit) && return TightBindingElementString("0") # no hopping term
  h_orbit = something(h_orbit)
  exp_strs = Vector{String}(undef, length(orbit(h_orbit)))
  for (n, Œ¥‚Çô) in enumerate(orbit(h_orbit))
    io_kr = IOBuffer()
    first_nonzero = true
    for (l, Œ¥‚Çô‚Çó) in enumerate(Œ¥‚Çô.cnst)
      abs2Œ¥‚Çô‚Çó = 2abs(Œ¥‚Çô‚Çó) # multiplied by 2 due to the 2œÄ factor in the exponential, but absolute value?
      abs2Œ¥‚Çô‚Çó < SPARSIFICATION_ATOL_DEFAULT && continue
      if Œ¥‚Çô‚Çó < 0 || !first_nonzero
        print(io_kr, Crystalline.signaschar(Œ¥‚Çô‚Çó))
      end
      first_nonzero = false
      str_enum, v_r, v_str = _stringify_characters(abs2Œ¥‚Çô‚Çó)
      str_enum == REAL_STR || error(lazy"unexpected imaginary component in exponential argument $abs2Œ¥‚Çô‚Çó")
      isone(v_r) || print(io_kr, v_str)
      print(io_kr, "k", Crystalline.subscriptify(string(l)))
    end
    exp_arg = String(take!(io_kr))
    if !isempty(exp_arg)
      exp_strs[n] = "ùïñ(" * exp_arg * ")" # short-hand: ùïñ(x) = exp(iœÄx); x = k‚ãÖ2Œ¥
    #                                      ùïñ(x) = exp(iœÄ2Œ¥)
    else
      exp_strs[n] = "" # = 1, but omit for compactness
    end
  end
  
  io = IOBuffer()
  Mm = tbb.Mm
  first_t_Œ±Œ≤_basis_vec = true
  for k in eachindex(tbb.t_Œ±Œ≤_basis)
    M‚Å± ≤t·µè = Mm[:, :, i, j] * tbb.t_Œ±Œ≤_basis[k] # symmetry related Hamiltonian terms
    nnz_els = count(v -> abs(v) > SPARSIFICATION_ATOL_DEFAULT, M‚Å± ≤t·µè)
    nnz_els == 0 && continue
    first_t_Œ±Œ≤_basis_vec ? (first_t_Œ±Œ≤_basis_vec = false) : (print(io, " + "))
    print(io, "c", Crystalline.subscriptify(string(tbb.c_idxs[k])))
    nnz_els > 1 && print(io, "[")
    first = true
    for (n, v) in enumerate(M‚Å± ≤t·µè)
      abs(v) < SPARSIFICATION_ATOL_DEFAULT && continue
      str_enum, v_r, v_str = _stringify_characters(v)
      if str_enum == REAL_STR || str_enum == IMAG_STR
        if isone(abs(v_r))
          v_str = ""
        else
          v_str = lstrip(v_str, ('-', '+'))
        end
        if first
          v_str = (v_r < 0 ? "-" : "") * v_str
        else
          v_str = (v_r < 0 ? "-" : "+") * v_str
        end
      else
        v_str = (first ? "" : " + ") * "(" * v_str * ")"
      end
      print(io, v_str, exp_strs[n])
      first = false
    end
    nnz_els > 1 && print(io, "]")
  end
  s = String(take!(io))
  isempty(s) && (s = "0")
  return TightBindingElementString(s)
end
Base.setindex!(::TightBindingBlock, v, ij...) = error("setindex! is not supported")

# pretty-printing of scalars

@enum StrPrintAs begin
  REAL_STR
  IMAG_STR
  COMPLEX_STR
end
function _stringify_characters(c::Number; digits::Int=3)
  c‚Ä≤ = round(c; digits)
  cr, ci = reim(c‚Ä≤)
  if iszero(ci)     # real
    isinteger(cr) && return (REAL_STR, cr, string(Int(cr)))
    return (REAL_STR, cr, string(cr))
  elseif iszero(cr) # imaginary
    isinteger(ci) && return (IMAG_STR, ci, string(Int(ci)) * "i")
    return (IMAG_STR, ci, string(ci) * "i")
  else              # complex
    if isinteger(cr) && isinteger(ci)
      return COMPLEX_STR, zero(cr), _complex_as_compact_string(Complex{Int}(cr, ci))
    else
      return COMPLEX_STR, zero(cr), _complex_as_compact_string(c‚Ä≤)
    end
  end
end
function _complex_as_compact_string(c::Complex) # usual string(::Complex) has spaces; 
  # avoid that
  io = IOBuffer()
  print(io, real(c), Crystalline.signaschar(imag(c)), abs(imag(c)), "i")
  return String(take!(io))
end

struct NewTightBindingBlock{D} <: AbstractMatrix{TightBindingElementString}
  br1::NewBandRep{D}
  br2::NewBandRep{D}
  ordering1::OrbitalOrdering{D}
  ordering2::OrbitalOrdering{D}
  Mm::Array{ComplexF64,3}
  t_Œ±Œ≤_basis::Vector{Array{ComplexF64,3}}
  c_idxs::Vector{Int}
end

# struct TightBindingMatrix{D} <: AbstractBlockMatrix
# end