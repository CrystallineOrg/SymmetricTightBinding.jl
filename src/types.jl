"""
    TightBindingCandidateSet

A structure for storing information about a set of tight-binding candidates for the photonic
crystal.
"""
struct TightBindingCandidateSet <: AbstractVector{CompositeBandRep{3}}
    longitudinal::CompositeBandRep{3}    # `n·¥∏`
    apolarv::Vector{CompositeBandRep{3}} # `n·µÄ‚Å∫·¥∏[i]` over `i ‚àà eachindex(apolarv)`
    ps::Vector{Vector{Float64}}          # `ps[i]` associates to `n·µÄ‚Å∫·¥∏[i]`; w/ n·µÄ(œâ=0) = n_fixed + Q*p
end
Base.size(tbc::TightBindingCandidateSet) = (length(tbc.apolarv),)
longitudinal(tbc::TightBindingCandidateSet) = tbc.longitudinal
Base.getindex(tbc::TightBindingCandidateSet, i::Int) = tbc.apolarv[i]
Base.setindex!(::TightBindingCandidateSet, v, i::Int) = error("setindex! is not supported")

"""
    HoppingOrbit{D}

A structure holding information about symmetry-related spatial hopping vectors.

An orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the
symmetry operations of the underlying space group to a representative vector Œ¥.

For each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site `a` to site
`b`, possibly related by a lattice translation `R`. Each such set of possible hopping term
`(a, b, R)` is for each `Œ¥·µ¢` is stored elements as the `i`th element of the vector
`hoppings`.

## Fields
- `representative :: RVec{D}`: the representative hopping vector Œ¥
- `orbit :: Vector{RVec{D}}`: the Œ¥·µ¢ elements of the orbit generated by Œ¥.
  Generally `orbit[1] == representative`, i.e., `Œ¥‚ÇÅ = Œ¥`
- `hoppings :: Vector{Vector{NTuple{3,RVec{D}}}}`: the `i`th element gives the possible
  physical hopping terms `(a,b,R)` associated to `orbit[i]`. Multiple physical hopping terms
  may correspond to each element of the orbit. 
  For `(a, b, R) = hoppings[i][j]`, we have `orbit[i] = Œ¥·µ¢ = b + R - a`
"""
struct HoppingOrbit{D}
    representative::RVec{D} # representative hopping vector Œ¥
    orbit::Vector{RVec{D}}  # orbit of the hopping vector {Œ¥·µ¢ ‚Ä¶}
    hoppings::Vector{Vector{NTuple{3, RVec{D}}}} # `[(a,b,R), ...]` for every `orbit[i]`
end
representative(s::HoppingOrbit) = s.representative
Crystalline.orbit(s::HoppingOrbit) = s.orbit # extend to avoid clash w/ Crystalline's `orbit`

# ---------------------------------------------------------------------------------------- #
# constructor defined in /src/tightbinding.jl

struct OrbitalOrdering{D} <: AbstractVector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
    ordering::Vector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
end
Base.getindex(o::OrbitalOrdering, i::Int) = o.ordering[i]
Base.size(o::OrbitalOrdering) = size(o.ordering)
Base.setindex!(::OrbitalOrdering, v, i::Int) = error("setindex! is not supported")
Base.IndexStyle(::Type{OrbitalOrdering}) = IndexLinear()
Base.iterate(o::OrbitalOrdering) = iterate(o.ordering)
Base.iterate(o::OrbitalOrdering, i) = iterate(o.ordering, i)

# ---------------------------------------------------------------------------------------- #

"""
    TightBindingElementString

A structure for pretty-printing tight-binding matrix elements.

## Fields
- `s :: String`: the string representing the tight-binding matrix element
- `active :: Bool`: whether the element belongs to an "active" block - i.e., one we want to
  highlight (then shown in blue).
"""
struct TightBindingElementString
    s::String
    active::Bool
end
function Base.show(io::IO, tbe_str::TightBindingElementString)
    s = tbe_str.s
    color = (
        tbe_str.active ? (s == "0" ? :normal : :blue) : (s == "0" ? :light_black : :normal)
    )
    printstyled(io, s; color)
end

"""
    TightBindingBlock{D}

A structure for storing information about a matrix block of a tight-binding Hamiltonian.

A block will represent a hopping terms between two band representations `br1` and `br2`. 
For this hopping we store:

## Fields
- `br1 :: NewBandRep{D}`: first band representation
- `br2 :: NewBandRep{D}`: second band representation
- `ordering1 :: OrbitalOrdering{D}`: ordering of the orbitals in `br1`
- `ordering2 :: OrbitalOrdering{D}`: ordering of the orbitals in `br2`
- `h_orbit :: Union{Nothing,HoppingOrbit{D}}`: hopping orbit associated to the block
- `Mm :: Array{Int,4}`: matrix codifying Hamiltonian
- `t :: Vector{Float64}}`: a basis vector, stored in re/im-doubled format
"""

struct TightBindingBlock{D} <: AbstractMatrix{TightBindingElementString}
    br1::NewBandRep{D}
    br2::NewBandRep{D}
    ordering1::OrbitalOrdering{D}
    ordering2::OrbitalOrdering{D}
    h_orbit::HoppingOrbit{D}
    Mm::Array{Int, 4}
    t::Vector{Float64}
end
Base.size(tbb::TightBindingBlock) = (size(tbb.Mm, 3), size(tbb.Mm, 4))

@enum Hermiticity::UInt8 begin
    HERMITIAN
    ANTIHERMITIAN
end

struct TightBindingTerm{D} <: AbstractBlockMatrix{TightBindingElementString}
    axis::BlockedOneTo{Int, Vector{Int}}
    block_ij::NTuple{2, Int}
    block::TightBindingBlock{D}
    hermiticity::Hermiticity
    brs::Vector{NewBandRep{D}}
end

Base.axes(H::TightBindingTerm) = (H.axis, H.axis)
function Base.axes(H::TightBindingTerm, d::Int)
    d > 2 ? Base.BlockedOneTo([1]) :
    d > 0 ? H.axis : error("dimensionality must be greater than 1")
end
Base.size(H::TightBindingTerm) = (N = last(H.axis); (N, N))

function Base.getindex(H::TightBindingTerm, i::Int, j::Int)
    N = size(H, 1)
    @boundscheck 1 ‚â§ i ‚â§ N && 1 ‚â§ j ‚â§ N || error(BoundsError(H, (i, j)))
    tmp = BlockArrays.findblockindex(H.axis, i)
    block_i = only(tmp.I)
    local_i = only(tmp.Œ±)
    tmp = BlockArrays.findblockindex(H.axis, j)
    block_j = only(tmp.I)
    local_j = only(tmp.Œ±)
    if H.block_ij == (block_i, block_j)
        return _getindex(H.block, local_i, local_j)
    elseif H.block_ij == (block_j, block_i) # hermicity-related block
        return _getindex(
            H.block,
            local_j,
            local_i;
            conjugate = true,
            antihermitian = H.hermiticity == ANTIHERMITIAN,
        )
    else # not a stored block
        return TightBindingElementString("0", false) #=active=#
    end
end

function _getindex(
    tbb::TightBindingBlock,
    i::Int,
    j::Int;
    conjugate::Bool = false,
    antihermitian::Bool = false,
)
    if antihermitian && !conjugate
        error("input has `antihermitian = true` but `conjugate = false`; not intended?")
    end
    @boundscheck 1 ‚â§ i ‚â§ size(tbb.Mm, 3) && 1 ‚â§ j ‚â§ size(tbb.Mm, 4) ||
                 error(BoundsError(tbb, (i, j)))

    io = IOBuffer()
    Mm = tbb.Mm
    N = size(Mm, 2) # half the length of the re/im-doubled `t[i]`
    M‚Å± ≤ = Mm[:, :, i, j]
    M‚Å± ≤t_re = M‚Å± ≤ * @view tbb.t[1:N]     # symmetry related Hamiltonian terms
    M‚Å± ≤t_im = M‚Å± ≤ * @view tbb.t[N+1:end]
    if !(
        any(v -> abs(v) > SPARSIFICATION_ATOL_DEFAULT, M‚Å± ≤t_re) ||
        any(v -> abs(v) > SPARSIFICATION_ATOL_DEFAULT, M‚Å± ≤t_im)
    )
        return TightBindingElementString("0", true) #=active=#
    end

    first = true
    for (n, (v·¥ø, v·¥µ)) in enumerate(zip(M‚Å± ≤t_re, M‚Å± ≤t_im))
        abs(complex(v·¥ø, v·¥µ)) < SPARSIFICATION_ATOL_DEFAULT && continue
        if conjugate
            v·¥µ = -v·¥µ # complex conjugate
            antihermitian && (v·¥ø = -v·¥ø; v·¥µ = -v·¥µ) # additional sign-flip from anti-hermiticity
        end

        v·¥ø‚Ä≤, v·¥ø_str = _stringify_real(v·¥ø)
        v·¥µ‚Ä≤, v·¥µ_str = _stringify_real(v·¥µ)
        if v·¥µ‚Ä≤ == 0     # strictly real
            v_str = isone(abs(v·¥ø‚Ä≤)) ? "" : lstrip(v·¥ø_str, ('-', '+'))
            v_str = (v·¥ø‚Ä≤ < 0 ? "-" : (first ? "" : "+")) * v_str
        elseif v·¥ø‚Ä≤ == 0 # strictly imaginary
            v_str = isone(abs(v·¥µ‚Ä≤)) ? "" : lstrip(v·¥µ_str, ('-', '+'))
            v_str = (v·¥µ‚Ä≤ < 0 ? "-" : (first ? "" : "+")) * v_str * "i"
        else            # complex
            v_str =
                (first ? "" : " + ") *
                "(" *
                _complex_as_compact_string(complex(v·¥ø‚Ä≤, v·¥µ‚Ä≤)) *
                ")"
        end
        print(io, v_str)

        Œ¥ = tbb.h_orbit.orbit[n]
        if !iszero(Œ¥) # print the exponential: our notation is ùïñ(Œ¥) ‚â° exp(2œÄiùê§‚ãÖŒ¥)
            print(io, "ùïñ(")
            # TODO: could do a little better here, since we know that `-Œ¥` is in the orbit?
            conjugate && print(io, "-")
            print(io, "Œ¥", Crystalline.subscriptify(string(n)), ")")
        else
            print(io, "1")
        end

        first = false
    end

    s = String(take!(io))
    return TightBindingElementString(s, true) #=active=#
end

function Base.getindex(tbb::TightBindingBlock, i::Int, j::Int)
    return _getindex(tbb, i, j; conjugate = false, antihermitian = false)
end

Base.setindex!(::TightBindingBlock, v, ij...) = error("setindex! is not supported")

# pretty-printing of scalars

function _stringify_real(c::Real; digits::Int = 3)
    c‚Ä≤ = round(c; digits)
    isinteger(c‚Ä≤) && return c‚Ä≤, string(Int(c‚Ä≤))
    return c‚Ä≤, string(c‚Ä≤)
end

function _complex_as_compact_string(c::Complex) # usual string(::Complex) has spaces; 
    # avoid that
    io = IOBuffer()
    print(io, real(c), Crystalline.signaschar(imag(c)), abs(imag(c)), "i")
    return String(take!(io))
end

# ---------------------------------------------------------------------------------------- #

"""
  TightBindingModel{D}

A structure storing a list of `TightBindingTerm{D}`s. Each term is assumed to associated
with an identical list of EBRs.

To associate a set of coefficients to each term, see
[`ParameterizedTightBindingModel`](@ref), which also allows evaluation at specific momenta.

## Fields

- `terms :: Vector{TightBindingTerm{D}}`: a vector of `TightBindingTerm{D}`s, each of which
  represents a block (or conjugated pairs of blocks) of the Hamiltonian matrix.
- `cbr :: CompositeBandRep{D}`: the composite band representation associated to the model.
- `positions :: Vector{DirectPoint{D}}`: a vector of positions, specified in the lattice
  basis, associated to each orbital of the model.
- `N :: Int`: the total number of orbitals in the model, i.e., the size of the Hamiltonian
  matrix associated to each element of `terms`.
"""
struct TightBindingModel{D} <: AbstractVector{TightBindingTerm{D}}
    terms::Vector{TightBindingTerm{D}}
    cbr::CompositeBandRep{D} # band representation associated to the model
    positions::Vector{DirectPoint{D}} # positions associated to each orbital
    N::Int # total number of orbitals, i.e., matrix size
end
Base.size(tbm::TightBindingModel) = (length(tbm.terms),)
Base.getindex(tbm::TightBindingModel, i::Int) = tbm.terms[i]
Base.setindex!(::TightBindingModel, v, i::Int) = error("setindex! is not supported")
Base.IndexStyle(::Type{TightBindingModel}) = IndexLinear()
orbital_positions(tbm::TightBindingModel) = tbm.positions
Crystalline.CompositeBandRep(tbm::TightBindingModel) = tbm.cbr

function TightBindingModel(
    terms::Vector{TightBindingTerm{D}},
    cbr::CompositeBandRep{D},
) where {D}
    length(terms) == 0 && return TightBindingModel{D}(terms, 0)
    positions = orbital_positions(cbr)
    N = last(first(terms).axis)
    return TightBindingModel{D}(terms, cbr, positions, N)
end
function (tbm::TightBindingModel{D})(cs::Vector{Float64}) where {D}
    return ParameterizedTightBindingModel(tbm, cs)
end

"""
  ParameterizedTightBindingModel{D}

A coefficient-parameterized tight-binding model, that can be used as a functor for
evaluation at input momenta `k`.

## Fields

- `tbm :: TightBindingModel{D}`: A tight-binding model, consisting of a set of a list of
  `TightBindingTerm{D}`s.
- `cs :: Vector{Float64}`: A vector of coefficients, each associated to a corresponding
  element of `tbm`.
- `scratch :: Matrix{ComplexF64}`: A scratch space for evaluating the Hamiltonian matrix at
  at specific momenta. This is a `N√óN` matrix, where `N` is the number of orbitals in `tbm`
  (i.e., `tbm.N`). The scratch space is instantiated automatically on construction.

## Functor over momenta

A `ParameterizedTightBindingModel` `ptbm` can be be evaluated at any ¬¥D`-dimensional
momentum `k` by using `ptbm` as a functor. That is, `ptbm(k)` returns a numerical
representation of the Hamiltonian matrix for `ptbm` evaluated at momentum `k`.`
"""
struct ParameterizedTightBindingModel{D}
    tbm::TightBindingModel{D}
    cs::Vector{Float64} # coefficients of the tight-binding model
    scratch::Matrix{ComplexF64} # scratch space for evaluation
end
orbital_positions(ptbm::ParameterizedTightBindingModel) = ptbm.tbm.positions
Crystalline.CompositeBandRep(ptbm::ParameterizedTightBindingModel) = ptbm.tbm.cbr

function ParameterizedTightBindingModel(
    tbm::TightBindingModel{D},
    cs::Vector{Float64},
) where {D}
    ParameterizedTightBindingModel{D}(tbm, cs, Matrix{ComplexF64}(undef, tbm.N, tbm.N))
end

function (ptbm::ParameterizedTightBindingModel{D})(
    k::Union{AbstractVector{<:Real}, NTuple{D, <:Real}, ReciprocalPoint{D}},
    scratch::Matrix{ComplexF64} = ptbm.scratch,
) where {D}
    if length(k) ‚â† D
        error("momentum `k` must be a $D-dimensional vector to match the model dimension")
    end
    if size(scratch) ‚â† (ptbm.tbm.N, ptbm.tbm.N)
        error(DimensionMismatch("scratch size ($ssize) does not match model size ($N, $N)"))
    end
    tbm = ptbm.tbm
    H = scratch # grab & reset scratch space for evaluating Hamiltonian matrix
    fill!(H, 0.0)

    # evaluate each block of the Hamiltonian terms, multiply by coefficients, & store in `H`
    for (tbt, c) in zip(tbm.terms, ptbm.cs)
        block = tbt.block
        block_i, block_j = tbt.block_ij
        is = tbt.axis[Block(block_i)] # global row indices
        js = tbt.axis[Block(block_j)] # global col indices
        t = block.t
        N·µó = length(t) √∑ 2
        t‚ÑÇ = ComplexF64.((@view t[1:N·µó]), (@view t[N·µó+1:end])) # complex coefficient vector
        Mm = block.Mm

        # NB: ‚Üì one more case of assuming no free parameters in `Œ¥`
        v = cispi.(dot.(Ref(2k), constant.(orbit(block.h_orbit))))
        M_t‚ÑÇ = Vector{ComplexF64}(undef, size(Mm, 1))
        for (local_i, i) in enumerate(is)
            for (local_j, j) in enumerate(js)
                mul!(M_t‚ÑÇ, (@view Mm[:, :, local_i, local_j]), t‚ÑÇ) # M_t‚ÑÇ = M[:,:,i,j] * t‚ÑÇ
                H·µ¢‚±º = c * dot(v, M_t‚ÑÇ)
                H[i, j] += H·µ¢‚±º
                H[j, i] += tbt.hermiticity == ANTIHERMITIAN ? -conj(H·µ¢‚±º) : conj(H·µ¢‚±º)
            end
        end
    end

    return H
end

function solve(
    ptbm::ParameterizedTightBindingModel{D},
    k::Union{KVec{D}, AbstractVector{<:Real}};
    bloch_phase::Union{Val{true}, Val{false}} = Val(true),
    eigen_kws...,
) where D
    length(k) == D || error("dimension mismatch")
    if ptbm.tbm.terms[1].hermiticity == ANTIHERMITIAN
        error("ANTIHERMITIAN model solve not implemented") # TODO: cf. `Hermitian` use below
    end

    es, vs = eigen(Hermitian(ptbm(k)), eigen_kws...)
    if bloch_phase === Val(true)
        _k = k isa KVec ? constant(k) : k
        phases = cispi.(2 .* dot.(Ref(_k), orbital_positions(ptbm))) # e^{ik¬∑r}
        vs = Diagonal(phases) * vs # add Bloch phases
        return es, vs
    else
        return es, vs
    end
end
