"""
    TightBindingCandidateSet

A structure for storing information about a set of tight-binding candidates for the photonic
crystal.
"""
struct TightBindingCandidateSet <: AbstractVector{CompositeBandRep{3}}
  longitudinal::CompositeBandRep{3}    # `n·¥∏`
  apolarv::Vector{CompositeBandRep{3}} # `n·µÄ‚Å∫·¥∏[i]` over `i ‚àà eachindex(apolarv)`
  ps::Vector{Vector{Float64}}          # `ps[i]` associates to `n·µÄ‚Å∫·¥∏[i]`; w/ n·µÄ(œâ=0) = n_fixed + Q*p
end
Base.size(tbc::TightBindingCandidateSet) = (length(tbc.apolarv),)
longitudinal(tbc::TightBindingCandidateSet) = tbc.longitudinal
Base.getindex(tbc::TightBindingCandidateSet, i::Int) = tbc.apolarv[i]
Base.setindex!(::TightBindingCandidateSet, v, i::Int) = error("setindex! is not supported")

"""
    HoppingOrbit{D}

A structure holding information about symmetry-related spatial hopping vectors.

An orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the
symmetry operations of the underlying space group to a representative vector Œ¥.

For each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site `a` to site
`b`, possibly related by a lattice translation `R`. Each such set of possible hopping term
`(a, b, R)` is for each `Œ¥·µ¢` is stored elements as the `i`th element of the vector
`hoppings`.

## Fields
- `representative :: RVec{D}`: the representative hopping vector Œ¥
- `orbit :: Vector{RVec{D}}`: the Œ¥·µ¢ elements of the orbit generated by Œ¥.
  Generally `orbit[1] == representative`, i.e., `Œ¥‚ÇÅ = Œ¥`
- `hoppings :: Vector{Vector{NTuple{3,RVec{D}}}}`: the `i`th element gives the possible
  physical hopping terms `(a,b,R)` associated to `orbit[i]`. Multiple physical hopping terms
  may correspond to each element of the orbit. 
  For `(a, b, R) = hoppings[i][j]`, we have `orbit[i] = Œ¥·µ¢ = b + R - a`
"""
struct HoppingOrbit{D}
  representative::RVec{D} # representative hopping vector Œ¥
  orbit::Vector{RVec{D}}  # orbit of the hopping vector {Œ¥·µ¢ ‚Ä¶}
  hoppings::Vector{Vector{NTuple{3,RVec{D}}}} # `[(a,b,R), ...]` for every `orbit[i]`
end
representative(s::HoppingOrbit) = s.representative
Crystalline.orbit(s::HoppingOrbit) = s.orbit # extend to avoid clash w/ Crystalline's `orbit`



# ---------------------------------------------------------------------------------------- #
# constructor defined in /src/tightbinding.jl

struct OrbitalOrdering{D} <: AbstractVector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
  ordering :: Vector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
end
Base.getindex(o::OrbitalOrdering, i::Int) = o.ordering[i]
Base.size(o::OrbitalOrdering) = size(o.ordering)
Base.setindex!(::OrbitalOrdering, v, i::Int) = error("setindex! is not supported")
Base.IndexStyle(::Type{OrbitalOrdering}) = IndexLinear()
Base.iterate(o::OrbitalOrdering) = iterate(o.ordering)
Base.iterate(o::OrbitalOrdering, i) = iterate(o.ordering, i)

# ---------------------------------------------------------------------------------------- #

"""
    TightBindingElementString

A structure for pretty-printing tight-binding matrix elements.

## Fields
- `s :: String`: the string representing the tight-binding matrix element
- `active :: Bool`: whether the element belongs to an "active" block - i.e., one we want to
  highlight (then shown in blue).
"""
struct TightBindingElementString
  s::String
  active::Bool
end
function Base.show(io::IO, tbe_str::TightBindingElementString)
  s = tbe_str.s
  color = (tbe_str.active ? (s == "0" ? :normal : :blue) 
                          : (s == "0" ? :light_black : :normal))
  printstyled(io, s; color)
end

"""
    TightBindingBlock{D}

A structure for storing information about a matrix block of a tight-binding Hamiltonian.

A block will represent a hopping terms between two band representations `br1` and `br2`. 
For this hopping we store:

## Fields
- `br1 :: NewBandRep{D}`: first band representation
- `br2 :: NewBandRep{D}`: second band representation
- `ordering1 :: OrbitalOrdering{D}`: ordering of the orbitals in `br1`
- `ordering2 :: OrbitalOrdering{D}`: ordering of the orbitals in `br2`
- `h_orbit :: Union{Nothing,HoppingOrbit{D}}`: hopping orbit associated to the block
- `Mm :: Array{Int,4}`: matrix codifying Hamiltonian
- `t :: Vector{Float64}}`: a basis vector, stored in re/im-doubled format
"""

struct TightBindingBlock{D} <: AbstractMatrix{TightBindingElementString}
  br1::NewBandRep{D}
  br2::NewBandRep{D}
  ordering1::OrbitalOrdering{D}
  ordering2::OrbitalOrdering{D}
  h_orbit::HoppingOrbit{D}
  Mm::Array{Int,4}
  t::Vector{Float64}
end
Base.size(tbb :: TightBindingBlock) = (size(tbb.Mm, 3), size(tbb.Mm, 4))

@enum Hermiticity::UInt8 begin
  HERMITIAN
  ANTIHERMITIAN
end

struct TightBindingTerm{D} <: AbstractBlockMatrix{TightBindingElementString}
  axis :: BlockedOneTo{Int, Vector{Int}}
  block_ij :: NTuple{2, Int}
  block :: TightBindingBlock{D}
  hermiticity :: Hermiticity
  brs :: Vector{NewBandRep{D}}
end

Base.axes(H::TightBindingTerm) = (H.axis, H.axis)
Base.axes(H::TightBindingTerm, d::Int) = d > 2 ? Base.BlockedOneTo([1,]) : d > 0 ? H.axis : error("dimensionality must be greater than 1")
Base.size(H::TightBindingTerm) = (N = last(H.axis); (N, N))

function Base.getindex(H::TightBindingTerm, i::Int, j::Int)
  N = size(H, 1)
  @boundscheck 1‚â§i‚â§N && 1‚â§j‚â§N || error(BoundsError(H, (i, j)))
  tmp = BlockArrays.findblockindex(H.axis, i); block_i = only(tmp.I); local_i = only(tmp.Œ±)
  tmp = BlockArrays.findblockindex(H.axis, j); block_j = only(tmp.I); local_j = only(tmp.Œ±)
  if H.block_ij == (block_i, block_j)
    return _getindex(H.block, local_i, local_j)
  elseif H.block_ij == (block_j, block_i) # hermicity-related block
    return _getindex(H.block, local_j, local_i; 
                     conjugate=true,
                     antihermitian=H.hermiticity == ANTIHERMITIAN)
  else # not a stored block
    return TightBindingElementString("0", #=active=# false)
  end
end

function _getindex(
  tbb::TightBindingBlock, i::Int, j::Int;
  conjugate::Bool=false, antihermitian::Bool=false
)
  if antihermitian && !conjugate
    error("input has `antihermitian = true` but `conjugate = false`; not intended?")
  end
  @boundscheck 1‚â§i‚â§size(tbb.Mm, 3) && 1‚â§j‚â§size(tbb.Mm, 4) || error(BoundsError(tbb, (i, j)))

  io = IOBuffer()
  Mm = tbb.Mm
  N = size(Mm, 2) # half the length of the re/im-doubled `t[i]`
  M‚Å± ≤ = Mm[:, :, i, j] 
  M‚Å± ≤t_re = M‚Å± ≤ * @view tbb.t[1:N]     # symmetry related Hamiltonian terms
  M‚Å± ≤t_im = M‚Å± ≤ * @view tbb.t[N+1:end]
  if !(any(v -> abs(v) > SPARSIFICATION_ATOL_DEFAULT, M‚Å± ≤t_re) || 
       any(v -> abs(v) > SPARSIFICATION_ATOL_DEFAULT, M‚Å± ≤t_im))
    return TightBindingElementString("0", #=active=# true)
  end
  
  first = true
  for (n, (v·¥ø, v·¥µ) ) in enumerate(zip(M‚Å± ≤t_re, M‚Å± ≤t_im))
    abs(complex(v·¥ø,v·¥µ)) < SPARSIFICATION_ATOL_DEFAULT && continue
    if conjugate
      v·¥µ = -v·¥µ # complex conjugate
      antihermitian && (v·¥ø = -v·¥ø; v·¥µ = -v·¥µ) # additional sign-flip from anti-hermiticity
    end

    v·¥ø‚Ä≤, v·¥ø_str = _stringify_real(v·¥ø)
    v·¥µ‚Ä≤, v·¥µ_str = _stringify_real(v·¥µ)
    if v·¥µ‚Ä≤ == 0     # strictly real
      v_str = isone(abs(v·¥ø‚Ä≤)) ? "" : lstrip(v·¥ø_str, ('-', '+'))
      v_str = (v·¥ø‚Ä≤ < 0 ? "-" : (first ? "" : "+")) * v_str
    elseif v·¥ø‚Ä≤ == 0 # strictly imaginary
      v_str = isone(abs(v·¥µ‚Ä≤)) ? "" : lstrip(v·¥µ_str, ('-', '+'))
      v_str = (v·¥µ‚Ä≤ < 0 ? "-" : (first ? "" : "+")) * v_str * "i"
    else            # complex
      v_str = (first ? "" : " + ") * "(" * _complex_as_compact_string(complex(v·¥ø‚Ä≤, v·¥µ‚Ä≤)) * ")"
    end
    print(io, v_str)

    Œ¥ = tbb.h_orbit.orbit[n]
    if !iszero(Œ¥) # print the exponential: our notation is ùïñ(Œ¥) ‚â° exp(2œÄiùê§‚ãÖŒ¥)
      print(io, "ùïñ(")
      # TODO: could do a little better here, since we know that `-Œ¥` is in the orbit?
      conjugate && print(io, "-")
      print(io, "Œ¥", Crystalline.subscriptify(string(n)), ")")
    else
      print(io, "1")
    end

    first = false
  end

  s = String(take!(io))
  return TightBindingElementString(s, #=active=# true)
end

function Base.getindex(tbb::TightBindingBlock, i::Int, j::Int)
  return _getindex(tbb, i, j; conjugate=false, antihermitian=false)
end

Base.setindex!(::TightBindingBlock, v, ij...) = error("setindex! is not supported")



# pretty-printing of scalars

function _stringify_real(c::Real; digits::Int=3)
  c‚Ä≤ = round(c; digits)
  isinteger(c‚Ä≤) && return c‚Ä≤, string(Int(c‚Ä≤))
  return c‚Ä≤, string(c‚Ä≤)
end

function _complex_as_compact_string(c::Complex) # usual string(::Complex) has spaces; 
  # avoid that
  io = IOBuffer()
  print(io, real(c), Crystalline.signaschar(imag(c)), abs(imag(c)), "i")
  return String(take!(io))
end


# ---------------------------------------------------------------------------------------- #

struct TightBindingModel{D} <: AbstractVector{TightBindingTerm{D}}
  terms :: Vector{TightBindingTerm{D}}
  N :: Int # total number of orbitals, i.e., matrix size
end
Base.size(tbm::TightBindingModel) = (length(tbm.terms),)
Base.getindex(tbm::TightBindingModel, i::Int) = tbm.terms[i]
Base.setindex!(::TightBindingModel, v, i::Int) = error("setindex! is not supported")
Base.IndexStyle(::Type{TightBindingModel}) = IndexLinear()

function TightBindingModel(terms::Vector{TightBindingTerm{D}}) where D
  length(terms) == 0 && return TightBindingModel{D}(terms, 0)
  N = last(first(terms).axis)
  return TightBindingModel{D}(terms, N)
end
function (tbm::TightBindingModel{D})(cs::Vector{Float64}) where D
  return ParameterizedTightBindingModel(tbm, cs)
end

struct ParameterizedTightBindingModel{D}
  tbm :: TightBindingModel{D}
  cs :: Vector{Float64} # coefficients of the tight-binding model
  scratch :: Matrix{ComplexF64} # scratch space for evaluation
end

function ParameterizedTightBindingModel(tbm::TightBindingModel{D}, cs::Vector{Float64}) where D
  ParameterizedTightBindingModel{D}(tbm, cs, Matrix{ComplexF64}(undef, tbm.N, tbm.N))
end

function (ptbm::ParameterizedTightBindingModel{D})(
  k :: Union{AbstractVector{<:Real}, NTuple{D, <:Real}, ReciprocalPoint{D}}
) where {D}
  if length(k) ‚â† D
    error("the momentum `k` must be a $D-dimensional vector to match the model dimension")
  end

  tbm = ptbm.tbm
  H = ptbm.scratch # grab & reset scratch space for evaluating Hamiltonian matrix
  fill!(H, 0.0)

  # evaluate each block of the `Hamiltonian` terms, multiply by coefficients, & store in `H`
  for (tbt, c) in zip(tbm.terms, ptbm.cs)
    block = tbt.block
    block_i, block_j = tbt.block_ij
    is = tbt.axis[Block(block_i)] # global row indices
    js = tbt.axis[Block(block_j)] # global col indices
    t = block.t
    N·µó = length(t)√∑2
    t‚ÑÇ = ComplexF64.((@view t[1:N·µó]), (@view t[N·µó+1:end])) # complex coefficient vector
    Mm = block.Mm
    v = cispi.(2 * dot.(Ref(k), constant.(orbit(block.h_orbit)))) # NB: one more case of assuming no free parameters in `Œ¥`
    for (local_i, i) in enumerate(is)
      for (local_j, j) in enumerate(js)
        H·µ¢‚±º = c * transpose(v) * (@view Mm[:, :, local_i, local_j]) * t‚ÑÇ
        H[i, j] += H·µ¢‚±º
        H[j, i] += tbt.hermiticity == ANTIHERMITIAN ? -conj(H·µ¢‚±º) : conj(H·µ¢‚±º)
      end
    end
  end
  
  return H
end
