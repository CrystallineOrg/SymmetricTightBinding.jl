"""
    TightBindingCandidateSet

A structure for storing information about a set of tight-binding candidates for the photonic
crystal.
"""
struct TightBindingCandidateSet <: AbstractVector{CompositeBandRep{3}}
  longitudinal::CompositeBandRep{3}    # `n·¥∏`
  apolarv::Vector{CompositeBandRep{3}} # `n·µÄ‚Å∫·¥∏[i]` over `i ‚àà eachindex(apolarv)`
  ps::Vector{Vector{Float64}}          # `ps[i]` associates to `n·µÄ‚Å∫·¥∏[i]`; w/ n·µÄ(œâ=0) = n_fixed + Q*p
end
Base.size(tbc::TightBindingCandidateSet) = (length(tbc.apolarv),)
longitudinal(tbc::TightBindingCandidateSet) = tbc.longitudinal
Base.getindex(tbc::TightBindingCandidateSet, i::Int) = tbc.apolarv[i]
Base.setindex!(::TightBindingCandidateSet, v, i::Int) = error("setindex! is not supported")

"""
    HoppingOrbit{D}

A structure holding information about symmetry-related spatial hopping vectors.

An orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the
symmetry operations of the underlying space group to a representative vector Œ¥.

For each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site `a` to site
`b`, possibly related by a lattice translation `R`. Each such set of possible hopping term
`(a, b, R)` is for each `Œ¥·µ¢` is stored elements as the `i`th element of the vector
`hoppings`.

## Fields
- `representative :: RVec{D}`: the representative hopping vector Œ¥
- `orbit :: Vector{RVec{D}}`: the Œ¥·µ¢ elements of the orbit generated by Œ¥.
  Generally `orbit[1] == representative`, i.e., `Œ¥‚ÇÅ = Œ¥`
- `hoppings :: Vector{Vector{NTuple{3,RVec{D}}}}`: the `i`th element gives the possible
  physical hopping terms `(a,b,R)` associated to `orbit[i]`. Multiple physical hopping terms
  may correspond to each element of the orbit. 
  For `(a, b, R) = hoppings[i][j]`, we have `orbit[i] = Œ¥·µ¢ = b + R - a`
"""
struct HoppingOrbit{D}
  representative::RVec{D} # representative hopping vector Œ¥
  orbit::Vector{RVec{D}}  # orbit of the hopping vector {Œ¥·µ¢ ‚Ä¶}
  hoppings::Vector{Vector{NTuple{3,RVec{D}}}} # `[(a,b,R), ...]` for every `orbit[i]`
end
representative(s::HoppingOrbit) = s.representative
Crystalline.orbit(s::HoppingOrbit) = s.orbit # extend to avoid clash w/ Crystalline's `orbit`



# ---------------------------------------------------------------------------------------- #
# constructor defined in /src/tightbinding.jl

struct OrbitalOrdering{D} <: AbstractVector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
  ordering :: Vector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
end
Base.getindex(o::OrbitalOrdering, i::Int) = o.ordering[i]
Base.size(o::OrbitalOrdering) = size(o.ordering)
Base.setindex!(::OrbitalOrdering, v, i::Int) = error("setindex! is not supported")
Base.IndexStyle(::Type{OrbitalOrdering}) = IndexLinear()
Base.iterate(o::OrbitalOrdering) = iterate(o.ordering)
Base.iterate(o::OrbitalOrdering, i) = iterate(o.ordering, i)

# ---------------------------------------------------------------------------------------- #

"""
    TightBindingElementString

A structure for pretty-printing tight-binding matrix elements.

## Fields
- `s :: String`: the string representing the tight-binding matrix element
"""
struct TightBindingElementString
  s::String
end
function Base.show(io::IO, tbe_str::TightBindingElementString)
  if tbe_str.s == "0"
    # TODO: change to `printstyled(io, "0"; color=:light_black)` if/when
    #       https://github.com/JuliaArrays/BlockArrays.jl/pull/443 is merged    
    print(io, "0")
  else
    print(io, tbe_str.s)
  end
end

"""
    TightBindingBlock{D}

A structure for storing information about a matrix block of a tight-binding Hamiltonian.

A block will represent a hopping terms between two band representations `br1` and `br2`. 
For this hopping we store:

## Fields
- `br1 :: NewBandRep{D}`: first band representation
- `br2 :: NewBandRep{D}`: second band representation
- `ordering1 :: OrbitalOrdering{D}`: ordering of the orbitals in `br1`
- `ordering2 :: OrbitalOrdering{D}`: ordering of the orbitals in `br2`
- `h_orbit :: Union{Nothing,HoppingOrbit{D}}`: hopping orbit associated to the block
- `Mm :: Array{Int,4}`: matrix codifying Hamiltonian
- `t :: Vector{Float64}}`: a basis vector, stored in re/im-doubled format
"""

struct TightBindingBlock{D} <: AbstractMatrix{TightBindingElementString}
  br1::NewBandRep{D}
  br2::NewBandRep{D}
  ordering1::OrbitalOrdering{D}
  ordering2::OrbitalOrdering{D}
  h_orbit::HoppingOrbit{D}
  Mm::Array{Int,4}
  t::Vector{Float64}
end
Base.size(tbb :: TightBindingBlock) = (size(tbb.Mm, 3), size(tbb.Mm, 4))

@enum Hermiticity::UInt8 begin
  HERMITIAN
  ANTIHERMITIAN
end

struct TightBindingMatrix{D} <: AbstractBlockMatrix{TightBindingElementString}
  axis :: BlockedOneTo{Int, Vector{Int}}
  block_ij :: NTuple{2, Int}
  block :: TightBindingBlock{D}
  hermiticity :: Hermiticity
end

Base.axes(H::TightBindingMatrix) = (H.axis, H.axis)
Base.axes(H::TightBindingMatrix, d::Int) = d > 2 ? Base.BlockedOneTo([1,]) : d > 0 ? H.axis : error("dimensionality must be greater than 1")
Base.size(H::TightBindingMatrix) = (N = last(H.axis); (N, N))

function Base.getindex(H::TightBindingMatrix, i::Int, j::Int)
  N = size(H, 1)
  @boundscheck 1‚â§i‚â§N && 1‚â§j‚â§N || error(BoundsError(H, (i, j)))
  tmp = BlockArrays.findblockindex(H.axis, i); block_i = only(tmp.I); local_i = only(tmp.Œ±)
  tmp = BlockArrays.findblockindex(H.axis, j); block_j = only(tmp.I); local_j = only(tmp.Œ±)
  if H.block_ij == (block_i, block_j)
    return _getindex(H.block, local_i, local_j)
  elseif H.block_ij == (block_j, block_i) # hermicity-related block
    return _getindex(H.block, local_j, local_i; 
                     conjugate=true,
                     antihermitian=H.hermiticity == ANTIHERMITIAN)
  else # not a stored block
    return TightBindingElementString("\e[39m0\e[39m") # a gray zero
  end
end

function _getindex(
  tbb::TightBindingBlock, i::Int, j::Int;
  conjugate::Bool=false, antihermitian::Bool=false
)
  if antihermitian && !conjugate
    error("input has `antihermitian = true` but `conjugate = false`; not intended?")
  end
  @boundscheck 1‚â§i‚â§size(tbb.Mm, 3) && 1‚â§j‚â§size(tbb.Mm, 4) || error(BoundsError(tbb, (i, j)))

  io = IOBuffer()
  Mm = tbb.Mm
  N = size(Mm, 2) # half the length of the re/im-doubled `t[i]`
  M‚Å± ≤ = Mm[:, :, i, j] 
  M‚Å± ≤t_re = M‚Å± ≤ * @view tbb.t[1:N]     # symmetry related Hamiltonian terms
  M‚Å± ≤t_im = M‚Å± ≤ * @view tbb.t[N+1:end]
  if !(any(v -> abs(v) > SPARSIFICATION_ATOL_DEFAULT, M‚Å± ≤t_re) || 
       any(v -> abs(v) > SPARSIFICATION_ATOL_DEFAULT, M‚Å± ≤t_im))
    return TightBindingElementString("0")
  end
  
  first = true
  for (n, (v·¥ø, v·¥µ) ) in enumerate(zip(M‚Å± ≤t_re, M‚Å± ≤t_im))
    abs(complex(v·¥ø,v·¥µ)) < SPARSIFICATION_ATOL_DEFAULT && continue
    if conjugate
      v·¥µ = -v·¥µ # complex conjugate
      antihermitian && (v·¥ø = -v·¥ø; v·¥µ = -v·¥µ) # additional sign-flip from anti-hermiticity
    end

    v·¥ø‚Ä≤, v·¥ø_str = _stringify_real(v·¥ø)
    v·¥µ‚Ä≤, v·¥µ_str = _stringify_real(v·¥µ)
    if v·¥µ‚Ä≤ == 0     # strictly real
      v_str = isone(abs(v·¥ø‚Ä≤)) ? "" : lstrip(v·¥ø_str, ('-', '+'))
      v_str = (v·¥ø‚Ä≤ < 0 ? "-" : (first ? "" : "+")) * v_str
    elseif v·¥ø‚Ä≤ == 0 # strictly imaginary
      v_str = isone(abs(v·¥µ‚Ä≤)) ? "" : lstrip(v·¥µ_str, ('-', '+'))
      v_str = (v·¥µ‚Ä≤ < 0 ? "-" : (first ? "" : "+")) * v_str * "i"
    else            # complex
      v_str = (first ? "" : " + ") * "(" * _complex_as_compact_string(complex(v·¥ø‚Ä≤, v·¥µ‚Ä≤)) * ")"
    end
    print(io, v_str)

    Œ¥ = tbb.h_orbit.orbit[n]
    if !iszero(Œ¥) # print the exponential
      print(io, "ùïñ(")
      # TODO: could do a little better here, since we know that `-Œ¥` is in the orbit?
      conjugate && print(io, "-")
      print(io, "k‚ãÖŒ¥", Crystalline.subscriptify(string(n)), ")")
    else
      print(io, "1")
    end

    first = false
  end

  s = String(take!(io))
  return TightBindingElementString(s)
end

function Base.getindex(tbb::TightBindingBlock, i::Int, j::Int)
  return _getindex(tbb, i, j; conjugate=false, antihermitian=false)
end

Base.setindex!(::TightBindingBlock, v, ij...) = error("setindex! is not supported")

# pretty-printing of scalars

function _stringify_real(c::Real; digits::Int=3)
  c‚Ä≤ = round(c; digits)
  isinteger(c‚Ä≤) && return c‚Ä≤, string(Int(c‚Ä≤))
  return c‚Ä≤, string(c‚Ä≤)
end

function _complex_as_compact_string(c::Complex) # usual string(::Complex) has spaces; 
  # avoid that
  io = IOBuffer()
  print(io, real(c), Crystalline.signaschar(imag(c)), abs(imag(c)), "i")
  return String(take!(io))
end
