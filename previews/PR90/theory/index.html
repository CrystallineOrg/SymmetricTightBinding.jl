<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory ¬∑ SymmetricTightBinding.jl</title><meta name="title" content="Theory ¬∑ SymmetricTightBinding.jl"/><meta property="og:title" content="Theory ¬∑ SymmetricTightBinding.jl"/><meta property="twitter:title" content="Theory ¬∑ SymmetricTightBinding.jl"/><meta name="description" content="Documentation for SymmetricTightBinding.jl."/><meta property="og:description" content="Documentation for SymmetricTightBinding.jl."/><meta property="twitter:description" content="Documentation for SymmetricTightBinding.jl."/><meta property="og:url" content="https://CrystallineOrg.github.io/SymmetricTightBinding.jl/theory/"/><meta property="twitter:url" content="https://CrystallineOrg.github.io/SymmetricTightBinding.jl/theory/"/><link rel="canonical" href="https://CrystallineOrg.github.io/SymmetricTightBinding.jl/theory/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymmetricTightBinding.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../band-symmetry/">Band symmetry</a></li><li><a class="tocitem" href="../symmetry-breaking/">Symmetry breaking</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../internal-api/">Internal API</a></li><li class="is-active"><a class="tocitem" href>Theory</a><ul class="internal"><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Transformation-properties-of-orbitals"><span>Transformation properties of orbitals</span></a></li><li><a class="tocitem" href="#Build-a-tight-binding-Hamiltonian-from-a-set-of-symmetric-orbitals"><span>Build a tight-binding Hamiltonian from a set of symmetric orbitals</span></a></li><li><a class="tocitem" href="#Implementing-Symbolic-Hamiltonians-in-Non-Symbolic-Environments"><span>Implementing Symbolic Hamiltonians in Non-Symbolic Environments</span></a></li><li><a class="tocitem" href="#Appendix-A"><span>Appendix A</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CrystallineOrg/SymmetricTightBinding.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CrystallineOrg/SymmetricTightBinding.jl/blob/main/docs/src/theory.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Theory-Notes"><a class="docs-heading-anchor" href="#Theory-Notes">Theory Notes</a><a id="Theory-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Theory-Notes" title="Permalink"></a></h1><p>This package heavily relies on <a href="https://en.wikipedia.org/wiki/Representation_theory_of_finite_groups">representation theory of groups</a> and on <a href="https://en.wikipedia.org/wiki/Electronic_band_structure">band theory</a> of crystals. Almost all of this theory was introduced before and can be found in <a href="https://academic.oup.com/book/54787">Bradley &amp; Cracknell</a> and later developed by <a href="https://www.nature.com/articles/nature23268">Bradlyn <em>et al.</em></a>. Here, we aim to provide a practical introduction to the main concepts and derive the essential functions and relations that we need for the implementation of this package. Additionally, we generalize some of the previously derived results and make them more accessible to the general public.</p><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="#theory-notes">Theory Notes</a><ul><li><a href="#table-of-contents">Table of contents</a></li><li><a href="#introduction">Introduction</a></li><li><a href="#transformation-properties-of-orbitals">Transformation properties of orbitals</a><ul><li><a href="#transformation-properties-of-induced-bloch-functions">Transformation properties of induced Bloch functions</a></li></ul></li><li><a href="#build-a-tight-binding-hamiltonian-from-a-set-of-symmetric-orbitals">Build a tight-binding Hamiltonian from a set of symmetric orbitals</a><ul><li><a href="#transformation-properties-of-the-bloch-states">Transformation properties of the Bloch states</a><ul><li><a href="#transformation-properties-under-lattice-translations">Transformation properties under lattice translations</a></li><li><a href="#transformation-properties-under-symmetry-operations">Transformation properties under symmetry operations</a></li></ul></li></ul></li><li><a href="#implementing-symbolic-hamiltonians-in-non-symbolic-environments">Implementing Symbolic Hamiltonians in Non-Symbolic Environments</a><ul><li><a href="#symmetry-constraints-in-the-numerical-matrix-ùêå">Symmetry constraints in the numerical matrix <span>$ùêå$</span></a></li></ul></li><li><a href="#appendix-a">Appendix A</a><ul><li><a href="#transformation-properties-within-convention-2">Transformation properties within Convention 2</a></li><li><a href="#bloch-hamiltonian-under-convention-2">Bloch Hamiltonian under Convention 2</a><ul><li><a href="#bloch-states-under-convention-2">Bloch states under Convention 2</a><ul><li><a href="#transformation-under-lattice-translations">Transformation under lattice translations</a></li><li><a href="#transformation-properties-under-symmetry-operations-1">Transformation properties under symmetry operations</a></li></ul></li></ul></li><li><a href="#conversions-between-convention-1-and-2">Conversions between Convention 1 and 2</a></li></ul></li></ul></li></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>The introduction of <a href="https://academic.oup.com/book/54787">Topological Quantum Chemistry</a> (TQC) established a link between trivial insulators and atomic limits. It states that if a set of isolated bands can be described by a set of isolated ‚Äî atomic-like ‚Äî orbitals, the set must be topologically trivial. This link is determined by first analyzing all band symmetries of these &quot;atomic-like&quot; orbitals. Then, the set of bands under study will be nontrivial if it does not fit into that list.</p><p>The analysis of the band symmetries of the isolated orbitals can be performed by placing localized, symmetric orbitals at some high-symmetry points <span>$ùê™_Œ±$</span> ‚Äî <a href="https://en.wikipedia.org/wiki/Wyckoff_positions">Wyckoff positions</a> ‚Äî with some internal symmetry ‚Äî corresponding to a particular site-symmetry irrep <span>$œÅ$</span>. Those orbitals can be labeled as <span>$œï_{Œ±i}(ùê´)$</span>, where <span>$i$</span> runs over the dimension of the irrep <span>$œÅ$</span>, or just by <span>$(ùê™_Œ±|œÅ)$</span>. By applying the Fourier transform, the induced Bloch functions can be obtained as:</p><p class="math-container">\[œÜ_{Œ±i,ùê§}(ùê´) = \sum_ùê≠ e^{iùê§¬∑ùê≠} œï_{Œ±i}(ùê´-ùê≠)\]</p><p>How <span>$œÜ_{Œ±iùê§}(ùê´)$</span> transforms under symmetries will define a <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.23.2824">band representation</a>.</p><p>The idea behind this package is to use these orbitals to build a tight-binding model that respects the symmetries and topology of the (trivial) set of bands whose band representation is matched by such a set of orbitals.</p><p>To do so, it is necessary to access all possible types of symmetry-independent orbitals and high-symmetry points in every space group. Luckily, this was tabulated by <a href="https://academic.oup.com/book/54787">Bradley &amp; Cracknell</a> and implemented in the Julia package <a href="https://github.com/thchr/Crystalline.jl">Crystalline.jl</a>. This package depends on the latter package to access that information.</p><p>Now that the basic framework has been established, in the following sections we deduce how these functions transform and how they can be used to build a symmetric tight-binding model.</p><h2 id="Transformation-properties-of-orbitals"><a class="docs-heading-anchor" href="#Transformation-properties-of-orbitals">Transformation properties of orbitals</a><a id="Transformation-properties-of-orbitals-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-properties-of-orbitals" title="Permalink"></a></h2><p>Let us assume we have identified a set of orbitals that describe the band structure of a trivial set of bands. This can be achieved through a TQC analysis of the bands, and several tools exist to perform such a decomposition. For example, the package <a href="https://github.com/AntonioMoralesPerez/PhotonicTightBinding.jl">PhotonicTightBinding.jl</a> provides this functionality for photonic bands.</p><blockquote><p>[!NOTE] For instance, Graphene&#39;s two <em>p</em>&lt;sub&gt;<em>z</em>&lt;/sub&gt; orbitals sit at the 2b Wyckoff position. Although these orbitals are odd (i.e., changing sign) under mirror in the out-of-plane direction, they are even (i.e., invariant) under all in-plane symmetries, including rotations and mirrors. The corresponding site-symmetry irrep is the A‚ÇÅ irrep of the 2b Wyckoff position. Thus, these orbitals can be expressed as (2b|A‚ÇÅ). However, take into account that not all band representations can be induced from a set of atomic (electronic) orbitals. Some might correspond to a hybridization or a complex mixture of them.</p></blockquote><p>Let us denote by <span>$Œ±$</span> the site in the Wyckoff position where the orbital is located, and let <span>$i$</span> label the orbitals associated with that site. Then, the orbital <span>$i$</span> at site <span>$Œ±$</span> can be denoted as <span>$œï_I(ùê´)$</span>, where we introduce the compound index <span>$I=(Œ±,i)$</span>. The complete set of orbitals needed to describe the system is obtained by considering all orbitals at all sites and all lattice translations of them, i.e., <span>$\{œï_I(ùê´-ùê≠)\}_{Iùê≠}$</span>, where <span>$ùê≠$</span> is a lattice translation vector.</p><p>We focus on a particular site <span>$ùê™_1$</span>, whose orbitals <span>$œï_{1i}(ùê´)$</span> transform under a particular site-symmetry representation <span>$œÅ$</span> of the site-symmetry group <span>$G_{ùê™_1}$</span>. Then, for <span>$h ‚àà G_{ùê™_1}$</span>, this function transforms as:</p><p class="math-container">\[h œï_{1i}(ùê´) = [œÅ(h)]_{ji} œï_{1j}(ùê´)\]</p><p>Since the orbitals are localized at a Wyckoff position, there exists a coset decomposition of the space group <span>$G$</span> relating each site in the Wyckoff position, i.e., <span>$ùê™_Œ± = g_Œ± ùê™_1$</span> with <span>$g_Œ± ‚àà G$</span>.</p><blockquote><p>[!NOTE] The set of <span>$\{g_Œ±\}$</span>, in combination with translations <span>$T$</span>, will generate a decomposition of <span>$G$</span> with respect to <span>$G_ùê™$</span>:</p><p class="math-container">\[G = \bigcup_Œ± g_Œ± (G_{ùê™_1} \ltimes T)\]</p></blockquote><p>Thus, each function in the unit cell can be built from the ones at site <span>$ùê™_1$</span> as follows:</p><p class="math-container">\[œï_{Œ±i}(ùê´) = g_Œ± œï_{1i}(ùê´) = œï_{1i}(g_Œ±^{-1} ùê´)\]</p><p>By extension, translated counterparts can be defined by:</p><p class="math-container">\[\{E|ùê≠\} œï_I(ùê´) = œï_I(ùê´-ùê≠)\]</p><p>The aforementioned coset decomposition also has an interesting implication: for any operation <span>$g = \{R|ùêØ\} ‚àà G$</span>, there is a unique choice of <span>$Œ≤$</span> for each <span>$Œ±$</span> such that <span>$g g_Œ± = \{E|ùê≠_{Œ≤Œ±}\} g_Œ≤ h$</span>, for some <span>$h ‚àà G_{ùê™_1}$</span> and <span>$ùê≠_{Œ≤Œ±} = g ùê™_Œ± - ùê™_Œ≤$</span>. The formal proof of this statement is beyond the scope of these notes and can be found in this <a href="https://www.nature.com/articles/nature23268">article</a>. An intuitive picture of this statement is shown in the following figure:</p><p><img src="../figures/coset_decomposition.png" alt="Coset decomposition"/></p><p>Taking into consideration the definitions of the transformed orbitals and the previous decomposition, we deduce that the orbitals transform under the induced representation <span>$œÅ_G$</span> according to:</p><p class="math-container">\[œÅ_G(g) œï_{Œ±i}(ùê´-ùê≠) = g \{E|ùê≠\} œï_{Œ±i}(ùê´) \\
= \{E|Rùê≠\} g œï_{Œ±i}(ùê´) \\
= \{E|Rùê≠\} \{E|ùê≠_{Œ≤Œ±}\} g_Œ≤ h g_Œ±^{-1} œï_{Œ±i}(ùê´) \\
= \{E|Rùê≠ + ùê≠_{Œ≤Œ±}\} g_Œ≤ h œï_{1i}(ùê´) \\
= \sum_j \{E|Rùê≠ + ùê≠_{Œ≤Œ±}\} g_Œ≤ [œÅ(h)]_{ji} œï_{1j}(ùê´) \\
= \sum_j [œÅ(h)]_{ji} \{E|Rùê≠ + ùê≠_{Œ≤Œ±}\} œï_{Œ≤j}(ùê´) \\
= \sum_j [œÅ(h)]_{ji} œï_{Œ≤j}(ùê´ - Rùê≠ - ùê≠_{Œ≤Œ±})\]</p><p>In principle, we could use the complete set of orbitals ‚Äî <span>$\{œï_I(ùê´-ùê≠)\}$</span>, with all degrees of freedom <span>$I$</span> and all lattice translations <span>$ùê≠$</span> ‚Äî to build a tight-binding model. However, it is more practical (and usual) to use the translational invariance of these orbitals to define a Fourier transform and use their Fourier-transformed functions as a basis ‚Äî we label such functions as induced Bloch functions. By doing so, instead of working with <span>$\dim(I) √ó N$</span> orbitals, where <span>$\dim(I)$</span> is the number of sites plus the number of orbitals at each site and <span>$N$</span> is the number of unit cells, we consider <span>$\dim(I)$</span> functions evaluated at <span>$N$</span> points inside the Brillouin zone.</p><p>However, when defining a Fourier transform, there is a gauge freedom which leads to different, so-called, ‚Äúconventions.‚Äù This choice has important implications for the representations of the symmetry operations and even for the representation of the Hamiltonian. Here, we focus on one convention and discuss changes and similarities with another convention in <a href="#appendix-a">Appendix A</a>.</p><h3 id="Transformation-properties-of-induced-Bloch-functions"><a class="docs-heading-anchor" href="#Transformation-properties-of-induced-Bloch-functions">Transformation properties of induced Bloch functions</a><a id="Transformation-properties-of-induced-Bloch-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-properties-of-induced-Bloch-functions" title="Permalink"></a></h3><p>Using the translational invariance of the orbitals, we can formally define a Fourier transform of them. These functions will not be solutions to any Schr√∂dinger-like problem, so instead of calling them Bloch states, we use the term <em>induced</em> Bloch functions, or just Bloch functions.</p><p>As mentioned before, there is a gauge freedom in the choice of the Fourier transform. Here, we choose the following one:</p><p class="math-container">\[œÜ_{I,ùê§}(ùê´) ‚â° \sum_ùê≠ e^{iùê§¬∑(ùê≠+ùê™_Œ±)} œï_I(ùê´-ùê≠)\]</p><p>The main reason behind this choice is the fact that, with this gauge, the ùê§-space dependence of the representation of space-group transformations enters as a global phase, as we will see. This is convenient for computational purposes, which is why we chose it. However, this convention implies that the Bloch functions are not periodic in reciprocal space:</p><p class="math-container">\[œÜ_{I,ùê§+ùêÜ} = \sum_ùê≠ e^{i(ùê§+ùêÜ)¬∑(ùê≠+ùê™_Œ±)} œï_I(ùê´-ùê≠) \\
= \sum_ùê≠ e^{iùêÜ¬∑(ùê≠+ùê™_Œ±)} e^{iùê§¬∑(ùê≠+ùê™_Œ±)} œï_I(ùê´-ùê≠) \\
= e^{iùêÜ¬∑ùê™_Œ±} œÜ_{I,ùê§}\]</p><p>This implies that if the orbital is located at a non-integer position in the unit cell (i.e., not at positions that are integer combinations of lattice vectors), the phase factor will differ from unity and the Bloch function will gain a phase. Thus, in general, the Bloch functions are not periodic under reciprocal lattice translations within this convention. This has implications for computing parts of this package, such as the representation of symmetry operations or symmetry eigenvalues.</p><p>Since these functions are derived from the orbitals, the transformation properties of these functions can be obtained. How these functions transform under symmetry operations constitutes what is usually called a <em>band representation</em>. In particular, this band representation will be:</p><p class="math-container">\[g œÜ_{iŒ±,ùê§}(ùê´) = \frac{1}{\sqrt{N}} \sum_ùê≠ e^{iùê§¬∑(ùê≠+ùê™_Œ±)} g œï_{iŒ±}(ùê´-ùê≠) \\
= \frac{1}{\sqrt{N}} \sum_{ùê≠,j} e^{iùê§¬∑(ùê≠+ùê™_Œ±)} [œÅ(h)]_{ji} œï_{jŒ≤}(ùê´-Rùê≠-ùê≠_{Œ≤Œ±}) \\
= \frac{1}{\sqrt{N}} \sum_{ùê≠&#39;,j} [œÅ(h)]_{ji} e^{iùê§¬∑R^{-1}(ùê≠&#39;+ùê™_Œ≤-ùêØ)} œï_{jŒ≤}(ùê´-ùê≠&#39;) \\
= e^{-i([R^{-1}]^T ùê§)¬∑ùêØ} \frac{1}{\sqrt{N}} \sum_{ùê≠&#39;,j} [œÅ(h)]_{ji} e^{i([R^{-1}]^T ùê§)¬∑(ùê≠&#39;+ùê™_Œ≤)} œï_{jŒ≤}(ùê´-ùê≠&#39;) \\
= e^{-i([R^{-1}]^T ùê§)¬∑ùêØ} \sum_j [œÅ(h)]_{ji} œÜ_{jŒ≤,[R^{-1}]^T ùê§}(ùê´),\]</p><p>where we have defined <span>$ùê≠&#39; = Rùê≠ + ùê≠_{Œ≤Œ±} ‚áí ùê≠ = R^{-1} (ùê≠&#39;-ùê≠_{Œ≤Œ±})$</span>, and we have used the following property: <span>$ùê§¬∑(R ùê´) = (R^T ùê§)¬∑ùê´$</span>. Finally, if we define the action of a symmetry operation <span>$g = \{R|ùêØ\}$</span> on a reciprocal space vector ùê§ as: <span>$gùê§ ‚â° [R^{-1}]^T ùê§$</span>, we can rewrite the previous relation as:</p><p class="math-container">\[g œÜ_{I,ùê§}(ùê´) = e^{-i(g ùê§)¬∑ùêØ} \sum_J [œÅ(h)]_{JI} œÜ_{J,g ùê§}(ùê´)\]</p><p>This relation is crucial in the implementation of the package, since it states the band representation of the system. If a tight-binding model is built from this set of functions, its band structure will, by construction, replicate that of the original system. In other words, the tight-binding model will inherit all symmetries of the system, forcing the same degeneracies the system has, and exhibit the same symmetry-indicated topology.</p><p>For the sake of simplicity, we define a matrix <span>$ùêÉ_ùê§(g)$</span> whose entries are given by the previous operation, i.e., <span>$[ùêÉ_ùê§(g)]_{JI} = e^{-i(g ùê§)¬∑ùêØ} [œÅ(h)]_{JI}$</span>, where <span>$I = (Œ±,i)$</span>, <span>$J = (Œ≤,j)$</span> and <span>$ùê≠_{Œ≤Œ±} = g ùê™_Œ± - ùê™_Œ≤$</span>. Then, we can rewrite the previous relation as:</p><p class="math-container">\[\boxed{g œÜ_{I,ùê§}(ùê´) = \sum_J [ùêÉ_ùê§(g)]_{JI} œÜ_{J,g ùê§}(ùê´)}\]</p><p>It is important to notice that the dependence on ùê§ of the representation <span>$ùêÉ_ùê§$</span> is a global phase factor. This is convenient for computational purposes when imposing the symmetry constraints in the Hamiltonian.</p><p>Our next objective is to build a tight-binding model that uses these functions as a basis and replicates the band structure of the system. We perform this construction in the next section.</p><h2 id="Build-a-tight-binding-Hamiltonian-from-a-set-of-symmetric-orbitals"><a class="docs-heading-anchor" href="#Build-a-tight-binding-Hamiltonian-from-a-set-of-symmetric-orbitals">Build a tight-binding Hamiltonian from a set of symmetric orbitals</a><a id="Build-a-tight-binding-Hamiltonian-from-a-set-of-symmetric-orbitals-1"></a><a class="docs-heading-anchor-permalink" href="#Build-a-tight-binding-Hamiltonian-from-a-set-of-symmetric-orbitals" title="Permalink"></a></h2><p>Second quantization rephrases quantum mechanics in terms of fields and occupation numbers. Instead of tracking individual particles, we describe how many particles occupy each quantum state.</p><p>In order to do so, we need to introduce creation and annihilation operators. Since we want to use the basis of orbitals previously introduced, we can define them as:</p><p class="math-container">\[\ket{œï_{I,ùê≠}} ‚â° ƒâ^‚Ä†_{I,ùê≠} \ket{\text{vac}}\]</p><p>Then, the most general tight-binding Hamiltonian can be written using those operators as:</p><p class="math-container">\[ƒ§ = \sum_{IJ,ùê≠ùê≠&#39;} h_{IJ,ùê≠-ùê≠&#39;} ƒâ^‚Ä†_{I,ùê≠} ƒâ_{J,ùê≠&#39;}\]</p><p>This Hamiltonian states that the probability amplitude of &quot;hopping&quot; from an orbital <span>$\ket{œï_{J,ùê≠&#39;}}$</span> to an orbital <span>$\ket{œï_{I,ùê≠}}$</span> is given by the amplitude term <span>$h_{IJ,ùê≠-ùê≠&#39;}$</span>. Notice that we have assumed that the hopping amplitude depends only on the relative distance between both orbitals. This implies that the Hamiltonian is translation invariant, as it should be. In the following, we refer to that distance as <span>$ùêë = ùê≠-ùê≠&#39;$</span>. Realize that it must be a lattice translation. Using this definition we can rewrite the previous Hamiltonian as:</p><p class="math-container">\[ƒ§ = \sum_{IJ,ùêëùê≠&#39;} h_{IJ,ùêë} ƒâ^‚Ä†_{I,ùêë+ùê≠&#39;} ƒâ_{J,ùê≠&#39;}\]</p><p>In order to be consistent with the previous choice of the Fourier transform, the creation operator in reciprocal space must be related to <span>$ƒâ^‚Ä†_{I,ùê≠}$</span> by:</p><p class="math-container">\[\ket{œÜ_{I,ùê§}} = √¢_{I,ùê§}^‚Ä† \ket{\text{vac}} \\
= \frac{1}{\sqrt{N}} \sum_ùê≠ e^{iùê§¬∑(ùê≠+ùê™_Œ±)} \ket{œï_{I,ùê≠}} = \frac{1}{\sqrt{N}} \sum_ùê≠ e^{iùê§¬∑(ùê≠+ùê™_Œ±)} ƒâ_{I,ùê≠}^‚Ä† \ket{\text{vac}} \\
‚áí √¢_{I,ùê§}^‚Ä† = \frac{1}{\sqrt{N}} \sum_ùê≠ e^{iùê§¬∑(ùê≠+ùê™_Œ±)} ƒâ_{I,ùê≠}^‚Ä†\]</p><p>Notice that since <span>$œÜ_{I,ùê§+ùêÜ}(ùê´) = e^{iùêÜ¬∑ùê™_Œ±} œÜ_{I,ùê§}(ùê´)$</span>, we also have <span>$√¢_{I,ùê§+ùêÜ}^‚Ä† = e^{iùêÜ¬∑ùê™_Œ±} √¢_{I,ùê§}^‚Ä†$</span>, consistently.</p><p>Considering this, we can rewrite the tight-binding Hamiltonian in reciprocal space as:</p><p class="math-container">\[ƒ§ = \frac{1}{N} \sum_{IJ,ùêëùê≠&#39;} h_{IJ,ùêë} \sum_{ùê§ùê§&#39;} e^{iùê§¬∑(ùêë+ùê≠&#39;+ùê™_Œ±)} e^{-iùê§&#39;¬∑(ùê≠&#39;+ùê™_Œ≤)} √¢_{I,ùê§}^‚Ä† √¢_{J,ùê§&#39;} \\
= \frac{1}{N} \sum_{IJ,ùêëùê≠&#39;,ùê§ùê§&#39;} h_{IJ,ùêë} e^{iùê§¬∑(ùêë+ùê™_Œ±)} e^{i(ùê§-ùê§&#39;)¬∑ùê≠&#39;} e^{-ùê§&#39;¬∑ùê™_Œ≤} √¢_{I,ùê§}^‚Ä† √¢_{J,ùê§&#39;} \\
= \sum_{IJ,ùêë,ùê§} h_{IJ,ùêë} e^{iùê§¬∑(ùêë+ùê™_Œ±-ùê™_Œ≤)} √¢_{I,ùê§}^‚Ä† √¢_{J,ùê§},\]</p><p>where we have used the property of exponential functions: <span>$\sum_{ùê≠&#39;} e^{i(ùê§-ùê§&#39;)¬∑ùê≠&#39;} = N Œ¥_{ùê§ùê§&#39;}$</span>.</p><p>Finally, if we define <span>$h_{IJ,ùê§} = \sum_ùêë h_{IJ,ùêë} e^{iùê§¬∑(ùêë+ùê™_Œ±-ùê™_Œ≤)}$</span>, we obtain the usual expression for a tight-binding Hamiltonian in reciprocal space:</p><p class="math-container">\[ƒ§ = \sum_{IJ,ùê§} h_{IJ,ùê§} √¢_{I,ùê§}^‚Ä† √¢_{J,ùê§}\]</p><p>As shown, the hopping amplitude in reciprocal space is computed from a sum of the real-space hopping amplitudes for all lattice translations ùêë. Usually, such a sum is truncated with some &quot;arbitrary&quot; (subjective) cutoff. One common approach is to consider a certain number of nearest neighbors. Since we are interested in building a symmetry-constrained tight-binding model and symmetry-related terms might not coincide with <span>$n$</span>-th nearest neighbors, we consider a different approach. As we will develop later, our strategy focuses on asking the user to provide a set of ùêë-vectors where to look, at least, for hopping terms, and then search for all symmetry-related terms starting from that initial, but potentially not complete, set.</p><p>As can be seen, the tight-binding Hamiltonian is diagonal in reciprocal space. This is due to the assumption that the Hamiltonian is translation invariant. Then, it is natural to define what is usually called the <em>Bloch Hamiltonian</em> <span>$ƒ§_ùê§$</span>, which consists of the diagonal blocks in reciprocal space of the tight-binding Hamiltonian:</p><p class="math-container">\[ƒ§_ùê§ = \sum_{IJ} h_{IJ,ùê§} √¢_{I,ùê§}^‚Ä† √¢_{J,ùê§}\]</p><p>Some general properties must be fulfilled independent of its representation, such as periodicity in reciprocal space. However, as shown above, the creation and annihilation operators are not periodic under reciprocal lattice translations and we also have that:</p><p class="math-container">\[h_{IJ,ùê§+ùêÜ} = \sum_ùêë h_{IJ,ùêë} e^{i(ùê§+ùêÜ)¬∑(ùêë+ùê™_Œ≤-ùê™_Œ±)} \\
= e^{iùêÜ¬∑(ùê™_Œ≤-ùê™_Œ±)} \sum_ùêë h_{IJ,ùêë} \cancel{e^{iùêÜ¬∑ùêë}} e^{iùê§¬∑(ùêë+ùê™_Œ≤-ùê™_Œ±)} \\
= e^{iùêÜ¬∑(ùê™_Œ≤-ùê™_Œ±)} h_{IJ,ùê§}\]</p><p>However, all these phase factors cancel out in the Bloch Hamiltonian, so it is translationally invariant in reciprocal space, as can be seen:</p><p class="math-container">\[ƒ§_{ùê§+ùêÜ} = \sum_{IJ} h_{IJ,ùê§+ùêÜ} √¢_{I,ùê§+ùêÜ}^‚Ä† √¢_{J,ùê§+ùêÜ} \\
= \sum_{IJ} e^{iùêÜ¬∑(ùê™_Œ≤-ùê™_Œ±)} h_{IJ,ùê§} e^{iùêÜ¬∑ùê™_Œ±} √¢_{I,ùê§}^‚Ä† e^{-iùêÜ¬∑ùê™_Œ≤} √¢_{J,ùê§} \\
= \sum_{IJ} h_{IJ,ùê§} √¢_{I,ùê§}^‚Ä† √¢_{J,ùê§} = ƒ§_ùê§\]</p><p>Then, we obtain the important translational invariance in reciprocal space of the Bloch Hamiltonian: <span>$ƒ§_{ùê§+ùêÜ} = ƒ§_ùê§$</span>. This property allows us to consider only the first Brillouin zone when we examine the Bloch Hamiltonian.</p><p>The Bloch Hamiltonian can be expressed as a matrix by:</p><p class="math-container">\[ƒ§_ùê§ = √Ç_ùê§^‚Ä† ùêá_ùê§ √Ç_ùê§,\]</p><p>where <span>$√Ç_ùê§^‚Ä† = [ √¢_{1,ùê§}^‚Ä†, √¢_{2,ùê§}^‚Ä†, ‚Ä¶ ]$</span> is a row vector collecting all creation operators, similarly with <span>$√Ç_ùê§$</span>, and <span>$ùêá_ùê§$</span> is a complex matrix whose each entry is defined by: <span>$[ùêá_ùê§]_{IJ} ‚â° h_{IJ,ùê§}$</span>. The matrix <span>$ùêá_ùê§$</span> is the one we are going to use in our package to compute the eigenvectors and eigenvalues for each ùê§-point.</p><p>Notice that this matrix <span>$ùêá_ùê§$</span> is strongly dependent on the Fourier transform chosen. As proved above, within this convention, this matrix is not invariant under reciprocal lattice translations. However, this does not hold under other conventions as exposed in <a href="#appendix-a">Appendix A</a>. This property is not suitable for computing some fundamental properties such as the symmetry eigenvalues, but it has some computational advantages when encoding the matrix representation <span>$ùêá_ùê§$</span> in the package.</p><p>Before proceeding, we deduce the constraints that the symmetries of the system impose on the matrix <span>$ùêá_ùê§$</span>. This will ensure that the model replicates the symmetry and (symmetry-indicated) topology of the system. For that purpose, first, we deduce how the creation and annihilation operators transform under the symmetry operations. Let us start with the creation operator:</p><p class="math-container">\[ƒù √¢_{I,ùê§}^‚Ä† ƒù^{-1} \ket{\text{vac}} = ƒù √¢_{I,ùê§}^‚Ä† \ket{\text{vac}} = ƒù \ket{œÜ_{I,ùê§}} \\
= \sum_J [ùêÉ_ùê§(g)]_{JI} \ket{œÜ_{J,gùê§}} = \sum_J [ùêÉ_ùê§(g)]_{JI} √¢_{J,gùê§}^‚Ä† \ket{\text{vac}} \\
‚áí ƒù √¢_{I,ùê§}^‚Ä† ƒù^{-1} = \sum_J [ùêÉ_ùê§(g)]_{JI} √¢_{J,gùê§}^‚Ä†\]</p><p>Since the symmetry operations <span>$ƒù$</span> are unitary, i.e., <span>$ƒù^{-1} = ƒù^‚Ä†$</span>, we can deduce the transformation properties of the annihilation operator from those of the creation operator, resulting in the relation:</p><p class="math-container">\[ƒù √¢_{I,ùê§} ƒù^{-1} = \sum_J [ùêÉ_ùê§^*(g)]_{JI} √¢_{J,gùê§}\]</p><p>Considering these two transformation properties of the operators, we can deduce the set of relations that the symmetry operations enforce on the Bloch Hamiltonian. The invariance of the Hamiltonian under symmetry operations reads as:</p><p class="math-container">\[ƒ§ = ƒù ƒ§ ƒù^{-1}\]</p><p>Expanding the Hamiltonian in terms of the creation and annihilation operator basis leads us to:</p><p class="math-container">\[\sum_{IJ,ùê§} √¢_{I,ùê§}^‚Ä† h_{IJ,ùê§} √¢_{J,ùê§} = \sum_{IJ,ùê§} ƒù √¢_{I,ùê§}^‚Ä† h_{IJ,ùê§} √¢_{J,ùê§} ƒù^{-1} \\
= \sum_{IJ,ùê§} ƒù √¢_{I,ùê§}^‚Ä† ƒù^{-1} h_{IJ,ùê§} ƒù √¢_{J,ùê§} ƒù^{-1} \\
= \sum_{IJ,ùê§,I&#39;J&#39;} [ùêÉ_ùê§(g)]_{I&#39;I} √¢_{I&#39;,gùê§}^‚Ä†  h_{IJ,ùê§} [ùêÉ_ùê§^*(g)]_{J&#39;J} √¢_{J&#39;,gùê§} \\
= \sum_{ùê§,I&#39;J&#39;} √¢_{I&#39;,gùê§}^‚Ä† [ùêÉ_ùê§(g) ùêá_ùê§ ùêÉ_ùê§^‚Ä†(g)]_{I&#39;J&#39;} √¢_{J&#39;,gùê§} \\
‚áí \boxed{ùêá_{gùê§} = ùêÉ_ùê§(g) ùêá_ùê§ ùêÉ_ùê§^‚Ä†(g)}\]</p><p>This symmetry constraint strongly restricts the functional form of <span>$ùêá_ùê§$</span>. Rather than being a completely general Hermitian (or anti-Hermitian) matrix, <span>$ùêá_ùê§$</span> must now lie in the subspace of matrices that fulfill the previous constraints. This ensures that the model preserves all symmetries and reproduces the correct degeneracies and connectivity of the original band structure.</p><p>Additionally, as explained above, the ùê§-dependence of the representation matrices <span>$ùêÉ_ùê§$</span> is only a global phase factor, so it can be dropped in the previous relation. This is very convenient in implementation-wise since the ùê§-dependence in the previous relation is restricted to just the matrix <span>$ùêá_ùê§$</span>, making it easier to encode in non-symbolic programming languages such as Julia.</p><p>As stated previously, we are interested in diagonalizing this matrix and finding the eigenvectors and eigenvalues associated with it at each ùê§-point. Those eigenvectors correspond to vectors of coefficients, associated with the basis set on which we built the Bloch Hamiltonian, and describe the Bloch state of the system at a particular ùê§-point and energy. In the following section, we elaborate on this topic and develop how these Bloch states transform under the symmetry operations of the system. A sanity check is to compare the band representation of both the real system‚Äôs band structure and the tight-binding model‚Äôs band structure, which should be equal.</p><h3 id="Transformation-properties-of-the-Bloch-states"><a class="docs-heading-anchor" href="#Transformation-properties-of-the-Bloch-states">Transformation properties of the Bloch states</a><a id="Transformation-properties-of-the-Bloch-states-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-properties-of-the-Bloch-states" title="Permalink"></a></h3><p>Until now we have focused on building a symmetry-constrained Hamiltonian to model the band structure of a physical system. Now, we shift our attention to analyze the properties of the Bloch states of the model, which must replicate the band structure of the physical system.</p><p>Let us start by defining the eigenvalue problem from which we start:</p><p class="math-container">\[ùêá_ùê§ ùê∞_{n,ùê§} = E_{nùê§} ùê∞_{n,ùê§},\]</p><p>where <span>$\{E_{nùê§}\}$</span> is the set of eigenvalues (energies) at each ùê§-point and <span>$\{ùê∞_{n,ùê§}\}$</span> the set of eigenvectors associated with them. Each eigenvector is a vector of coefficients which corresponds to a particular Bloch state in the basis used for describing the Bloch Hamiltonian, i.e.:</p><p class="math-container">\[\ket{œà_{nùê§}} = \sum_I w_{I,nùê§} \ket{œÜ_{I,ùê§}} = \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w_{I,nùê§} e^{iùê§¬∑(ùê≠+ùê™_Œ±)} \ket{œï_{I,ùê≠}}\]</p><p>Now that the Bloch states have been defined, we can deduce their transformation properties. First, we analyze their transformation properties under lattice translations in real and reciprocal space and, subsequently, their transformation properties under symmetry operation of the space group.</p><h4 id="Transformation-properties-under-lattice-translations"><a class="docs-heading-anchor" href="#Transformation-properties-under-lattice-translations">Transformation properties under lattice translations</a><a id="Transformation-properties-under-lattice-translations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-properties-under-lattice-translations" title="Permalink"></a></h4><p>Let us first consider lattice translations in real space:</p><p class="math-container">\[œà_{nùê§}(ùê´+ùêë) = \braket{ùê´+ùêë|œà_{nùê§}} \\
= \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w_{I,nùê§} e^{iùê§¬∑(ùê≠+ùê™_Œ±)} \braket{ùê´+ùêë|œï_{n,ùê≠}} \\
= \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w_{I,nùê§} e^{iùê§¬∑(ùê≠+ùê™_Œ±)} \braket{ùê´|œï_{n,ùê≠-ùêë}} \\
= e^{iùê§¬∑ùêë} \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w_{I,nùê§} e^{iùê§¬∑(ùê≠-ùêë+ùê™_Œ±)} \braket{ùê´|œï_{n,ùê≠-ùêë}} \\
= e^{iùê§¬∑ùêë} \braket{ùê´|œà_{nùê§}} = e^{iùê§¬∑ùêë} œà_{nùê§}(ùê´)\]</p><p>The Bloch states transform as Bloch functions under translations in real space, as expected.</p><p>Secondly, let us analyze how they transform under reciprocal lattice translations. Recall that, within this convention, the matrix representation <span>$ùêá_ùê§$</span> is not periodic under reciprocal lattice translations. This implies that <span>$ùê∞_{nùê§}$</span> will not be either, but the eigenvalues <span>$E_{nùê§}$</span> must be periodic since those are the energies associated with each Bloch state ‚Äî independent of the basis chosen to represent the Hamiltonian. Let us analyze this behavior:</p><p class="math-container">\[ùêá_{ùê§+ùêÜ} ùê∞_{n,ùê§+ùêÜ} = E_{n,ùê§+ùêÜ} ùê∞_{n,ùê§+ùêÜ} \\
‚áí \sum_J h_{IJ,ùê§+ùêÜ} w_{Jn,ùê§+ùêÜ} = E_{n,ùê§} w_{In,ùê§+ùêÜ} \\
‚áí \sum_J e^{iùêÜ¬∑(ùê™_Œ≤-ùê™_Œ±)} h_{IJ,ùê§} w_{Jn,ùê§+ùêÜ} = E_{n,ùê§} w_{In,ùê§+ùêÜ} \\
‚áí \sum_J h_{IJ,ùê§} e^{iùêÜ¬∑ùê™_Œ≤} w_{Jn,ùê§+ùêÜ} = E_{n,ùê§} e^{iùêÜ¬∑ùê™_Œ±} w_{In,ùê§+ùêÜ}\]</p><p>Then, this implies that the eigenvectors gain a phase factor when translated in reciprocal space such that:</p><p class="math-container">\[w_{In,ùê§+ùêÜ} = e^{-iùêÜ¬∑ùê™_Œ±} w_{In,ùê§}\]</p><p>To make this easier, we can define a diagonal matrix such that <span>$[Œò_ùêÜ]_{II} = e^{-iùêÜ¬∑ùê™_Œ±}$</span>; then the previous expression can be rewritten as:</p><p class="math-container">\[ùê∞_{n,ùê§+ùêÜ} = Œò_ùêÜ ùê∞_{n,ùê§}\]</p><p>Notice that this transformation is not a simple phase factor ‚Äî which is indeterminate for eigenvectors; rather, it acts differently on each entry of the eigenvector. This extra factor is crucial when analyzing the invariance of the Bloch states under reciprocal lattice translations, as we will see now.</p><p>Let us deduce how Bloch states will transform under reciprocal lattice translations:</p><p class="math-container">\[\ket{œà_{n,ùê§+ùêÜ}} = \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w_{In,ùê§+ùêÜ} e^{i(ùê§+ùêÜ)¬∑(ùê≠+ùê™_Œ±)} \ket{œï_{I,ùê≠}} \\
= \frac{1}{\sqrt{N}} \sum_{I,ùê≠} \cancel{e^{-iùêÜ¬∑ùê™_Œ±}} w_{In,ùê§} \cancel{e^{iùêÜ¬∑ùê≠}} \cancel{e^{iùêÜ¬∑ùê™_Œ±}} e^{iùê§¬∑(ùê≠+ùê™_Œ±)} \ket{œï_{I,ùê≠}} \\
= \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w_{In,ùê§} e^{iùê§¬∑(ùê≠+ùê™_Œ±)} \ket{œï_{I,ùê≠}} = \ket{œà_{nùê§}}\]</p><p>The Bloch states remain invariant under reciprocal lattice translations, as they should. This is a a crucial feature which must be upheld, regardless of the basis used for representing the Hamiltonian or the Fourier convention used. We prove that the property also holds for another Fourier convention in <a href="#appendix-a">Appendix A</a>.</p><h4 id="Transformation-properties-under-symmetry-operations"><a class="docs-heading-anchor" href="#Transformation-properties-under-symmetry-operations">Transformation properties under symmetry operations</a><a id="Transformation-properties-under-symmetry-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-properties-under-symmetry-operations" title="Permalink"></a></h4><p>Here we analyze how the Bloch states transform under more complex symmetry operations <span>$g = \{R|ùêØ\}$</span> that might involve translations <span>$ùêØ$</span> and site-symmetry operations <span>$R$</span>. The Bloch state transforms under these operations as:</p><p class="math-container">\[ƒù \ket{œà_{nùê§}} = \sum_I w_{I,nùê§} ƒù \ket{œÜ_{I,ùê§}} \\
= \sum_{IJ} w_{I,nùê§} [ùêÉ_ùê§(g)]_{JI} \ket{œÜ_{J,gùê§}} \\
= \sum_{IJ} [ùêÉ_ùê§(g)]_{JI} w_{I,nùê§} \ket{œÜ_{J,gùê§}}\]</p><p>We are particularly interested in the transformation under operations <span>$ƒù$</span> in the little group <span>$G_ùê§$</span> of a particular ùê§-point. These operations leave the particular ùê§-point invariant up to a lattice translation, i.e., <span>$g ùê§ = ùê§ + ùêÜ$</span>. How these functions transform under those operations at each high-symmetry point allows us to assign an irrep to each of the Bloch states at that ùê§-point. Those should coincide with the ones obtained from the original system&#39;s band structure. The irrep can be assigned by computing the symmetry eigenvalues associated with each Bloch state. These are computed by:</p><p class="math-container">\[\braket{œà_{nùê§}|ƒù|œà_{nùê§}} = \sum_{IJ} (w_{I,nùê§})^* w_{J,nùê§} \braket{œÜ_{I,ùê§}|ƒù|œÜ_{J,ùê§}} \\
= \sum_{IJJ&#39;} (w_{I,nùê§})^* w_{J,nùê§} [ùêÉ_ùê§(g)]_{J&#39;J} \braket{œÜ_{I,ùê§}|œÜ_{J&#39;,gùê§}} \\
= \sum_{IJJ&#39;} (w_{I,nùê§})^* w_{J,nùê§} [ùêÉ_ùê§(g)]_{J&#39;J} \braket{œÜ_{I,ùê§}|œÜ_{J&#39;,ùê§+ùêÜ}} \\
= \sum_{IJJ&#39;} (w_{I,nùê§})^* w_{J,nùê§} [ùêÉ_ùê§(g)]_{J&#39;J} e^{iùêÜ¬∑ùê™_{Œ≤&#39;}} \braket{œÜ_{I,ùê§}|œÜ_{J&#39;,ùê§}} \\
= \sum_{IJJ&#39;} (w_{I,nùê§})^* w_{J,nùê§} [ùêÉ_ùê§(g)]_{J&#39;J} e^{iùêÜ¬∑ùê™_{Œ≤&#39;}} Œ¥_{IJ&#39;} \\
= \sum_{IJ} (w_{I,nùê§})^* e^{iùêÜ¬∑ùê™_Œ±} [ùêÉ_ùê§(g)]_{IJ} w_{J,nùê§}\]</p><p>where we have used how the Bloch functions transform under reciprocal lattice translations ‚Äî a property inherit from the convention choice ‚Äî and their orthogonality.</p><div class="admonition is-info" id="Acting-with-representation-matrices:-to-transpose-or-not-to-transpose-5a4d2613bd1ed4e5"><header class="admonition-header">Acting with representation matrices: to transpose or not to transpose<a class="admonition-anchor" href="#Acting-with-representation-matrices:-to-transpose-or-not-to-transpose-5a4d2613bd1ed4e5" title="Permalink"></a></header><div class="admonition-body"><p>A subtly suprising feature may stand out from the above result: unlike previously, the representation matrix <span>$ùêÉ_ùê§(g)$</span> is acting &quot;directly&quot;, i.e., untransposed, on the &quot;state&quot; <span>$w_{J,nùê§}$</span>. Although this may appear to be at odds with the earlier approach of the representation matrix acting via its transpose, it is entirely consistent. The key point is that previously, we defined the representation matrix to act via its transpose on <em>basis vectors</em> (e.g., <span>$\ket{œÜ_{J,ùê§}}$</span>). However, here, the representation matrix is acting on a <em>coefficient vector</em>.</p><p>It&#39;s easy to see by example that the action on these two different kinds of vectors must be different. In particular, if we define the action of <span>$ƒù$</span> on a <em>basis</em> <span>$ùêØ_i$</span> as <span>$ƒù ùêØ_i = \sum_{j} D_{ji} ùêØ_j$</span>, then any general vector <span>$œà = \sum_i c_i ùêØ_i$</span> (specified by a basis <span>$\{ùêØ_i\}$</span> and a corresponding set of expansion coefficients <span>$\{c_i\}$</span>) must transform as:</p><p class="math-container">\[ƒù œà
= ƒù \sum_i c_i ùêØ_i
=  \sum_i c_i ƒù ùêØ_i 
=  \sum_{ij} c_i D_{ji} ùêØ_j\]</p><p>The latter expression can be interpreted equivalently as either</p><ol><li><span>$ùêú^T (ùêÉ^T ùêØ)$</span>: i.e., ùêÉ acting transposed on the &quot;vector of basis vectors&quot; <span>$ùêØ = [ùêØ_1, ùêØ_2, ‚Ä¶]$</span>, or as </li><li><span>$(ùêÉ ùêú)^T ùêØ$</span>: i.e., ùêÉ acting un-transposed on the coefficient vector <span>$ùêú = [c_1, c_2, ‚Ä¶]$</span>.</li></ol><p>I.e., the general rule is that the representation matrix acts transposed on basis vectors, and untransposed on coefficient vectors.</p></div></div><p>Notice that this expression has a phase factor that cannot be omitted. In Convention 2 this phase factor does not appear, producing an arguably simlper expression. Nevertheless, we stick to the current convention due to the property of the ùê§-dependence in the representation matrices of symmetry operations. However, it is interesting to be able to change from one convention to others. Because of that, we include some functions in the package to be able to change from one convention to another one ‚Äî heavily used in the literature. The relation between these two conventions can be found in <a href="#appendix-a">Appendix A</a>.</p><p>This expression for <span>$\braket{œà_{nùê§}|ƒù|œà_{nùê§}} = \sum_{IJ} (w_{I,nùê§})^* w_{J,nùê§} \braket{œÜ_{I,ùê§}|ƒù|œÜ_{J,ùê§}}$</span> can be rewritten in a vectorized form, convenient for implementation. To do so, we make use of the previously introduced phase-factor diagonal matrix <span>$Œò_ùê§$</span>, allowing:</p><p class="math-container">\[\boxed{\braket{œà_{nùê§}|ƒù|œà_{nùê§}} = (Œò_ùêÜ ùê∞_{nùê§})^\dagger (ùêÉ_ùê§(g) ùê∞_{nùê§}).}\]</p><p>Note that the <span>$[Œò_ùêÜ]_{II} = e^{-iùêÜ¬∑ùê™_Œ±}$</span>  matrix is placed in the conjugated part of the dot product, consistent with the minus sign in the definition of Œò_ùêÜ.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>We have now developed the theory needed to explore the most important parts of the package. However, we have not tackled one important point: implementing these constraints and algebraic structures in a conventional programming language, such as Julia, which lacks symbolic manipulation capabilities. To overcome this, we must develop a way to encode the preceding formulas and algebraic structures.</p><p>In the following section, we present the strategy we have developed to this end. The main idea is to express the structure of the Hamiltonian that is amenable to both linear algebra and enforcement of the symmetry constraints.</p><h2 id="Implementing-Symbolic-Hamiltonians-in-Non-Symbolic-Environments"><a class="docs-heading-anchor" href="#Implementing-Symbolic-Hamiltonians-in-Non-Symbolic-Environments">Implementing Symbolic Hamiltonians in Non-Symbolic Environments</a><a id="Implementing-Symbolic-Hamiltonians-in-Non-Symbolic-Environments-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-Symbolic-Hamiltonians-in-Non-Symbolic-Environments" title="Permalink"></a></h2><p>In this section we aim to introduce our strategy to encode the symbolic structures and formulas we have presented in a non-symbolic programming language, such as Julia.</p><p>Let us consider a term in a general Hamiltonian which describes the hopping term between two EBRs. For the sake of simplicity let us call them <span>$Œ±: (ùê™|A)$</span> and <span>$Œ≤: (ùê∞|B)$</span>, where <span>$ùê™$</span> and <span>$ùê∞$</span> represent two particular Wyckoff positions in the space group and <span>$A$</span> and <span>$B$</span> are two associated site-symmetry irreps of arbitrary dimension.</p><p>Additionally, we will distinguish each point in the Wyckoff positions&#39;s orbit and each orbital in the site-symmetry irreps by subscripting <span>$ùê™$</span>, <span>$ùê∞$</span>, <span>$A$</span>, and <span>$B$</span>:</p><p class="math-container">\[ùê™: q_1, q_2, ‚Ä¶, q_N \\
ùê∞: w_1, w_2, ‚Ä¶, w_M \\
A: A_1, A_2, ‚Ä¶, A_J \\
B: B_1, B_2, ‚Ä¶, B_K\]</p><p>such that e.g., <span>$(q_2, A_3)$</span> denotes an orbital transforming like the third partner function of the <span>$A$</span>-irrep, placed at the second position in the orbit of <span>$\mathbf{q}$</span>.</p><p>As we have discussed previously, in reciprocal space the Hamiltonian term involving those EBRs, <span>$ùêá_ùê§$</span> can be written as a matrix where each row denote an orbital from the &quot;arriving&quot; EBR and the column an orbital from the &quot;departing&quot; EBR. Each of its components will be a complex number which depend on the vector ùê§ and on some free-parameters that later on we will adjust to obtain the band structure.</p><p>In order to encode such Hamiltonian term, we will need to do some previous steps.</p><p>The first step we need to do is to list all the possible hopping distances that can be found between this two EBRs. Obviously, that set will be infinite so we need to impose a particular cutoff. As explained above, we will impose it by constraining the hopping terms to a particular set of lattice translations ‚Äî and obviously theirs symmetry partners. This complex structure is computed in the function <code>obtain_symmetry_related_hoppings</code>, where we provide a set of representatives of hopping distances which which is associated to a set of hopping terms that are symmetry related.</p><p>Inside of one of this representatives we will find different hopping distances <span>$Œ¥s = [Œ¥_1, Œ¥_2, ‚Ä¶, Œ¥_n]$</span>, which will be associated to different hopping terms:</p><p class="math-container">\[Œ¥_1: q_i ‚Üí w_j + G_k, q_l ‚Üí w_l + G_n, ‚Ä¶ \\
Œ¥_2: q_o ‚Üí w_p + G_r, q_s ‚Üí w_t + G_z, ‚Ä¶ \\
\vdots\]</p><p>where <span>$G_k$</span> are some particular lattice translations.</p><p>With this information we are able to numerically codify the Hamiltonian matrix by terms, as we will show in the following.</p><p>As we showed above, the phases in the Bloch Hamiltonian can be computed from this hopping vectors. First, we use them to create an abstract vector <span>$ùêØ$</span> which will store the phases that will appear in the Hamiltonian&#39;s term in reciprocal space. Being specific, this vector would like:</p><p class="math-container">\[ùêØ^T = [e^{iùê§¬∑Œ¥_1}, e^{iùê§¬∑Œ¥_2}, ‚Ä¶, e^{iùê§¬∑Œ¥_n}]\]</p><p>Note that we are going to use here the order provided by the function <code>obtain_symmetry_related_hoppings</code> to store this phases.</p><p>Additionally, we will need to assign a free-parameter to each orbital hopping term in the Hamiltonian matrix ‚Äî the ones that afterwards we will tune to replicate the band structure. This vector then will have a length of <span>$\text{len}(Œ¥s) √ó \# ùê™ √ó \# ùê∞ √ó \text{dim}(A) √ó \text{dim}(B)$</span>. In particular this vector will look like this:</p><p class="math-container">\[ùê≠^T = [t(Œ¥_1), ‚Ä¶, t(Œ¥_i), ‚Ä¶, t(Œ¥_n)]\]</p><p>where each <span>$t(Œ¥_i)$</span> represent a collection of free-parameter, one per hopping term inside the hopping distance <span>$Œ¥_i$</span>.</p><p>Then, each term of the Hamiltonian matrix <span>$ùêá_ùê§$</span> can be written as bilinear form in the following way:</p><p class="math-container">\[H_{ùê§,ij}^{Œ±Œ≤} = ùêØ_ùê§^T ùêå_{Œ±Œ≤,ij} ùê≠\]</p><p>where <span>$Œ±Œ≤$</span> indicates the two EBRs considered in the tight-binding term, and, <span>$ùêå_{Œ±Œ≤,ij}$</span> is a numerical matrix that will relate a phase with a free-parameter present on the Hamiltonian matrix term.</p><p>We will, then, work with a set of matrices <span>$\{ ùêå_{Œ±Œ≤,ij} \}_{ij}$</span>, each associated to a pair of EBRs, that will encode the tight-binding Hamiltonian and will allow us to operate with it.</p><p>In the following section, we will show how symmetry operations acts on this set of matrices and how to obtain the constraints they impose on the tight-binding Hamiltonian.</p><h3 id="Symmetry-constraints-in-the-numerical-matrix-ùêå"><a class="docs-heading-anchor" href="#Symmetry-constraints-in-the-numerical-matrix-ùêå">Symmetry constraints in the numerical matrix <span>$ùêå$</span></a><a id="Symmetry-constraints-in-the-numerical-matrix-ùêå-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry-constraints-in-the-numerical-matrix-ùêå" title="Permalink"></a></h3><p>Now we want to deduce how transformations on the Hamiltonian matrix <span>$ùêá_ùê§^{Œ±Œ≤}$</span> translate into the numerical tensor <span>$ùêå_{Œ±Œ≤}$</span>.</p><p>We will start from the condition imposed into the Hamiltonian term:</p><p class="math-container">\[ùêá_{gùó∏}^{Œ±Œ≤} = ùêÉ_ùê§^{Œ±Œ±}(g) ùêá_ùó∏^{Œ±Œ≤} ùêÉ_ùê§^{Œ≤Œ≤,‚Ä†}(g)\]</p><p>Then,</p><p class="math-container">\[ùòÉ_{gùó∏}^T ùêå_{Œ±Œ≤,ij} ùòÅ = ùêÉ_ùê§^{Œ±Œ±}(g) ùòÉ_ùó∏^T ùêå_{Œ±Œ≤,ij} ùòÅ ùêÉ_ùê§^{Œ≤Œ≤,‚Ä†}(g)\]</p><p>Since the representation matrices act on different indices as <span>$ùòÉ$</span> and <span>$ùòÅ$</span>, we can permute them obtaining:</p><p class="math-container">\[ùòÉ^T_{gùó∏} ùêå_{Œ±Œ≤,ij} ùòÅ = ùòÉ^T_ùó∏ ùêÉ_ùê§^{Œ±Œ±}(g) ùêå_{Œ±Œ≤,ij} ùêÉ_ùê§^{Œ≤Œ≤,‚Ä†}(g) ùòÅ\]</p><p>In order to compare both <span>$M$</span> matrices, we need to analyze what is <span>$ùòÉ_{gùó∏}$</span>. As can be seeing above, the <span>$ùòÉ_ùê§$</span> vector is constructed as: <span>$ùòÉ^T_ùó∏ = [e^{iùó∏¬∑Œ¥‚ÇÅ}, e^{iùó∏¬∑Œ¥‚ÇÇ}, ‚Ä¶, e^{iùó∏¬∑Œ¥_n}]$</span>, where <span>$\{ Œ¥_i \}$</span> is a closed orbit. Then, <span>$ùòÉ^T_{gùó∏} = [e^{i(gùó∏)¬∑Œ¥‚ÇÅ}, e^{i(gùó∏)¬∑Œ¥‚ÇÇ}, ‚Ä¶, e^{i(gùó∏)¬∑Œ¥_n}]$</span>. As discussed above, we defined as <span>$(gùó∏)¬∑ùóø ‚â° ([R^{-1}]^T ùó∏)¬∑ùóø = ùê§ ¬∑ (R^{-1} ùê´)$</span>, where <span>$g = \{ R|œÑ \}$</span>, then: <span>$ùòÉ^T_{gùó∏} = [e^{iùó∏¬∑(R‚Åª¬πŒ¥‚ÇÅ)}, e^{iùó∏¬∑(R‚Åª¬πŒ¥‚ÇÇ)}, ‚Ä¶, e^{iùó∏¬∑(R‚Åª¬πŒ¥_n)}]$</span>. Additionally, since <span>$\{ Œ¥_i \}$</span> is a closed orbit, <span>$ùòÉ_{gùó∏}$</span> will be just a permutation of <span>$ùòÉ_ùó∏$</span>, in other words, <span>$ùòÉ_{gùó∏} = œÉ(g) ùòÉ_ùó∏$</span>, with <span>$œÉ(g)$</span> a particular permutation. This permutation is obtained in <code>_permute_symmetry_related_hoppings_under_symmetry_operation</code>, allowing us to operate on the numerical tensor <span>$ùêå_{Œ±Œ≤}$</span> as follows:</p><p class="math-container">\[(œÉ(g) ùòÉ_ùó∏)^T ùêå_{Œ±Œ≤,ij} ùòÅ = ùòÉ^T_ùó∏ ùêÉ_ùê§^{Œ±Œ±}(g) ùêå_{Œ±Œ≤,ij} ùêÉ_ùê§^{Œ≤Œ≤,‚Ä†}(g) ùòÅ \\
ùòÉ^T_ùó∏ œÉ(g)^T ùêå_{Œ±Œ≤,ij} ùòÅ = ùòÉ^T_ùó∏ ùêÉ_ùê§^{Œ±Œ±}(g) ùêå_{Œ±Œ≤,ij} ùêÉ_ùê§^{Œ≤Œ≤,‚Ä†}(g) ùòÅ\]</p><p>Then, performing some algebra we obtain that:</p><p class="math-container">\[ùòÉ^T_ùó∏ \left( œÉ(g)^T ùêå_{Œ±Œ≤,ij} - ùêÉ_ùê§^{Œ±Œ±}(g) ùêå_{Œ±Œ≤,ij} ùêÉ_ùê§^{Œ≤Œ≤‚Ä†}(g) \right) ùòÅ = 0 \\
‚áí \boxed{\left( œÉ(g)^T ùêå_{Œ±Œ≤,ij} - ùêÉ_ùê§^{Œ±Œ±}(g) ùêå_{Œ±Œ≤,ij} ùêÉ_ùê§^{Œ≤Œ≤,‚Ä†}(g) \right) ùòÅ = 0}\]</p><p>This implies that if we compute the null-space of the previous subtraction, we will obtain a set of free-parameter vectors that will fulfill the constrains imposed by unitary operations.</p><p>Notice that this set of vectors will be, in general, complex vector, since the matrices involved will have complex entries. Then, in order to avoid compilations, we will split our free-parameter vector <span>$ùòÅ$</span> into its real and imaginary part, so we can work only with real parameters. This is performed in <code>split_complex</code>. For now on, <span>$ùòÅ^T = [ùòÅ^T_\text{real}, i ùòÅ^T_\text{imag}]$</span>.</p><h2 id="Appendix-A"><a class="docs-heading-anchor" href="#Appendix-A">Appendix A</a><a id="Appendix-A-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix-A" title="Permalink"></a></h2><p>In this appendix we aim to present, develop and compare two of the main conventions present on the literature for Fourier transforms. The two Fourier transform conventions we are going to analyze are:</p><ol><li><strong>Convention 1:</strong> <span>$œÜ^{(1)}_{I,ùê§}(ùê´) ‚â° \sum_ùê≠ e^{iùê§¬∑(ùê≠+ùê™_Œ±)} œï_I(ùê´-ùê≠)$</span></li><li><strong>Convention 2:</strong> <span>$œÜ^{(2)}_{I,ùê§}(ùê´) ‚â° \sum_ùê≠ e^{iùê§¬∑ùê≠} œï_I(ùê´-ùê≠)$</span></li></ol><p>where Convention 1 is the one we have been using in the theory notes and Convention 2 is another one commonly used in the literature and other packages such as <a href="https://www.nature.com/articles/nature23268">Bradlyn <em>et al.</em></a>. This second convention does not includes the position of the orbital <span>$ùê™_Œ±$</span> in the phase factor of the Fourier transform.</p><p>The former is the one used in the <a href="https://www.physics.rutgers.edu/pythtb/">PythTB package</a>, where they claim it to be more suitable for computing topological invariants as <a href="https://en.wikipedia.org/wiki/Geometric_phase">Berry phases</a> or <a href="https://en.wikipedia.org/wiki/Wilson_loop">Wilson loops</a>. The later is more common in the literature since it is not necessary to trace back the extra phase factor. Additionally, as we will see later, the later makes easier to compute the symmetry eigenvalues.</p><p>The arguments of which one is better than the other are out of the scope of this notes, so we are going to focus on developing both of them and pointing out their main differences. The package uses ‚Äî for now ‚Äî Convention 1, since it is more suitable for accounting on the ùê§-dependence, but it also provide several tools to convert its outcome into Convention 2.</p><p>Firstly, we are going to do a similar analysis to the previous one in Convention 1, but now on Convention 2. We are going to analyze the transformation properties of the Bloch functions induced from the orbitals, the effect of this choice on the representation of the Bloch Hamiltonian and its Bloch states. Secondly, we are going to point out the main differences and similarities between both conventions. We aim to point out in which situations one more suitable than the other and when it is irrelevant. Finally, we are going to cover the conversion rules to change to one another ‚Äî which are the ones we implement in this package.</p><h3 id="Transformation-properties-within-Convention-2"><a class="docs-heading-anchor" href="#Transformation-properties-within-Convention-2">Transformation properties within Convention 2</a><a id="Transformation-properties-within-Convention-2-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-properties-within-Convention-2" title="Permalink"></a></h3><p>Firstly, we are going to prove the previous statement: Convention 2 is periodic in reciprocal space, on the contrary, to Convention 1. Let us deduce how a reciprocal lattice translation <span>$ùêÜ$</span> acts on the Bloch functions under Convention 2:</p><p class="math-container">\[œÜ^{(2)}_{I,ùê§+ùêÜ} = \sum_ùê≠ e^{i(ùê§+ùêÜ)¬∑ùê≠} œï_I(ùê´-ùê≠) \\
= \sum_ùê≠ \cancel{e^{iùêÜ¬∑ùê≠}} e^{iùê§¬∑ùê≠} œï_I(ùê´-ùê≠) \\
= œÜ^{(2)}_{I,ùê§}\]</p><p>This implies that the Bloch functions are periodic under reciprocal lattice translations within this convention. This has interesting implications in the computation of some parts of this package, such as, the representation of symmetry operations or symmetry eigenvalues. </p><p>Secondly, let us reproduce the transformation properties of the Bloch functions under symmetry operations <span>$g = \{ R|ùêØ \}$</span> of the space group under Convention 2. Following a similar approach to the one previously developed:</p><p class="math-container">\[g œÜ^{(2)}_{I,ùê§}(ùê´) = \frac{1}{\sqrt{N}} \sum_ùê≠ e^{iùê§¬∑ùê≠} g œï_{I}(ùê´-ùê≠) \\
= \frac{1}{\sqrt{N}} \sum_{ùê≠,J} e^{iùê§¬∑ùê≠} [œÅ(h)]_{JI} œï_J(ùê´-Rùê≠-ùê≠_{Œ≤Œ±}) \\
= \frac{1}{\sqrt{N}} \sum_{ùê≠&#39;,J} e^{iùê§¬∑R^{-1}(ùê≠&#39;-ùê≠_{Œ≤Œ±})} [œÅ(h)]_{JI} œï_J(ùê´-ùê≠&#39;) \\
= e^{-i(g ùê§)¬∑ùê≠_{Œ≤Œ±}} \sum_J [œÅ(h)]_{JI} \frac{1}{\sqrt{N}} \sum_{ùê≠&#39;} e^{i(g ùê§)¬∑ùê≠&#39;} œï_J(ùê´-ùê≠&#39;) \\
= e^{-i(g ùê§)¬∑ùê≠_{Œ≤Œ±}} \sum_J [œÅ(h)]_{JI} œÜ^{(2)}_{J,g ùê§}(ùê´),\]</p><p>where we made the substitution <span>$ùê≠&#39; = Rùê≠ + ùê≠_{Œ≤Œ±}$</span>, and used the definition stated before: <span>$gùê§ ‚â° [R^{-1}]^T ùê§$</span>.</p><p>Similarly as before, we can define a representation matrix <span>$ùêÉ^{(2)}_ùê§(g)$</span> whose entries are <span>$[ùêÉ^{(2)}_ùê§(g)]_{IJ} = e^{-i(gùê§)¬∑ùê≠_{Œ≤Œ±}} [œÅ(h)]_{IJ}$</span>, where <span>$I = (i,Œ±)$</span> and <span>$J = (j,Œ≤)$</span>. Then, the previous expression reduces to:</p><p class="math-container">\[g œÜ^{(2)}_{I,ùê§}(ùê´) = \sum_j [ùêÉ^{(2)}_ùê§(g)]_{JI} œÜ^{(2)}_{jŒ≤,gùê§}(ùê´)\]</p><p>Notice that the representation matrix for the space group operations differs between conventions, i.e., <span>$ùêÉ^{(1)}_ùê§(g) ‚â† ùêÉ^{(2)}_ùê§(g)$</span>. The representation under Convention 1 depends on the translational part <span>$ùêØ$</span>, as shown before, meanwhile, under Convention 2, it presents not on a global phase factor, but on a local phase factor depending on <span>$ùê≠_{Œ≤Œ±}$</span>.</p><p>The next step will be to build a tight-binding model using this set of functions as a basis. For that, in the following section, we will follow the same steps as in Convention 1 by introducing the creation and annihilation operators associated to such functions, and how the Bloch Hamiltonian will look like.</p><h3 id="Bloch-Hamiltonian-under-Convention-2"><a class="docs-heading-anchor" href="#Bloch-Hamiltonian-under-Convention-2">Bloch Hamiltonian under Convention 2</a><a id="Bloch-Hamiltonian-under-Convention-2-1"></a><a class="docs-heading-anchor-permalink" href="#Bloch-Hamiltonian-under-Convention-2" title="Permalink"></a></h3><p>We want to use the previously introduced Bloch functions as a basis to construct a Bloch Hamiltonian in reciprocal space. Once again, we start from the most general tight-binding Hamiltonian, which, as we described, can be written as:</p><p class="math-container">\[ƒ§ = \sum_{IJ,ùêëùê≠} h_{IJ,ùêë} ƒâ^‚Ä†_{I,ùê≠+ùêë} ƒâ_{J,ùê≠}\]</p><p>Since we want to use the previous Bloch functions as a basis, we have to introduce a set of creation and annihilation operators that are consistent with the convention choice ‚Äî Convention 2 in this case. This is satisfied by the following relation:</p><p class="math-container">\[\hat{b}_{I,ùê§}^‚Ä† = \frac{1}{\sqrt{N}} \sum_ùê≠ e^{iùê§¬∑ùê≠} ƒâ_{I,ùê≠}^‚Ä†,\]</p><p>where we have used <span>$\hat{b}$</span> as the notation for the operators under this new convention. It is interesting to notice that you can obtain one from the other by using the following relation:</p><p class="math-container">\[\hat{b}_{I,ùê§}^‚Ä† = e^{-iùê§¬∑ùê™_Œ±} √¢_{I,ùê§}^‚Ä†\]</p><p>Introducing the previous transformation into the tight-binding Hamiltonian we obtain that:</p><p class="math-container">\[ƒ§ = \sum_{IJ,ùêë,ùê§} h_{IJ,ùêë} e^{iùê§¬∑ùêë} \hat{b}_{I,ùê§}^‚Ä† \hat{b}_{J,ùê§}\]</p><p>If we define <span>$h^{(2)}_{IJ,ùê§} = \sum_ùêë h_{IJ,ùêë} e^{iùê§¬∑ùêë}$</span>, we obtain the usual expression for a tight-binding Hamiltonian in reciprocal space:</p><p class="math-container">\[ƒ§ = \sum_{IJ,ùê§} h^{(2)}_{IJ,ùê§} \hat{b}_{I,ùê§}^‚Ä† \hat{b}_{J,ùê§}\]</p><p>From here, we can define the Bloch Hamiltonian which will be the diagonal part of the Hamiltonian in reciprocal space, i.e.:</p><p class="math-container">\[ƒ§_ùê§ = \sum_{IJ} h^{(2)}_{IJ,ùê§} \hat{b}_{I,ùê§}^‚Ä† \hat{b}_{J,ùê§}\]</p><p>Considering that now the Bloch functions are periodic it is easier to prove that the Bloch Hamiltonian is periodic also, but, nevertheless, we are going to prove it. Firstly, let us examine how the creation operator transform under a reciprocal lattice translation:</p><p class="math-container">\[\hat{b}_{I,ùê§+ùêÜ}^‚Ä† = \frac{1}{\sqrt{N}} \sum_ùê≠ e^{i(ùê§+ùêÜ)¬∑ùê≠} ƒâ_{I,ùê≠}^‚Ä† \\
= \frac{1}{\sqrt{N}} \sum_ùê≠ \cancel{e^{iùêÜ¬∑ùê≠}} e^{iùê§¬∑ùê≠} ƒâ_{I,ùê≠}^‚Ä† \\
= \hat{b}_{I,ùê§}^‚Ä†\]</p><p>Secondly, let us study how the coefficients transform under a reciprocal lattice translation:</p><p class="math-container">\[h^{(2)}_{IJ,ùê§+ùêÜ} = \sum_ùêë h_{IJ,ùêë} e^{i(ùê§+ùêÜ)¬∑ùêë} \\
= \sum_ùêë h_{IJ,ùêë} \cancel{e^{iùêÜ¬∑ùêë}} e^{iùê§¬∑ùêë} \\
= h^{(2)}_{IJ,ùê§}\]</p><p>As can be seen, all the components are periodic within this convention. This is the common reason why it is heavily used in the literature. Proving now the translational invariance of the Bloch Hamiltonian:</p><p class="math-container">\[ƒ§_{ùê§+ùêÜ} = \sum_{IJ} h^{(2)}_{IJ,ùê§+ùêÜ} \hat{b}_{I,ùê§+ùêÜ}^‚Ä† \hat{b}_{J,ùê§+ùêÜ} \\
= \sum_{IJ} h^{(2)}_{IJ,ùê§} \hat{b}_{I,ùê§}^‚Ä† \hat{b}_{J,ùê§} = ƒ§_ùê§\]</p><p>This is an important property since the eigenvalues of this Bloch Hamiltonian, which correspond to the energies of the Bloch states of the system, must be periodic in reciprocal space, allowing us to restrict to the first Brillouin zone. Additionally, since the representation matrix <span>$ùêá^{(2)}_ùê§$</span> is now periodic by itself, the eigenvectors <span>$ùê∞^{(2)}_{nùê§}$</span> will also be periodic. This has important implications, for example, when computing the symmetry eigenvalues.</p><p>Before studying the transformation properties of the Bloch states, we want to mention that the creation and annihilation operators and the Bloch Hamiltonian within this convention will have the same transformation properties under symmetry operations but now using the representation matrix of the operations <span>$ùêÉ^{(2)}_ùê§$</span> associated to Convention 2.</p><h4 id="Bloch-states-under-Convention-2"><a class="docs-heading-anchor" href="#Bloch-states-under-Convention-2">Bloch states under Convention 2</a><a id="Bloch-states-under-Convention-2-1"></a><a class="docs-heading-anchor-permalink" href="#Bloch-states-under-Convention-2" title="Permalink"></a></h4><p>Let us now jump into the transformation properties of the Bloch states. The Bloch states are represented using the basis obtained by Convention 2 as:</p><p class="math-container">\[\ket{œà_{nùê§}} = \sum_I w^{(2)}_{I,nùê§} \ket{œÜ^{(2)}_{I,ùê§}} = \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w^{(2)}_{I,nùê§} e^{iùê§¬∑(ùê≠+ùê™_Œ±)} \ket{œï_{I,ùê≠}}\]</p><p>Let us first study how the Bloch states transform under lattice translations in real and reciprocal space and, then, deduce how they transform under more complex symmetry operations.</p><h5 id="Transformation-under-lattice-translations"><a class="docs-heading-anchor" href="#Transformation-under-lattice-translations">Transformation under lattice translations</a><a id="Transformation-under-lattice-translations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformation-under-lattice-translations" title="Permalink"></a></h5><p>Firstly, we are going to consider lattice translations in real space. This can be obtained by:</p><p class="math-container">\[œà_{nùê§}(ùê´+ùêë) = \braket{ùê´+ùêë|œà_{nùê§}} \\
= \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w^{(2)}_{I,nùê§} e^{iùê§¬∑ùê≠} \braket{ùê´+ùêë|œï_{n,ùê≠}} \\
= \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w^{(2)}_{I,nùê§} e^{iùê§¬∑ùê≠} \braket{ùê´|œï_{n,ùê≠-ùêë}} \\
= e^{iùê§¬∑ùêë} \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w^{(2)}_{I,nùê§} e^{iùê§¬∑(ùê≠-ùêë)} \braket{ùê´|œï_{n,ùê≠-ùêë}} \\
= e^{iùê§¬∑ùêë} \braket{ùê´|œà_{nùê§}} = e^{iùê§¬∑ùêë} œà_{nùê§}(ùê´)\]</p><p>The Bloch states transform as Bloch functions under translations in real space, as expected.</p><p>Secondly, let us analyze how they transform under reciprocal lattice translations. Remind that the matrix representation <span>$ùêá^{(2)}_ùê§$</span> is periodic under reciprocal lattice translations. This implies that <span>$ùê∞^{(2)}_{n,ùê§+ùêÜ} = ùê∞^{(2)}_{n,ùê§}$</span>, and <span>$E_{n,ùê§+ùêÜ} = E_{n,ùê§}$</span>, i.e., they are periodic under reciprocal lattice translations.</p><p>Let us deduce how Bloch states will transform under reciprocal lattice translations:</p><p class="math-container">\[\ket{œà_{n,ùê§+ùêÜ}} = \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w^{(2)}_{In,ùê§+ùêÜ} e^{i(ùê§+ùêÜ)¬∑ùê≠} \ket{œï_{I,ùê≠}} \\
= \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w^{(2)}_{In,ùê§} \cancel{e^{iùêÜ¬∑ùê≠}} e^{iùê§¬∑ùê≠} \ket{œï_{I,ùê≠}} \\
= \frac{1}{\sqrt{N}} \sum_{I,ùê≠} w^{(2)}_{In,ùê§} e^{iùê§¬∑ùê≠} \ket{œï_{I,ùê≠}} = \ket{œà_{nùê§}}\]</p><p>The Bloch states will remain invariant under reciprocal lattice translations, as it should be.</p><h5 id="Transformation-properties-under-symmetry-operations-2"><a class="docs-heading-anchor" href="#Transformation-properties-under-symmetry-operations-2">Transformation properties under symmetry operations</a><a class="docs-heading-anchor-permalink" href="#Transformation-properties-under-symmetry-operations-2" title="Permalink"></a></h5><p>Here we analyze how the Bloch states transform under more complex symmetry operations <span>$g = \{R|ùêØ\}$</span> that might involve translations <span>$ùêØ$</span> and site-symmetry operations <span>$R$</span>. The Bloch state will transform under this operations as:</p><p class="math-container">\[ƒù \ket{œà_{nùê§}} = \sum_I w^{(2)}_{I,nùê§} ƒù \ket{œÜ^{(2)}_{I,ùê§}} \\
= \sum_{IJ} w^{(2)}_{I,nùê§} [ùêÉ^{(2)}_ùê§(g)]_{JI} \ket{œÜ^{(2)}_{J,gùê§}} \\
= \sum_{IJ} [ùêÉ^{(2)}_ùê§(g)]_{JI} w^{(2)}_{I,nùê§} \ket{œÜ^{(2)}_{J,gùê§}}\]</p><p>We are particularly interested in the transformation under operations <span>$ƒù$</span> in the little-group <span>$G_ùê§$</span> of a particular ùê§-point. This operations will leave invariant the particular ùê§-point up to a lattice translation, i.e., <span>$g ùê§ = ùê§ + ùêÜ$</span>. How these functions transform under those operation at each high-symmetry point will allow us to assign an irrep to each of the Bloch states at that ùê§-point. Those should coincide with the ones obtained from the original system&#39;s band structure. The irrep could be assigned by computing the symmetry eigenvalues associated to each Bloch state. Those are compute by:</p><p class="math-container">\[\braket{œà_{nùê§}|ƒù|œà_{nùê§}} = \sum_{IJ} (w^{(2)}_{I,nùê§})^* w^{(2)}_{J,nùê§} \braket{œÜ^{(2)}_{I,ùê§}|ƒù|œÜ^{(2)}_{J,ùê§}} \\
= \sum_{IJJ&#39;} (w^{(2)}_{I,nùê§})^* w^{(2)}_{J,nùê§} [ùêÉ^{(2)}_ùê§(g)]_{J&#39;J} \braket{œÜ^{(2)}_{I,ùê§}|œÜ^{(2)}_{J&#39;,gùê§}} \\
= \sum_{IJJ&#39;} (w^{(2)}_{I,nùê§})^* w^{(2)}_{J,nùê§} [ùêÉ^{(2)}_ùê§(g)]_{J&#39;J} \braket{œÜ^{(2)}_{I,ùê§}|œÜ^{(2)}_{J&#39;,ùê§+ùêÜ}} \\
= \sum_{IJJ&#39;} (w^{(2)}_{I,nùê§})^* w^{(2)}_{J,nùê§} [ùêÉ^{(2)}_ùê§(g)]_{J&#39;J} \braket{œÜ^{(2)}_{I,ùê§}|œÜ^{(2)}_{J&#39;,ùê§}} \\
= \sum_{IJJ&#39;} (w^{(2)}_{I,nùê§})^* w^{(2)}_{J,nùê§} [ùêÉ^{(2)}_ùê§(g)]_{J&#39;J} Œ¥_{IJ&#39;} \\
= \sum_{IJ} (w^{(2)}_{I,nùê§})^* [ùêÉ^{(2)}_ùê§(g)]_{IJ} w^{(2)}_{J,nùê§}\]</p><p>Notice that this expression differs from the previous one due to a phase factor. This is the main reason why some authors decided to use Convention 2 instead Convention 1: it is not necessary to account for phase factors in the symmetry eigenvalues computations.</p><p>Nevertheless, it is interesting to be able to consider both conventions and that is why, in the next section, we develop conversion properties between the two conventions for several convention-dependent expressions.</p><h3 id="Conversions-between-Convention-1-and-2"><a class="docs-heading-anchor" href="#Conversions-between-Convention-1-and-2">Conversions between Convention 1 and 2</a><a id="Conversions-between-Convention-1-and-2-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions-between-Convention-1-and-2" title="Permalink"></a></h3><p>First, let us start with the conversion between the Bloch functions that the different Fourier transformations induce. Since there is just an additional phase factor, we can convert from one convention to the other by adding that extra factor as:</p><p class="math-container">\[\ket{œÜ^{(2)}_{I,ùê§}} = e^{-iùê§¬∑ùê™_Œ±} \ket{œÜ^{(1)}_{I,ùê§}}\]</p><p>Obviously, the creation and annihilation operators convert in a similar fashion; in particular, as stated previously:</p><p class="math-container">\[\hat{b}_{I,ùê§}^‚Ä† = e^{-iùê§¬∑ùê™_Œ±} √¢_{I,ùê§}^‚Ä†\]</p><p>Second, the Hamiltonian must be invariant independently of the basis used to define it. Considering this, we can deduce how the matrix <span>$ùêá_ùê§$</span>, which is representation dependent, converts from one convention to the other. Let us start with the Bloch Hamiltonian:</p><p class="math-container">\[ƒ§_ùê§ = \sum_{IJ} h^{(1)}_{IJ,ùê§} √¢_{I,ùê§}^‚Ä† √¢_{J,ùê§} \\
= \sum_{IJ} e^{iùê§¬∑ùê™_Œ±} h^{(1)}_{IJ,ùê§} e^{-iùê§¬∑ùê™_Œ≤} \hat{b}_{I,ùê§}^‚Ä† \hat{b}_{J,ùê§} \\
‚áí h^{(2)}_{IJ,ùê§} = e^{iùê§¬∑ùê™_Œ±} h^{(1)}_{IJ,ùê§} e^{-iùê§¬∑ùê™_Œ≤}\]</p><p>This allows us to convert from one representation matrix of the Hamiltonian to the other. It is convenient to rewrite the previous relation in matrix form, which is:</p><p class="math-container">\[ùêá^{(2)}_ùê§ = Œò^‚Ä†_ùê§ ùêá^{(1)}_ùê§ Œò_ùê§,\]</p><p>where <span>$Œò_ùê§$</span> is a diagonal matrix containing the phase factor as defined previously: <span>$[Œò_ùê§]_{II} = e^{-iùê§¬∑ùê™_Œ±}$</span>. This relation allows us to transform from one representation of the Bloch Hamiltonian into the other.</p><p>Finally, we are interested in deducing the conversion properties of the eigenvectors obtained from diagonalizing the representation matrix <span>$ùêá_ùê§$</span>. Since <span>$ùêá^{(1)}_ùê§$</span> and <span>$ùêá^{(2)}_ùê§$</span> are related by a change of basis, the eigenvectors of both can be related to each other as:</p><p class="math-container">\[ùê∞^{(2)}_{nùê§} = Œò^‚Ä†_ùê§ ùê∞^{(1)}_{nùê§}\]</p><p>With these relations we are able to go back and forth from one convention to the other, making it possible to use both depending on which is most suitable for each case.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>An equivalent casting of the same result is <span>$\braket{œà_{nùê§}|ƒù|œà_{nùê§}} = ùê∞_{nùê§}^\dagger (Œò_{-ùêÜ} ùêÉ_ùê§(g) ùê∞_{nùê§})$</span>, showing that <span>$Œò_{-ùêÜ}ùêÉ_ùê§(g)$</span> acts as the representation in the coefficient basis.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internal-api/">¬´ Internal API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 14 August 2025 14:22">Thursday 14 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
