var documenterSearchIndex = {"docs":
[{"location":"internal-api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"This page lists unexported functionality from SymmetricTightBinding.jl that may be of interest to developers.","category":"page"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"","category":"page"},{"location":"internal-api/#Unexported,-internal-functionality","page":"Internal API","title":"Unexported, internal functionality","text":"","category":"section"},{"location":"internal-api/#SymmetricTightBinding.OrbitalOrdering-Union{Tuple{Crystalline.NewBandRep{D}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.OrbitalOrdering","text":"OrbitalOrdering(br::NewBandRep{D}) --> OrbitalOrdering{D}\n\nEstablishes a canonical, local ordering for the orbitals associated to a band representation br. This is the default ordering used when associating row/column indices in a tight-binding Hamiltonian block to specific orbitals in the associated band representations.\n\nThe canonical orbital ordering is stored in .ordering. The ith elements of ordering, ordering[i], is a NamedTuple with two fields: wp and idx:\n\nwp: stores a Wyckoff position in the orbit of the Wyckoff position associated to br.wp.\nidx: stores the index of the partner function of the site-symmetry irrep associated to br at wp.\n\nI.e., the ith orbital associated to br is located at wp and transforms as the idxth partner function of the site-symmetry irrep of br.siteir. The total number of orbitals associated to a band representation, and hence the length of ordering, is the product of the site-symmetry irrep dimensionality and the number of sites in the Wyckoff position orbit.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.SiteInducedSGRepElement","page":"Internal API","title":"SymmetricTightBinding.SiteInducedSGRepElement","text":"SiteInducedSGRepElement{D}(\n    œÅ::AbstractMatrix,\n    positions::Vector{DirectPoint{D}},\n    op::SymOperation{D}\n)\n\nRepresents a matrix-valued element of a site-induced representation of a space group, including a global momentum-dependent phase factor.\n\nThis structure behaves like a functor: calling it with a momentum k :: AbstractVector  returns the matrix representation at k.\n\nFields (internal)\n\nœÅ :: Matrix{ComplexF64} : The momentum-independent matrix part of the representation.\npositions :: Vector{DirectPoint{D}}: Real-space positions corresponding to the orbitals in the orbit of the associated site-symmetry group.\n\n\n\n\n\n","category":"type"},{"location":"internal-api/#SymmetricTightBinding._maybe_add_hoppings!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding._maybe_add_hoppings!","text":"Computes and adds the symmetry related partners of a hopping term Œ¥ to the Œ¥_orbit.\n\nwarning: Warning\nThis function is an internal helper function for maybe_add_hoppings! and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._permute_symmetry_related_hoppings_under_symmetry_operation-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.SymOperation{D}}} where D","page":"Internal API","title":"SymmetricTightBinding._permute_symmetry_related_hoppings_under_symmetry_operation","text":"Build the P matrix for a particular symmetry operation acting on k-space, which permutes the rows of the M matrix.\n\nFor obtaining the P matrix, we make use that the action is on exponential of the type: ùêûxp(2œÄkŒ¥), to instead act on Œ¥ ‚àà h_orbit.orbit instead of k, which is a symbolic variable. Because of that, we need to use the inverse of the rotation part of the symmetry operation.\n\ndetails: Sketch of proof\nAssume g={R|œÑ} and Crystalline implements gk=(R‚Åª¬π)·µÄk. Then (gk)‚ãÖŒ¥ = ((R‚Åª¬π)·µÄk)‚ãÖŒ¥ + œÑ = k‚ãÖ(R‚Åª¬π)Œ¥.\n\ninfo: Info\nIt is assumed that the operation op is provided in a primitive setting.\n\nwarning: Warning\nThis function is an internal helper function for reciprocal_constraints_matrices and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._poormans_sparsification-Tuple{AbstractMatrix{<:Number}}","page":"Internal API","title":"SymmetricTightBinding._poormans_sparsification","text":"Poor man's \"matrix sparsification\" via the reduced row echelon form.\n\nwarning: Warning\nThis function is an internal helper function for obtain_basis_free_parameters and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._prune_at_threshold!-Union{Tuple{AbstractVector{<:AbstractVector{T}}}, Tuple{T}} where T<:Complex","page":"Internal API","title":"SymmetricTightBinding._prune_at_threshold!","text":"Prune near-zero elements of vectors in vs.\n\nwarning: Warning\nThis function is an internal helper function for obtain_basis_free_parameters and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.add_timereversal_related_orbits!-Union{Tuple{Array{HoppingOrbit{D}, 1}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.add_timereversal_related_orbits!","text":"add_timereversal_related_orbits!(h_orbits::Vector{HoppingOrbit{D}}) where {D}\n\nAdds the time-reversed hopping terms to the hopping orbits in h_orbits. The time-reversed hopping terms are added to the orbit of the hopping term they are related to, and if they are already present in another orbit, the two orbits are merged.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.construct_M_matrix-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.construct_M_matrix","text":"construct_M_matrix(\n    h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D},\n    [ordering1, ordering2]) \n    --> Array{Int,4}\n\nConstruct a set of matrices that encodes a Hamiltonian's term which resembles the hopping from EBR br1 to EBR br2.\n\nThe encoding is stored as a 4D matrix. Its last two axes correspond to elements of the Bloch Hamiltonian H(k); its first axis corresponds to orbit(h_orbit) and the associated complex exponentials stored in v; and its second axis to the elements of the vector t. That is:\n\nH‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º\n\nSee devdocs.md for details.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.evaluate_tight_binding_term!-Union{Tuple{D}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Union{Nothing, Number}}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Union{Nothing, Number}, Matrix{ComplexF64}}} where D","page":"Internal API","title":"SymmetricTightBinding.evaluate_tight_binding_term!","text":"evaluate_tight_binding_term!(tbt::TightBindingTerm, k, [c, H])\n\nEvaluate the tight-binding term tbt at momentum k, possibly multiplied by a scalar coefficient c (unity if omitted). The term is added into the scratch space matrix H; if H is not provided, it is initialized as a zero matrix of the appropriate size.\n\nThe function returns the modified H matrix.\n\nNote\n\nThe two-argument form of the function, i.e., returning the value of tbt at k, can be more simply achieved via tbt(k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.inversion-Tuple{Val{3}}","page":"Internal API","title":"SymmetricTightBinding.inversion","text":"inversion(::Val{D}) --> SymOperation{D}\n\nReturn the inversion operation in dimension D.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.maybe_add_hoppings!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding.maybe_add_hoppings!","text":"maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops) --> Vector{HoppingOrbit{D}}\n\nChecks if a hopping term Œ¥ is already in the list of representatives. If not, it adds it and its symmetry related partners. If it is, it only adds the symmetry related partners.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters","text":"obtain_basis_free_parameters(\n    h_orbit::HoppingOrbit{D},\n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D}, \n    [ordering‚Çê = OrbitalOrdering(br‚Çê), ordering·µ¶ = OrbitalOrdering(br·µ¶)]\n    )                            --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}\n\nObtain the basis of free parameters for the hopping terms between br‚Çê and br·µ¶  associated with the hopping orbit h_orbit.\n\nNote\n\nThe presence or absence of time-reversal symmetry is inferred implicitly from br‚Çê and br·µ¶.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters_TRS-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}, AbstractArray{Int64, 4}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters_TRS","text":"obtain_basis_free_parameters_TRS(\n    h_orbit::HoppingOrbit{D}, \n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D}, \n    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),\n    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶),\n    Mm::AbstractArray{4, Int} = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶)\n    )                             --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}}\n\nObtain the basis of free parameters for the hopping terms between br‚Çê and br·µ¶ associated with the hopping orbit h_orbit under time-reversal symmetry.\n\nReal and imaginary parts of the basis vectors are differentiated explicitly: internally, we consider only variables.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters_hermiticity-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}, AbstractArray{Int64, 4}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters_hermiticity","text":"obtain_basis_free_parameters_hermiticity(\n    h_orbit::HoppingOrbit{D},\n    br‚Çê::NewBandRep{D},\n    br·µ¶::NewBandRep{D},\n    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),\n    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶),\n    Mm::AbstractArray{Int, 4} = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶);\n    antihermitian::Bool = false,\n) where {D}\n\nConstructs a basis for the coefficient vectors t‚ÅΩ‚Åø‚Åæ that span the space of Hermitian (or antihermitian if true) TB Hamiltonians H‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º = v·µÄ(k) M‚ÅΩÀ¢·µó‚Åæ t. We do this by assuming that each coefficient vector t is sorted into a vector of the form [t·¥ø; it·¥µ] so that we can take the complex conjugate by as t* = œÉ‚ÇÉt, which can then be moved onto M‚ÅΩÀ¢·µó‚Åæ instead of t. The constraint H‚Çõ‚Çú(k) = (H‚Ä†)‚Çõ‚Çú(k) = H‚Çú‚Çõ*(k) can then be expressed as v·µÄ(k) M‚ÅΩÀ¢·µó‚Åæ t‚±º = v*·µÄ(k) M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ t = v·µÄ(k) (P·µÄ M‚ÅΩ·µóÀ¢‚ÅæœÉ‚ÇÉ) t, which requires that t be a solution to the nullspace M‚ÅΩÀ¢·µó‚Åæ - P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ = 0. We cast this as Z - Q = 0, with Z = M‚ÅΩÀ¢·µó‚Åæ and Q = P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ.\n\nNotes\n\nFor anti-Hermitian symmetry, we require H‚Çõ‚Çú(k) = -H‚Çú‚Çõ*(k), which translates to M‚ÅΩÀ¢·µó‚Åæ + P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ = 0; i.e., simply swaps the sign of Q\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.pin_free-Union{Tuple{D}, Tuple{Crystalline.NewBandRep{D}, AbstractVector{<:Real}}} where D","page":"Internal API","title":"SymmetricTightBinding.pin_free","text":"pin_free(br::NewBandRep{D}, Œ±Œ≤Œ≥::AbstractVector{<:Real}) where D\n\nPin the free parameters of the Wyckoff position associated with the band representation br to the values in Œ±Œ≤Œ≥. \n\nReturns a new band representation with all other properties, apart from the Wyckoff position, identical to (and sharing memory with) br.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.primitivized_orbit-Union{Tuple{Crystalline.NewBandRep{D}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.primitivized_orbit","text":"primitivized_orbit(br::NewBandRep{D}) where D\n\nReturn the orbit of the Wyckoff position associated with the band representation br. The coordinates of positions in the orbit are given relative to the primitive unit cell.\n\nPositions are returned as a Vector{DirectPoint{D}}.\n\nThe following checks are made, producing an error if violated:\n\nThere are no free parameters associated with the Wyckoff position.\nFor every position, its coordinates, referred to the primitive basis, is in the range [0,1); i.e., every position lies in the parallepiped primitive unit cell [0,1)·¥∞.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.reciprocal_constraints_matrices-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, AbstractArray{Crystalline.SymOperation{D}, 1}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.reciprocal_constraints_matrices","text":"reciprocal_constraints_matrices(\n                                Mm::AbstractArray{Int,4}, \n                                gens::AbstractVector{SymOperation{D}}, \n                                h_orbit::HoppingOrbit{D}\n                                ) --> Vector{Array{Int,4}}\n\nCompute the reciprocal constraints matrices for the generators of the SG. This is done by permuting the rows of the M matrix according to the symmetry operation acting on k-space. See more details in permute_symmetry_related_hoppings_under_symmetry_operation and devdocs.md.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.reciprocal_constraints_trs-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.reciprocal_constraints_trs","text":"reciprocal_constraints_trs(Mm::AbstractArray{Int,4}, h_orbit::HoppingOrbit{D}) \n--> Array{ComplexF64,4}\n\nTime reversal symmetry action on reciprocal space. It is given by the association  k -> -k => H(k) -> H(-k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.representation_constraint_matrices-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding.representation_constraint_matrices","text":"representation_constraints_matrices(\n    Mm::AbstractArray{Int,4}, \n    br‚Çê::NewBandRep{D},\n    br·µ¶::NewBandRep{D}) --> Vector{Array{ComplexF64,4}}\n\nBuild the Q matrix for a particular symmetry operation (or, equivalently, a particular matrix from the site-symmetry representation), acting on the M matrix. Relative to our white-board notes, Q has swapped indices, in the sense we below give Q[i,j,r,l].\n\n(œÅ‚Çê‚Çê)·µ£‚Çõ H‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ v·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = v·µ¢ (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó t‚±º,\n\nthen we can define: Q·µ¢‚±º·µ£‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.representation_constraint_trs-Union{Tuple{D}, Tuple{AbstractArray{<:Number, 4}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.representation_constraint_trs","text":"representation_constraint_trs(Mm::AbstractArray{Int,4}, h_orbit::HoppingOrbit{D})\n--> Array{ComplexF64,4}\n\nTime reversal symmetry action on the Hamiltonian. It is given by the association Œ¥ -> -Œ¥ and  the complex conjugation in the free-parameter part: t‚±º - t‚±º*  t‚±º·¥ø it‚±º·¥µ - t‚±º·¥ø -it‚±º·¥µ  H(k) - H*(k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.sgrep_induced_by_siteir_excl_phase-Union{Tuple{D}, Tuple{Crystalline.NewBandRep{D}, Crystalline.SymOperation{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.sgrep_induced_by_siteir_excl_phase","text":"sgrep_induced_by_siteir_excl_phase(br::NewBandRep, op::SymOperation)\nsgrep_induced_by_siteir_excl_phase(cbr::CompositeBandRep, op::SymOperation)\n    --> Matrix{ComplexF64}\n\nReturn the representation matrix of a symmetry operation op induced by the site symmetry group of a band representation br or composite band representation cbr, excluding the global momentum-dependent phase factor.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.split_complex-Tuple{AbstractVector{<:Number}}","page":"Internal API","title":"SymmetricTightBinding.split_complex","text":"split_complex(t::Vector{<:Number}) -> Matrix{Real}\n\nConsider Œ±t where Œ± ‚àà ‚ÑÇ and t ‚àà ‚ÑÇ‚Åø and build from t a matrix representation T that allows access to the real and imaginary parts of the product Œ±t without using complex numbers by splitting Œ± into a real 2-vector of its real and imaginary parts.\n\nIn particular, let Œ± = Œ±·¥ø + iŒ±·¥µ and t = t·¥ø + it·¥µ with Œ±·¥ø, Œ±·¥µ ‚àà ‚Ñù and t·¥ø t·¥µ  ‚Ñù‚Åø, then Œ±t can be rewritten as\n\nŒ±t = (Œ±·¥ø + iŒ±·¥µ)(t·¥ø + it·¥µ)\n   = (Œ±·¥øt·¥ø - Œ±·¥µt·¥µ) + i(Œ±·¥øt·¥µ + Œ±·¥µt·¥ø)\n   = t·¥ø t·¥µ·µÄ Œ±·¥ø Œ±·¥µ + i t·¥µ t·¥ø·µÄ Œ±·¥ø Œ±·¥µ\n\nThen, defining T = [t·¥ø -t·¥µ; t·¥µ t·¥ø], the above product can then be reexpressed as: Re(Œ±t) = Œ±·¥øt·¥ø - Œ±·¥µt·¥µ = (T * [Œ±·¥ø; Œ±·¥µ])[1:n] and Im(Œ±t) = Œ±·¥øt·¥µ + Œ±·¥µt·¥ø = (T * [Œ±·¥ø; Œ±·¥µ])[n+1:2n]. I.e., the \"upper half\" of the product T * [real(Œ±), imag(Œ±)] is real(Œ± * t) and the  \"lower half\" is imag(Œ±t).\n\nThis functionality is used to avoid complex numbers in amplitude basis coefficients, which simplifies the application of time-reversal symmetry and hermiticity.\n\nExamples\n\njulia> using SymmetricTightBinding: split_complex\n\njulia> t = [im,0]\n2-element Vector{Complex{Int64}}:\n 0 + 1im\n 0 + 0im\n\njulia> T = split_complex(t)\n4√ó2 Matrix{Int64}:\n 0  -1\n 0   0\n 1   0\n 0   0\n\njulia> Œ± = 0.5+0.2im; Œ±v = [real(Œ±), imag(Œ±)];\n\njulia> (T * Œ±v)[1:2] == real(Œ±*t) && (T * Œ±v)[3:4] == imag(Œ±*t)\n\njulia> t = [1,im]\n2-element Vector{Complex{Int64}}:\n 1 + 0im\n 0 + 1im\n\njulia> split_complex(t)\n4√ó2 Matrix{Int64}:\n 1   0\n 0  -1\n 0   1\n 1   0\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.zassenhaus_intersection-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, Real}} where T<:Number","page":"Internal API","title":"SymmetricTightBinding.zassenhaus_intersection","text":"zassenhaus_intersection(U::AbstractArray{<:Number}, W::AbstractArray{<:Number}) \n    --> AbstractArray{<:Number}\n\nFinds the intersection of two bases U and W using the Zassenhaus algorithm. It assumes that the basis are given by columns.\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Zassenhaus_algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#Crystalline.collect_compatible-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, Vararg{Any}}} where D","page":"API","title":"Crystalline.collect_compatible","text":"collect_compatible(ptbm::ParameterizedTightBindingModel{D}; multiplicities_kws...)\n\nDetermine a decomposition of the bands associated with ptbm into a set of SymmetryVectors, with each symmetry vector corresponding to a set of compatibility-respecting (i.e., energy separable along high-symmetry k-lines) bands.\n\nKeyword arguments\n\nmultiplicities_kws...: keyword arguments passed to Crystalline.collect_compatible used in determining the multiplicities of irreps across high-symmetry k-points.\n\nExample\n\njulia> using Crystalline, SymmetricTightBinding\n\njulia> brs = calc_bandreps(221);\n\njulia> cbr = @composite brs[1] + brs[2]\n40-irrep CompositeBandRep{3}:\n (3d|A‚ÇÅg) + (3d|A‚ÇÅ·µ§) (6 bands)\n\njulia> tbm = tb_hamiltonian(cbr); # a 4-term, 6-band model\n\njulia> ptbm = tbm([1.0, 0.1, -1.0, 0.1]); # fix free coefficients\n\njulia> collect_compatible(ptbm)\n2-element Vector{SymmetryVector{3}}:\n [M‚ÇÖ‚Å∫+M‚ÇÅ‚Åª, X‚ÇÉ‚Å∫+X‚ÇÅ‚Åª+X‚ÇÇ‚Åª, Œì‚ÇÅ‚Åª+Œì‚ÇÉ‚Åª, R‚ÇÑ‚Å∫] (3 bands)\n [M‚ÇÅ‚Å∫+M‚ÇÖ‚Åª, X‚ÇÅ‚Å∫+X‚ÇÇ‚Å∫+X‚ÇÉ‚Åª, Œì‚ÇÅ‚Å∫+Œì‚ÇÉ‚Å∫, R‚ÇÑ‚Åª] (3 bands)\n\nIn the above example, the bands separate into two symmetry vectors, one for each of the original EBRs in cbr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.collect_irrep_annotations-Tuple{ParameterizedTightBindingModel}","page":"API","title":"Crystalline.collect_irrep_annotations","text":"collect_irrep_annotations(ptbm::ParameterizedTightBindingModel; kws...)\n\nCollect the irrep labels across the high-symmetry k-points referenced by the underlying composite band representation of ptbm, across the bands of the model.\n\nUseful for annotating irrep labels in band structure plots (via the Makie extension call plot(ks, energies; annotations=collect_irrep_annotations(ptbm)))\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.complement-Union{Tuple{D}, Tuple{TightBindingModel{D}, Int64}} where D","page":"API","title":"SymmetricTightBinding.complement","text":"complement(tbm::TightBindingModel{D}, sgnum·¥¥::Int; timereversal) --> TightBindingModel{D}\n\nGiven a model tbm associated with a space group G, determine the new, independent tight-binding terms (i.e., the the orthogonal complement of terms) that become  symmetry-allowed when the model's space group is reduced to a subgroup H  G with space group number sgnum·¥¥ and time-reversal symmetry timereversal.\n\nPractically, the function answers the question: which new tight-binding terms become allowed if the symmetry of the model is reduced from space group G to subgroup H?\n\nImplementation\n\nThe function computes a basis of allowed tight-binding terms in the subgroup setting H by simply restricting the constraints in G to generators in H. This gives a basis for the tight-binding terms in the subduced G  H setting.  The space spanned by this basis is compared to the space spanned in the original model; in particular new terms are identified as the orthogonal complement of the spaces associated with G  H relative to G.\n\nKeywords\n\ntimereversal::Bool: Specifies whether time-reversal symmetry is present in the subgroup H. By default, the presence or absence is inherited from the original model tbm. Note that timereversal must be \"lower or equal to\" the time-reversal of the original model.\n\nExample\n\nIt is well-known that the Dirac point of graphene is gapped under mirror and time-reversal symmetry breaking. We can see this by constructing a tight-binding model first for a model of graphene (plane group ‚ãï17) and then subducing it to a setting without mirror symmetry (plane group ‚ãï16) and without time-reversal symmetry (timereversal = false). First, we construct the tight-binding model for graphene (via the (2a|A‚ÇÅ) band representation):\n\njulia> using SymmetricTightBinding, Crystalline\n\njulia> brs = calc_bandreps(17, Val(2); timereversal = true);\n\njulia> cbr = @composite brs[5]\n\njulia> tbm = tb_hamiltonian(cbr, [[0,0], [1,0]])\n\nEach of the 4 terms in this model is proportional to an identity matrix at K = (1/3, 1/3). By using complement, we can find the new terms that appear if we imagine lowering the symmetry from plane group ‚ãï17 to ‚ãï16 (which has no mirror symmetry) while also removing time-reversal symmetry.\n\njulia> Œîtbm = complement(tbm, 16; timereversal = false)\n2-term 2√ó2 TightBindingModel{2} over (2b|A‚ÇÅ):\n‚îå‚îÄ\n1. ‚é° iùïñ(Œ¥‚ÇÅ)+iùïñ(Œ¥‚ÇÇ)+iùïñ(Œ¥‚ÇÉ)-iùïñ(Œ¥‚ÇÑ)-iùïñ(Œ¥‚ÇÖ)-iùïñ(Œ¥‚ÇÜ)  0                                          ‚é§\n‚îÇ  ‚é£ 0                                          -iùïñ(Œ¥‚ÇÅ)-iùïñ(Œ¥‚ÇÇ)-iùïñ(Œ¥‚ÇÉ)+iùïñ(Œ¥‚ÇÑ)+iùïñ(Œ¥‚ÇÖ)+iùïñ(Œ¥‚ÇÜ) ‚é¶\n‚îî‚îÄ (2b|A‚ÇÅ) self-term:  Œ¥‚ÇÅ=[1,0], Œ¥‚ÇÇ=[0,1], Œ¥‚ÇÉ=[-1,-1], Œ¥‚ÇÑ=-Œ¥‚ÇÅ, Œ¥‚ÇÖ=-Œ¥‚ÇÇ, Œ¥‚ÇÜ=-Œ¥‚ÇÉ\n‚îå‚îÄ\n2. ‚é° 0                                       ùïñ(Œ¥‚ÇÅ)+ùïñ(Œ¥‚ÇÇ)+ùïñ(Œ¥‚ÇÉ)-ùïñ(Œ¥‚Çá)-ùïñ(Œ¥‚Çà)-ùïñ(Œ¥‚Çâ) ‚é§\n‚îÇ  ‚é£ ùïñ(Œ¥‚ÇÑ)+ùïñ(Œ¥‚ÇÖ)+ùïñ(Œ¥‚ÇÜ)-ùïñ(Œ¥‚ÇÅ‚ÇÄ)-ùïñ(Œ¥‚ÇÅ‚ÇÅ)-ùïñ(Œ¥‚ÇÅ‚ÇÇ)  0                                   ‚é¶\n‚îî‚îÄ (2b|A‚ÇÅ) self-term:  Œ¥‚ÇÅ=[4/3,-1/3], Œ¥‚ÇÇ=[1/3,5/3], Œ¥‚ÇÉ=[-5/3,-4/3], Œ¥‚ÇÑ=-Œ¥‚ÇÅ, Œ¥‚ÇÖ=-Œ¥‚ÇÇ, Œ¥‚ÇÜ=-Œ¥‚ÇÉ, Œ¥‚Çá=[1/3,-4/3], Œ¥‚Çà=[-5/3,-1/3], Œ¥‚Çâ=[4/3,5/3], Œ¥‚ÇÅ‚ÇÄ=-Œ¥‚Çá, Œ¥‚ÇÅ‚ÇÅ=-Œ¥‚Çà, Œ¥‚ÇÅ‚ÇÇ=-Œ¥‚Çâ\n\nThe first of the of these terms is not diagonal at K and so opens a gap at the Dirac point:\n\njulia> Œîtbm[1](ReciprocalPoint(1/3, 1/3))\n2√ó2 Matrix{ComplexF64}:\n 5.19615+1.73195e-14im       0.0+0.0im\n     0.0+0.0im          -5.19615+1.43774e-14im\n\nAdding symmetry-breaking terms to the original model\n\nTo build a \"complete\" model, with both the original and symmetry-breaking terms, use vcat:\n\njulia> tbm‚Ä≤ = vcat(tbm, Œîtbm); length(tbm‚Ä≤) == length(tbm) + length(Œîtbm)\ntrue\n\nLimitations\n\nThe subgroup H must be a volume-preserving subgroup of the original group G. I.e. H must be a translationen-gleiche subgroup of G (or G itself), and there must exist a transformation from G to H that preserves volume (i.e., has det(t.P) == 1 for t denoting an element returned by Crystalline.jl's conjugacy_relations).\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.energy_gradient_wrt_hopping-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{ParameterizedTightBindingModel{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Any}} where D","page":"API","title":"SymmetricTightBinding.energy_gradient_wrt_hopping","text":"energy_gradient_wrt_hopping(\n    ptbm::ParameterizedTightBindingModel{D},\n    k::ReciprocalPointLike{D}\n    (Es, us) = solve(ptbm, k; bloch_phase=Val(false));\n    degen_rtol::Float64 = 1e-12,\n    degen_atol::Float64 = 1e-12\n) where D\n\nReturn the hopping gradient of the energy of each band in ptbm evaluated at momentum k.\n\nThe gradient is computed using the Feynman-Hellmann theorem. For degenerate bands (assessed energetically using relative and absolute tolerances degen_rtol and degen_atol), a degenerate variant is used, equivalent to degenerate perturbation theory.\n\nThe gradient is returned as column vectors, one for each band, with each column containing the gradient of the corresponding energy with respect to the hopping coefficients of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.gradient_wrt_hopping-Tuple{TightBindingModel}","page":"API","title":"SymmetricTightBinding.gradient_wrt_hopping","text":"gradient_wrt_hopping(tbm :: TightBindingModel)\ngradient_wrt_hopping(ptbm :: ParameterizedTightBindingModel)\n\nReturn a structure that encodes the gradient of a tight-binding model tbm or ptbm with respect to the hopping coefficients.\n\nTo evaluate the gradient at a particular momentum k, use the returned structure as a functor at k. I.e., gradient(tbm)(k) returns the gradient of the tight-binding Hamiltonian with respect to all hoppping coefficients at momentum k. This gradient is a vector of matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.obtain_symmetry_related_hoppings-Union{Tuple{V}, Tuple{D}, Tuple{AbstractVector{V}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}} where {D, V<:Union{Crystalline.RVec{D}, AbstractVector{<:Integer}}}","page":"API","title":"SymmetricTightBinding.obtain_symmetry_related_hoppings","text":"obtain_symmetry_related_hoppings(\n    Rs::AbstractVector{V}, \n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D},\n) --> Vector{HoppingOrbit{D}}\n\nCompute the symmetry related hopping terms from the points in WP of br‚Çê to the  WP of br·µ¶ displaced a set of primitive lattice vectors representatives Rs.\n\nImplementation\n\nTake a point a in the WP of br‚Çê and a point b in the WP of br·µ¶. We \n\ncompute the displacement vector Œ¥ = b + R - a, where R ‚àà Rs.\n\nIf Œ¥ ‚àà representatives then we add Œ¥ => (a, b, R) to the list of hoppings   of that representative and continue. If not then, we search inside of all the   representatives for the one that Œ¥ => (a, b, R) in the list of hoppings.   If not found, then we add Œ¥ as a new representative and add Œ¥ => (a, b, R)   to its list of hoppings.\nTake g ‚àà generators and compute Œ¥' = g Œ¥ and (a', b', R') = (g a, g b, g R),   and repeat step 2.\nRepeat all steps 1 to 3 for all pair of points in the WPs of br‚Çê and br·µ¶.\n\nAdditionally, if we have time-reversal symmetry, we check if orbits that relate Œ¥ and  -Œ¥ are present; if not, we add them. The presence or absence of time-reversal symmetry is automatically inferred from br‚Çê and br·µ¶ (which must be identical).\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.pin_free!-Tuple{Crystalline.Collection{<:Crystalline.NewBandRep}, AbstractVector{<:Pair{Int64, <:AbstractVector{<:Real}}}}","page":"API","title":"SymmetricTightBinding.pin_free!","text":"pin_free!(\n    brs::Collection{NewBandRep{D}},\n    idx2Œ±Œ≤Œ≥::Pair{Int, <:AbstractVector{<:Real}}\n)\n\npin_free!(\n    brs::Collection{NewBandRep{D}},\n    idx2Œ±Œ≤Œ≥s::AbstractVector{<:Pair{Int, <:AbstractVector{<:Real}}}\n)\n\nFor idx2Œ±Œ≤Œ≥ = idx => Œ±Œ≤Œ≥, update brs[idx] such that the free parameters of its associated Wyckoff positions are pinned to Œ±Œ≤Œ≥.\n\nA vector of pairs idx2Œ±Œ≤Œ≥s can also be provided, to pin multiple distinct band representations.\n\nSee also pin_free for non-mutated input.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.sgrep_induced_by_siteir-Union{Tuple{D}, Tuple{Union{Crystalline.CompositeBandRep{D}, Crystalline.NewBandRep{D}}, Crystalline.SymOperation{D}}, Tuple{Union{Crystalline.CompositeBandRep{D}, Crystalline.NewBandRep{D}}, Crystalline.SymOperation{D}, Array{Bravais.DirectPoint{D}, 1}}} where D","page":"API","title":"SymmetricTightBinding.sgrep_induced_by_siteir","text":"sgrep_induced_by_siteir(\n    br::Union{NewBandRep, CompositeBandRep},\n    op::SymOperation, [positions::Vector{<:DirectPoint}]\n)\nsgrep_induced_by_siteir(\n    tbm::Union{TightBindingModel,ParameterizedTightBindingModel}, op::SymOperation\n)\n    --> SiteInducedSGRepElement\n\nComputes the representation matrix of a symmetry operation op induced by the site symmetry group associated with an elementary or composite band representation br , including the global momentum-dependent phase factor, returning a SiteInducedSGRepElement, which is a functor over momentum inputs.\n\nA (possibly parameterized) tight-binding model tbm can be specified instead of a band representation, in which case the latter is inferred from the former.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.spectrum-Tuple{ParameterizedTightBindingModel, Any}","page":"API","title":"SymmetricTightBinding.spectrum","text":"spectrum(ptbm::ParameterizedTightBindingModel, ks; transform = identity)\n\nEvaluate the spectrum, i.e., energies, of the tight-binding model ptbm over an iterable of input momenta ks. \n\nEnergies are returned as a matrix, with rows running over momenta and columns over distinct bands.\n\nKeyword arguments\n\ntransform: a function to apply to the resulting matrix of energies, defaulting to the identity function. This can be used to e.g., convert the energies to a different scaling.\n\nExample\n\nAs an example, we evaluating the band structure of graphene. Below, we first construct and parameterize a tight-binding model for the the (2b|A‚ÇÅ) EBR in plane group 17, corresponding to the highest-lying orbitals in graphene. Next, we construct a path along high-symmetry directions of the Brillouin zone using Brillouin.jl, calculate the spectrum across this path; and finally, plot the band structure using Brillouin and GLMakie (or PlotlyJS):\n\njulia> using Crystalline, SymmetricTightBinding\n\njulia> brs = calc_bandreps(17, Val(2));\n\njulia> cbr = @composite brs[5]\n13-irrep CompositeBandRep{2}:\n (2b|A‚ÇÅ) (2 bands)\n\njulia> ptbm = tb_hamiltonian(cbr, [zeros(Int, dim(cbr))])([0.0, 1.0]);\n\njulia> using Brillouin, GLMakie\n\njulia> kpi = interpolate(irrfbz_path(17, directbasis(17, Val(2))), 100);\n\njulia> plot(kpi, spectrum(ptbm, kpi))\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.spectrum-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, AbstractVector{<:Real}}} where D","page":"API","title":"SymmetricTightBinding.spectrum","text":"spectrum(ptbm::ParameterizedTightBindingModel, k::AbstractVector{<:Real})\n\nEvaluate the spectrum, i.e., energies, of the tight-binding model ptbm at a single momentum k, across all the bands of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.symmetry_eigenvalues-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, AbstractArray{Crystalline.SymOperation{D}, 1}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{ParameterizedTightBindingModel{D}, AbstractArray{Crystalline.SymOperation{D}, 1}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, AbstractArray{SymmetricTightBinding.SiteInducedSGRepElement{D}, 1}}} where D","page":"API","title":"SymmetricTightBinding.symmetry_eigenvalues","text":"symmetry_eigenvalues(\n    ptbm::ParameterizedTightBindingModel{D},\n    ops::AbstractVector{SymOperation{D}},\n    k::ReciprocalPointLike{D},\n    [sgreps::AbstractVector{SiteInducedSGRepElement{D}}]\n)\nsymmetry_eigenvalues(\n    ptbm::ParameterizedTightBindingModel{D},\n    lg::LittleGroup{D},\n    [sgreps::AbstractVector{SiteInducedSGRepElement{D}}]\n)\n    --> Matrix{ComplexF64}\n\nCompute the symmetry eigenvalues of a coefficient-parameterized tight-binding model ptbm at the k-point k for the symmetry operations ops. A LittleGroup can also be provided instead of ops and k.\n\nRepresentations of the symmetry operations ops as acting on the orbitals of the tight-binding setting can optionally be provided in sgreps (see sgrep_induced_by_siteir) and are otherwise initialized by the function.\n\nThe symmetry eigenvalues are returned as a matrix, with rows running over the elements of ops and columns running over the bands of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.tb_hamiltonian-Union{Tuple{Crystalline.CompositeBandRep{D}}, Tuple{D}, Tuple{Crystalline.CompositeBandRep{D}, AbstractVector{Vector{Int64}}}} where D","page":"API","title":"SymmetricTightBinding.tb_hamiltonian","text":"tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) \n    --> Vector{TightBindingTerm{D}}\n\nConstruct the TB Hamiltonian matrix from a given composite band representation cbr and a set of global translation-representatives Rs. The Hamiltonian is constructed block by block according to the symmetry-related hoppings between the band representations in cbr. Several models returned, each representing a term that is closed under the symmetry operations of  the underlying space group.\n\n\n\n\n\n","category":"method"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#SymmetricTightBinding.HoppingOrbit","page":"API","title":"SymmetricTightBinding.HoppingOrbit","text":"HoppingOrbit{D}\n\nA structure holding information about symmetry-related spatial hopping vectors.\n\nAn orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the symmetry operations of the underlying space group to a representative vector Œ¥.\n\nFor each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site a to site b, possibly related by a lattice translation R. Each such set of possible hopping term (a, b, R) is for each Œ¥·µ¢ is stored elements as the ith element of the vector hoppings.\n\nFields\n\nrepresentative :: RVec{D}: the representative hopping vector Œ¥\norbit :: Vector{RVec{D}}: the Œ¥·µ¢ elements of the orbit generated by Œ¥. Generally orbit[1] == representative, i.e., Œ¥‚ÇÅ = Œ¥\nhoppings :: Vector{Vector{NTuple{3,RVec{D}}}}: the ith element gives the possible physical hopping terms (a,b,R) associated to orbit[i]. Multiple physical hopping terms may correspond to each element of the orbit.  For (a, b, R) = hoppings[i][j], we have orbit[i] = Œ¥·µ¢ = b + R - a\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.ParameterizedTightBindingModel","page":"API","title":"SymmetricTightBinding.ParameterizedTightBindingModel","text":"ParameterizedTightBindingModel{D}\n\nA coefficient-parameterized tight-binding model, that can be used as a functor for evaluation at input momenta k.\n\nFields\n\ntbm :: TightBindingModel{D}: A tight-binding model, consisting of a set of a list of TightBindingTerm{D}s.\ncs :: Vector{Float64}: A vector of coefficients, each associated to a corresponding element of tbm.\nscratch :: Matrix{ComplexF64}: A scratch space for evaluating the Hamiltonian matrix at at specific momenta. This is a N√óN matrix, where N is the number of orbitals in tbm (i.e., tbm.N). The scratch space is instantiated automatically on construction.\n\nFunctor over momenta\n\nA ParameterizedTightBindingModel ptbm can be be evaluated at any ¬¥D-dimensional momentumkby usingptbmas a functor. That is,ptbm(k)returns a numerical representation of the Hamiltonian matrix forptbmevaluated at momentumk.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.TightBindingElementString","page":"API","title":"SymmetricTightBinding.TightBindingElementString","text":"TightBindingElementString\n\nA structure for pretty-printing tight-binding matrix elements.\n\nFields\n\ns :: String: the string representing the tight-binding matrix element\nactive :: Bool: whether the element belongs to an \"active\" block - i.e., one we want to highlight (then shown in blue).\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.TightBindingModel","page":"API","title":"SymmetricTightBinding.TightBindingModel","text":"TightBindingModel{D}\n\nA structure storing a list of TightBindingTerm{D}s. Each term is assumed to associated with an identical list of EBRs.\n\nTo associate a set of coefficients to each term, see ParameterizedTightBindingModel, which also allows evaluation at specific momenta.\n\nFields\n\nterms :: Vector{TightBindingTerm{D}}: a vector of TightBindingTerm{D}s, each of which represents a block (or conjugated pairs of blocks) of the Hamiltonian matrix.\ncbr :: CompositeBandRep{D}: the composite band representation associated to the model.\npositions :: Vector{DirectPoint{D}}: a vector of positions, specified in the lattice basis, associated to each orbital of the model.\nN :: Int: the total number of orbitals in the model, i.e., the size of the Hamiltonian matrix associated to each element of terms.\n\n\n\n\n\n","category":"type"},{"location":"symmetry-breaking/#Symmetry-breaking","page":"Symmetry breaking","title":"Symmetry breaking","text":"","category":"section"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"A frequent question in tight-binding modelling is whether ‚Äì and which ‚Äì new hoppings terms might become allowed if the overall symmetry is reduced, either by breaking spatial symmetries or time-reversal symmetry. Such terms might e.g., break degeneracies or enable topological phase transitions.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"SymmetricTightBinding.jl exports complement as a tool to answer exactly this question. Here, we apply it to understand the effect of symmetry breaking on a 2-band model in plane group p4mm (‚ãï11).","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"We start by constructing our symmetry-unbroken model, picking the (2c|A‚ÇÅ) band representation of p4mm:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"using Crystalline, SymmetricTightBinding\nbrs = calc_bandreps(11, Val(2))\ncbr = @composite brs[1]\ntbm = tb_hamiltonian(cbr, [[0,0], [1,0]])\nptbm = tbm([0, 1, -1, 1])","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"note: Interpretation of tight-binding terms\nWe can visualize the tight-binding terms using plot, providing also a lattice basis for the illustration:using GLMakie\nplot(tbm, directbasis(11, Val(2)))While terms 3 and 4 appear identical in this visualization, they are not (cf. issue #75): in term 3, horizontal hoppings (Œ¥‚ÇÅ and Œ¥‚ÇÇ) are associated to the first Wyckoff position (at [1/2, 0]) and vertical hoppings to the second Wyckoff position (at [0, 1/2]), and vice versa for term 4.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"The parameterized model has a quadratic degeneracy at M, associated with the M‚ÇÖ irrep:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"using Brillouin, GLMakie\nRs = directbasis(11, Val(2))\nkp = irrfbz_path(11, Rs)\nkpi = interpolate(kp, 100);","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"plot(kpi, spectrum(ptbm, kpi))","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Next, we may study which terms become allowed if we break either time-reversal symmetry or the mirror symmetries of the system. In the latter case, this corresponds to lowering the plane group symmetry to p4 (‚ãï10):","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Œîtbm_mirror = complement(tbm, 10)                   # maintain TR, break mirror symmetry\nŒîtbm_tr = complement(tbm, 11; timereversal = false) # maintain spatial symmetries, break TR","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"todo: Todo\nIs the above for Œîtbm_tr wrong? It looks wrong relative to the result below. Maybe the effect of breaking either is equivalent, but the effect of breaking both is \"more than the sum of their parts\" - would make sense.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"We can also break both simultaneously:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Œîtbm = complement(tbm, 10; timereversal = false)","category":"page"},{"location":"band-symmetry/#Band-symmetry-and-topology","page":"Band symmetry","title":"Band symmetry and topology","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Since the theory behind SymmetricTightBinding.jl is anchored in symmetry analysis, the package naturally provides several tools to analyze band symmetry, as well as to use this information to apply the frameworks of topological quantum chemistry and symmetry indicators to analyze band topology.","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"To explore these tools, we first re-build the graphene model previously explored in the tutorial section, instantiating the variables tbm (model), ptbm (coefficient-parameterized model), kpi (interpolated k-path, via Brillouin.jl), and Es (band structure of ptbm, evaluated over kpi).","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"details: Setup details\nusing Crystalline, SymmetricTightBinding\nusing Brillouin, GLMakie           # for k-space path and plotting\nsgnum = 17                         # plane group p6mm\nbrs = calc_bandreps(sgnum, Val(2)) # band representations\ncbr = @composite brs[5]            # (2b|A‚ÇÅ) EBR\ntbm = tb_hamiltonian(cbr)          # tight-binding model (nearest neigbors)\nptbm = tbm([0, 1])                 # zero self-energy, nonzero nearest-neighbor hopping\nRs = directbasis(sgnum, Val(2))    # (conventional) direct lattice basis\nkp = irrfbz_path(sgnum, Rs)        # high-symmetry k-path\nkpi = interpolate(kp, 100)         # interpolated k-path\nEs = spectrum(ptbm, kpi)           # band structure over `kpi`\nnothing # hide","category":"page"},{"location":"band-symmetry/#Annotating-little-group-irrep-labels","page":"Band symmetry","title":"Annotating little group irrep labels","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"To annotate a band structure plot with the little group irrep labels at high-symmetry k-points, we can use collect_irrep_annotations in combination with the annotations keyword argument of the Makie plot extension:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"plot(kpi, Es; annotations = collect_irrep_annotations(ptbm))","category":"page"},{"location":"band-symmetry/#Collecting-compatibility-respecting-band-groups","page":"Band symmetry","title":"Collecting compatibility respecting band groups","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Similarly, we can analyze the compatibility respecting bands contained in ptbm via collect_compatible:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"collect_compatible(ptbm)","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"collect_compatible returns a list of symmetry vectors, from lowest-energy band grouping to highest, each aggregating the symmetry content of a minimal set of compatibility-respecting bands. Here, since our model contains only a single band representation ‚Äì which is additionally an intrinsically connected one ‚Äì such a list can have only one possible element: the only possible band groupings is the original band representation. We can verify this by comparing with the symmetry vector of the band representation used to build tbm:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"SymmetryVector(CompositeBandRep(ptbm))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can set up a more interesting situation by incorporating more band representations (i.e., more orbitals) into our model. E.g., below, we add three s-like orbitals placed at the 3c Wyckoff position (edges of the hexagonal unit cell; i.e., a kagome-like lattice) to the usual graphene model. First, we look at a situation without hybridization and with the bands of the two orbitals sets overlapping:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"cbr‚Ä≤ = @composite brs[3] + brs[5] # (2a|A‚ÇÅ) + (3c|B‚ÇÇ)\ntbm‚Ä≤ = tb_hamiltonian(cbr‚Ä≤)\nptbm‚Ä≤ = tbm‚Ä≤([2.5, 0, 0.2, 0, -1, 0])\nplot(kpi, spectrum(ptbm‚Ä≤, kpi); annotations = collect_irrep_annotations(ptbm‚Ä≤))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Next, we turn on hybridization (controlled by the fifth term of tbm‚Ä≤):","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"ptbm‚Ä≤‚Ä≤ = tbm‚Ä≤([2.5, 0, 0.2, 0, -1, .5])\nplot(kpi, spectrum(ptbm‚Ä≤‚Ä≤, kpi); annotations = collect_irrep_annotations(ptbm‚Ä≤‚Ä≤))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can verify that neither of the band groupings in the hybridized band structure have the same content as either of the underlying band representations. In particular, the band symmetry content of the underlying band representations is:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"SymmetryVector.([brs[3], brs[5]])","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can compare this against the band symmetry content of each of the hybridized bands is obtained from collect_compatible (using a compatibility analysis that involves only the high-symmetry k-points):","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"ns = collect_compatible(ptbm‚Ä≤‚Ä≤)","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"In the hybridized model above, the symmetry content of each band grouping differs from any of the original band representations used to build the model: in particular, the assignment of the Œì‚ÇÉ and Œì‚ÇÜ irreps and the M‚ÇÇ and M‚ÇÑ irreps are inverted.","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"details: Recovering an EBR decomposition\nThe new bands can still be interpreted as induced by band representations: the lowest bands correspond to (1aE‚ÇÅ) + (1aA‚ÇÅ), or brs[end]+brs[end-5], while the upper bands are topologically fragile with a possible decomposition of the form (2bA‚ÇÅ) + (1aB‚ÇÇ) + (1aE‚ÇÇ) - (3cA‚ÇÅ), or brs[5] + brs[end-3] + brs[end-1] - brs[1]. These expansions can be obtained using SymmetryBases.jl's decompose function.","category":"page"},{"location":"band-symmetry/#Band-topology","page":"Band symmetry","title":"Band topology","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Using the extracted symmetry vectors, we can compute the associated symmetry-diagnosable band topology of each band grouping. We can obtain e.g., a coarse topological diagnosis of TRIVIAL (encompassing both trivial and fragile phases) and NONTRIVIAL using Crystalline.jl's calc_topology:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"calc_topology.(ns, Ref(brs))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"I.e., in this example, both band representations are either a trivial or a fragile phase. To resolve this distinction, we can use SymmetryBases.jl's calc_detailed_topology:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"using SymmetryBases\ncalc_detailed_topology.(ns, Ref(brs))","category":"page"},{"location":"#SymmetricTightBinding.jl","page":"Home","title":"SymmetricTightBinding.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymmetricTightBinding.jl provides tools for the construction and manipulation of tight-binding models. The main novelty ‚Äì and principal strength ‚Äì of the package is that every such model is associated with, and specified by, a set of band representations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Put more simply, SymmetricTightBinding.jl will automatically generate all possible tight-binding Hamiltonians that are compatible with a global (space group) symmetry, as well as a selection of orbitals with specified local symmetries (i.e., transforming as specific site symmetry irreps), each situated at specified positions in the unit cell (i.e., at specific Wyckoff positions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying physics is that the Bloch Hamiltonian of a Wannierizable set of bands must transform under under a site-symmetry induced representation (also called band representation) D(g) for operations g in the associated space group. That is, the Bloch Hamiltonian mathbfh(mathbfk) must be symmetric in the sense:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbfD_mathbfk(g) mathbfh_mathbfk mathbfD_mathbfk^dagger(g) = mathbfh_gmathbfk","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfD_mathbfk(g) is the (momentum-)block-diagonal part of the Fourier transformed band representation D(g). This is simply the familiar operator relation g hath_mathbfk g^-1 = hath_gmathbfk cast into the basis of local orbitals.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is registered in the Julia General registry and can be installed from the pkg> command line (entered by pressing ] in the Julia REPL):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SymmetricTightBinding, Crystalline","category":"page"},{"location":"","page":"Home","title":"Home","text":"SymmetricTightBinding.jl is designed to work as a companion package to Crystalline.jl; so we add Crystalline.jl in the above as well. The packages can subsequently be loaded at the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SymmetricTightBinding, Crystalline","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"tutorial.md\", \"band-symmetry.md\", \"symmetry-breaking.md\", \"api.md\", \"internal-api.md\"]\nDepth = 2","category":"page"},{"location":"tutorial/#tutorial","page":"Tutorial","title":"Tutorial example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a first step, we load both Crystalline.jl and SymmetricTightBinding.jl into our current Julia session:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Crystalline, SymmetricTightBinding","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As our first example, we'll build and explore the tight-binding model of graphene. Once we've done that, we'll explore how to create related tight-binding models in the same symmetry setting. Subsequently, we'll take a look at building 3D tight-binding models.","category":"page"},{"location":"tutorial/#Graphene","page":"Tutorial","title":"Graphene","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Graphene is a two-dimensional material, with two carbon atoms arranged in a honeycomb lattice. For our purposes, the important aspect is its crystal symmetry: the lattice has 6-fold rotation symmetry and associated in-plane mirror symmetry. In the language of crystallography, its symmetry is that of plane group p6mm (here, specified by its Hermann‚ÄìMauguin label). This plane group has a conventional numbering assigned ‚Äì namely, plane group ‚ãï17. The mapping between the Hermann‚ÄìMauguin label and the conventional number can e.g., be determined using Crystalline.jl's iuc or looked up in online tables, such as the Bilbao Crystallographic Server.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using Crystalline, we can build the maximal band representations of plane group ‚ãï17:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sgnum = 17 # space group number of p6mm\nbrs = calc_bandreps(sgnum, Val(2)) # `Val(2)` specifies the dimensionality (here, 2D)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The top row of the output lists the possible positions that a symmetrically placed orbital can reside, specified as a Wyckoff position label (e.g., 1a, 2b, 3c). In the second row, the possible local symmetry that an orbital placed there can have (e.g., A‚ÇÅ, A‚ÇÇ, B‚ÇÅ, ‚Ä¶) are listed, specified in Mulikken notation. The remaining rows contain information about the projection of each band representation to band symmetries at high-symmetry k-points and which is not needed in the present context.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Graphene's two p<sub>z</sub> orbitals sit at the 2b Wyckoff position: though odd (i.e., changing sign) under mirror in the out-of-plane direction, the p<sub>z</sub> orbital is even (i.e., invariant) under all in-plane symmetries (rotations and mirrors). The associated site-symmetry irrep is the A‚ÇÅ site-symmetry irrep of the 2b Wyckoff position. In the above tables, this is the fifth column of brs, which we may select by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"brs[1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To construct a tight-binding model, we must construct a CompositeBandRepresentation: this is necessary because we may generally be interested in building models for multiple band representations (say, for placing orbitals at multiple distinct Wyckoff positions). We can construct such a composite representation by @composite a*brs[i] + b*brs[j] + ‚Ä¶ which will contain a times the brs[i] band representation and so on. Here, we just need the (2b|A‚ÇÅ) representation once:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cbr = @composite brs[5]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With this in hand, we can finally use SymmetricTightBinding.jl. In particular, we may use tb_hamiltonian. First, we build the nearest-neighbor tight-binding Hamiltonian:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tbm = tb_hamiltonian(cbr)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The output lists the \"basis terms\" of the tight-binding Bloch Hamiltonian, each implicitly parameterized by a free on-site energy or hopping amplitude. The notation ùïñ(Œ¥·µ¢) is introduced for brevity, a short-hand for the complex momentum-dependent exponential mathrme^mathrmimathbfkcdotboldsymboldelta_i. Here boldsymboldelta_i denotes a hopping vector; in turn, these vectors are expressed above as Œ¥·µ¢, given in the basis of the primitive direct lattice mathbfa_i. I.e., a term like Œ¥‚ÇÅ = [-1/3, 1/3] really means boldsymboldelta_1 = -tfrac13mathbfa_1 + tfrac13mathbfa_2.","category":"page"},{"location":"tutorial/#Visualization","page":"Tutorial","title":"Visualization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It's often helpful to visualize model terms, and SymmetricTightBinding.jl facilitates this via a Makie extension. We may e.g., use GLMakie.jl to plot the second tight-binding term:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GLMakie\nRs = directbasis(sgnum, Val(2)) # a direct lattice basis, to allow plotting in a Cartesian setting\nplot(tbm[2], Rs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, red markers indicate \"source\" sites while blue markers indicat \"drains\"; electrons hop from sources to drains, as also indicated by the arrowheads. The visualization (and the internal representation of tbm) includes only the hoppings for a single unit cell, such that tiling unit cells do not lead to counting hoppings multiple times.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We might want to go beyond nearest-neighbor in our tight-binding model. To do so, we must provide tb_hamiltonian with a second argument that gives a set of possible direct-lattice vector separations of sources and drains (in addition to an intra-lattice term). It is enough to include a representative direct lattice vector; if e.g., [1,0] and [0,1] are symmetry-related, the latter will be automatically included by providing the former.  For the graphene example, we might include direct lattice separations [0,0] (default, if a second argument is not provided) and [1,0]:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tbm = tb_hamiltonian(cbr, [[0,0], [1,0]])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And we now have four terms. We can visualize tbm[3] and tbm[4] as before, individually, or we can visualize all terms at once:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(tbm, Rs)","category":"page"},{"location":"tutorial/#Model-evaluation-and-band-structures","page":"Tutorial","title":"Model evaluation & band structures","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To evaluate the tight-binding model, we must specify a set of (real) hopping amplitudes. To associate coefficients c‚ÇÅ, c‚ÇÇ, c‚ÇÉ, c‚ÇÑ to each of the basis terms of the model tbm, we can invoke it as a functor to create a ParameterizedTightBindingModel:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cs = [0, 1, 0, 0] # set c‚ÇÇ = 1 and all other c·µ¢ to zero\nptbm = tbm(cs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then evaluate the parameterized model ptbm at k-point, again using ptbm as a functor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"k = ReciprocalPoint(1/2, 0) # the M point\nh = ptbm(k)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the k-point coordinates must be given in the basis of the primitive reciprocal lattice vectors mathbfb_i (the dual lattice to mathbfa_i), i.e., the k variable above corresponds to the point mathbfk = tfrac12mathbfb_1 + 0mathbfb_2.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will usually be more interested in the overall behavior of the model across the Brillouin zone than its behavior at any single k-point. E.g., we might be interested in the band structure along high-symmetry lines of the Brillouin zone. To quickly build such a path, we leverage Brillouin.jl's irrfbz_path:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Brillouin\nkp = irrfbz_path(sgnum, Rs)\nkpi = interpolate(kp, 200) # aim for 200 interpolations points","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, to obtain the band structure along the interpolated k-path, we use SymmetricTightBinding.jl's spectrum function and plot the result using the Brillouin.jl's Makie.jl extension:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Es = spectrum(ptbm, kpi); # a 200√ó2 Matrix\nplot(kpi, Es)","category":"page"}]
}
