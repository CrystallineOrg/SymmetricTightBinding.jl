var documenterSearchIndex = {"docs":
[{"location":"internal-api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"This page lists unexported functionality from SymmetricTightBinding.jl that may be of interest to developers.","category":"page"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"","category":"page"},{"location":"internal-api/#Unexported,-internal-functionality","page":"Internal API","title":"Unexported, internal functionality","text":"","category":"section"},{"location":"internal-api/#SymmetricTightBinding.OrbitalOrdering-Union{Tuple{Crystalline.NewBandRep{D}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.OrbitalOrdering","text":"OrbitalOrdering(br::NewBandRep{D}) --> OrbitalOrdering{D}\n\nEstablishes a canonical, local ordering for the orbitals associated to a band representation br. This is the default ordering used when associating row/column indices in a tight-binding Hamiltonian block to specific orbitals in the associated band representations.\n\nThe canonical orbital ordering is stored in .ordering. The ith elements of ordering, ordering[i], is a NamedTuple with two fields: wp and idx:\n\nwp: stores a Wyckoff position in the orbit of the Wyckoff position associated to br.wp.\nidx: stores the index of the partner function of the site-symmetry irrep associated to br at wp.\n\nI.e., the ith orbital associated to br is located at wp and transforms as the idxth partner function of the site-symmetry irrep of br.siteir. The total number of orbitals associated to a band representation, and hence the length of ordering, is the product of the site-symmetry irrep dimensionality and the number of sites in the Wyckoff position orbit.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.SiteInducedSGRepElement","page":"Internal API","title":"SymmetricTightBinding.SiteInducedSGRepElement","text":"SiteInducedSGRepElement{D}(\n    œÅ::AbstractMatrix,\n    positions::Vector{DirectPoint{D}},\n    op::SymOperation{D}\n)\n\nRepresents a matrix-valued element of a site-induced representation of a space group, including a global momentum-dependent phase factor.\n\nThis structure behaves like a functor: calling it with a momentum k :: AbstractVector  returns the matrix representation at k.\n\nFields (internal)\n\nœÅ :: Matrix{ComplexF64} : The momentum-independent matrix part of the representation.\npositions :: Vector{DirectPoint{D}}: Real-space positions corresponding to the orbitals in the orbit of the associated site-symmetry group.\n\n\n\n\n\n","category":"type"},{"location":"internal-api/#SymmetricTightBinding._maybe_add_hoppings!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding._maybe_add_hoppings!","text":"Computes and adds the symmetry related partners of a hopping term Œ¥ to the Œ¥_orbit.\n\nwarning: Warning\nThis function is an internal helper function for maybe_add_hoppings! and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._permute_symmetry_related_hoppings_under_symmetry_operation-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.SymOperation{D}}} where D","page":"Internal API","title":"SymmetricTightBinding._permute_symmetry_related_hoppings_under_symmetry_operation","text":"Build the P matrix for a particular symmetry operation acting on k-space, which permutes the rows of the M matrix.\n\nFor obtaining the P matrix, we make use that the action is on exponential of the type: ùêûxp(2œÄkŒ¥), to instead act on Œ¥ ‚àà h_orbit.orbit instead of k, which is a symbolic variable. Because of that, we need to use the inverse of the rotation part of the symmetry operation.\n\ndetails: Sketch of proof\nAssume g={R|œÑ} and Crystalline implements gk=(R‚Åª¬π)·µÄk. Then (gk)‚ãÖŒ¥ = ((R‚Åª¬π)·µÄk)‚ãÖŒ¥ + œÑ = k‚ãÖ(R‚Åª¬π)Œ¥.\n\ninfo: Info\nIt is assumed that the operation op is provided in a primitive setting.\n\nwarning: Warning\nThis function is an internal helper function for reciprocal_constraints_matrices and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._poormans_sparsification-Tuple{AbstractMatrix{<:Number}}","page":"Internal API","title":"SymmetricTightBinding._poormans_sparsification","text":"Poor man's \"matrix sparsification\" via the reduced row echelon form.\n\nwarning: Warning\nThis function is an internal helper function for obtain_basis_free_parameters and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._prune_at_threshold!-Union{Tuple{AbstractVector{<:AbstractVector{T}}}, Tuple{T}} where T<:Complex","page":"Internal API","title":"SymmetricTightBinding._prune_at_threshold!","text":"Prune near-zero elements of vectors in vs.\n\nwarning: Warning\nThis function is an internal helper function for obtain_basis_free_parameters and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.add_reversed_orbits!-Union{Tuple{Array{HoppingOrbit{D}, 1}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.add_reversed_orbits!","text":"add_reversed_orbits!(h_orbits::Vector{HoppingOrbit{D}}) where {D}\n\nAdds the reversed hopping terms to the hopping orbits in h_orbits. The reversed hopping terms are added to the orbit of the hopping term they are related to, and if they are already present in another orbit, the two orbits are merged.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.construct_M_matrix-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.construct_M_matrix","text":"construct_M_matrix(\n    h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D},\n    [ordering1, ordering2]) \n    --> Array{Int,4}\n\nConstruct a set of matrices that encodes a Hamiltonian's term which resembles the hopping from EBR br1 to EBR br2.\n\nThe encoding is stored as a 4D matrix. Its last two axes correspond to elements of the Bloch Hamiltonian H(k); its first axis corresponds to orbit(h_orbit) and the associated complex exponentials stored in v; and its second axis to the elements of the vector t. That is:\n\nH‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º\n\nSee devdocs.md for details.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.evaluate_tight_binding_term!-Union{Tuple{D}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Union{Nothing, Number}}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Union{Nothing, Number}, Matrix{ComplexF64}}} where D","page":"Internal API","title":"SymmetricTightBinding.evaluate_tight_binding_term!","text":"evaluate_tight_binding_term!(tbt::TightBindingTerm, k, [c, H])\n\nEvaluate the tight-binding term tbt at momentum k, possibly multiplied by a scalar coefficient c (unity if omitted). The term is added into the scratch space matrix H; if H is not provided, it is initialized as a zero matrix of the appropriate size.\n\nThe function returns the modified H matrix.\n\nNote\n\nThe two-argument form of the function, i.e., returning the value of tbt at k, can be more simply achieved via tbt(k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.inversion-Tuple{Val{3}}","page":"Internal API","title":"SymmetricTightBinding.inversion","text":"inversion(::Val{D}) --> SymOperation{D}\n\nReturn the inversion operation in dimension D.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.maybe_add_hoppings!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding.maybe_add_hoppings!","text":"maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops) --> Vector{HoppingOrbit{D}}\n\nChecks if a hopping term Œ¥ is already in the list of representatives. If not, it adds it and its symmetry related partners. If it is, it only adds the symmetry related partners.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters","text":"obtain_basis_free_parameters(\n    h_orbit::HoppingOrbit{D},\n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D}, \n    [ordering‚Çê = OrbitalOrdering(br‚Çê), ordering·µ¶ = OrbitalOrdering(br·µ¶)]\n    )                            --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}\n\nObtain the basis of free parameters for the hopping terms between br‚Çê and br·µ¶  associated with the hopping orbit h_orbit.\n\nNote\n\nThe presence or absence of time-reversal symmetry is inferred implicitly from br‚Çê and br·µ¶.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters_TRS-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}, AbstractArray{Int64, 4}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters_TRS","text":"obtain_basis_free_parameters_TRS(\n    h_orbit::HoppingOrbit{D}, \n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D}, \n    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),\n    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶),\n    Mm::AbstractArray{4, Int} = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶)\n    )                             --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}}\n\nObtain the basis of free parameters for the hopping terms between br‚Çê and br·µ¶ associated with the hopping orbit h_orbit under time-reversal symmetry.\n\nReal and imaginary parts of the basis vectors are differentiated explicitly: internally, we consider only variables.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters_hermiticity-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}, AbstractArray{Int64, 4}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters_hermiticity","text":"obtain_basis_free_parameters_hermiticity(\n    h_orbit::HoppingOrbit{D},\n    br‚Çê::NewBandRep{D},\n    br·µ¶::NewBandRep{D},\n    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),\n    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶),\n    Mm::AbstractArray{Int, 4} = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶);\n    antihermitian::Bool = false,\n) where {D}\n\nConstructs a basis for the coefficient vectors t‚ÅΩ‚Åø‚Åæ that span the space of Hermitian (or antihermitian if true) TB Hamiltonians H‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º = v·µÄ(k) M‚ÅΩÀ¢·µó‚Åæ t. We do this by assuming that each coefficient vector t is sorted into a vector of the form [t·¥ø; it·¥µ] so that we can take the complex conjugate by as t* = œÉ‚ÇÉt, which can then be moved onto M‚ÅΩÀ¢·µó‚Åæ instead of t. The constraint H‚Çõ‚Çú(k) = (H‚Ä†)‚Çõ‚Çú(k) = H‚Çú‚Çõ*(k) can then be expressed as v·µÄ(k) M‚ÅΩÀ¢·µó‚Åæ t‚±º = v*·µÄ(k) M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ t = v·µÄ(k) (P·µÄ M‚ÅΩ·µóÀ¢‚ÅæœÉ‚ÇÉ) t, which requires that t be a solution to the nullspace M‚ÅΩÀ¢·µó‚Åæ - P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ = 0. We cast this as Z - Q = 0, with Z = M‚ÅΩÀ¢·µó‚Åæ and Q = P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ.\n\nNotes\n\nFor anti-Hermitian symmetry, we require H‚Çõ‚Çú(k) = -H‚Çú‚Çõ*(k), which translates to M‚ÅΩÀ¢·µó‚Åæ + P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ = 0; i.e., simply swaps the sign of Q\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.pin_free-Union{Tuple{D}, Tuple{Crystalline.NewBandRep{D}, AbstractVector{<:Real}}} where D","page":"Internal API","title":"SymmetricTightBinding.pin_free","text":"pin_free(br::NewBandRep{D}, Œ±Œ≤Œ≥::AbstractVector{<:Real}) where D\n\nPin the free parameters of the Wyckoff position associated with the band representation br to the values in Œ±Œ≤Œ≥. \n\nReturns a new band representation with all other properties, apart from the Wyckoff position, identical to (and sharing memory with) br.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.primitivized_orbit-Union{Tuple{Crystalline.NewBandRep{D}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.primitivized_orbit","text":"primitivized_orbit(br::NewBandRep{D}) where D\n\nReturn the orbit of the Wyckoff position associated with the band representation br. The coordinates of positions in the orbit are given relative to the primitive unit cell.\n\nPositions are returned as a Vector{DirectPoint{D}}.\n\nThe following checks are made, producing an error if violated:\n\nThere are no free parameters associated with the Wyckoff position.\nFor every position, its coordinates, referred to the primitive basis, is in the range [0,1); i.e., every position lies in the parallepiped primitive unit cell [0,1)·¥∞.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.reciprocal_constraints_matrices-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, AbstractArray{Crystalline.SymOperation{D}, 1}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.reciprocal_constraints_matrices","text":"reciprocal_constraints_matrices(\n                                Mm::AbstractArray{Int,4}, \n                                gens::AbstractVector{SymOperation{D}}, \n                                h_orbit::HoppingOrbit{D}\n                                ) --> Vector{Array{Int,4}}\n\nCompute the reciprocal constraints matrices for the generators of the SG. This is done by permuting the rows of the M matrix according to the symmetry operation acting on k-space. See more details in permute_symmetry_related_hoppings_under_symmetry_operation and devdocs.md.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.reciprocal_constraints_trs-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.reciprocal_constraints_trs","text":"reciprocal_constraints_trs(Mm::AbstractArray{Int,4}, h_orbit::HoppingOrbit{D}) \n--> Array{ComplexF64,4}\n\nTime reversal symmetry action on reciprocal space. It is given by the association  k -> -k => H(k) -> H(-k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.representation_constraint_matrices-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding.representation_constraint_matrices","text":"representation_constraints_matrices(\n    Mm::AbstractArray{Int,4}, \n    br‚Çê::NewBandRep{D},\n    br·µ¶::NewBandRep{D}) --> Vector{Array{ComplexF64,4}}\n\nBuild the Q matrix for a particular symmetry operation (or, equivalently, a particular matrix from the site-symmetry representation), acting on the M matrix. Relative to our white-board notes, Q has swapped indices, in the sense we below give Q[i,j,r,l].\n\n(œÅ‚Çê‚Çê)·µ£‚Çõ H‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ v·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = v·µ¢ (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó t‚±º,\n\nthen we can define: Q·µ¢‚±º·µ£‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.representation_constraint_trs-Union{Tuple{D}, Tuple{AbstractArray{<:Number, 4}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.representation_constraint_trs","text":"representation_constraint_trs(Mm::AbstractArray{Int,4}, h_orbit::HoppingOrbit{D})\n--> Array{ComplexF64,4}\n\nTime reversal symmetry action on the Hamiltonian. It is given by the association Œ¥ -> -Œ¥ and  the complex conjugation in the free-parameter part: t‚±º - t‚±º*  t‚±º·¥ø it‚±º·¥µ - t‚±º·¥ø -it‚±º·¥µ  H(k) - H*(k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.sgrep_induced_by_siteir_excl_phase-Union{Tuple{D}, Tuple{Crystalline.NewBandRep{D}, Crystalline.SymOperation{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.sgrep_induced_by_siteir_excl_phase","text":"sgrep_induced_by_siteir_excl_phase(br::NewBandRep, op::SymOperation)\nsgrep_induced_by_siteir_excl_phase(cbr::CompositeBandRep, op::SymOperation)\n    --> Matrix{ComplexF64}\n\nReturn the representation matrix of a symmetry operation op induced by the site symmetry group of a band representation br or composite band representation cbr, excluding the global momentum-dependent phase factor.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.split_complex-Tuple{AbstractVector{<:Number}}","page":"Internal API","title":"SymmetricTightBinding.split_complex","text":"split_complex(t::Vector{<:Number}) -> Matrix{Real}\n\nConsider Œ±t where Œ± ‚àà ‚ÑÇ and t ‚àà ‚ÑÇ‚Åø and build from t a matrix representation T that allows access to the real and imaginary parts of the product Œ±t without using complex numbers by splitting Œ± into a real 2-vector of its real and imaginary parts.\n\nIn particular, let Œ± = Œ±·¥ø + iŒ±·¥µ and t = t·¥ø + it·¥µ with Œ±·¥ø, Œ±·¥µ ‚àà ‚Ñù and t·¥ø t·¥µ  ‚Ñù‚Åø, then Œ±t can be rewritten as\n\nŒ±t = (Œ±·¥ø + iŒ±·¥µ)(t·¥ø + it·¥µ)\n   = (Œ±·¥øt·¥ø - Œ±·¥µt·¥µ) + i(Œ±·¥øt·¥µ + Œ±·¥µt·¥ø)\n   = t·¥ø t·¥µ·µÄ Œ±·¥ø Œ±·¥µ + i t·¥µ t·¥ø·µÄ Œ±·¥ø Œ±·¥µ\n\nThen, defining T = [t·¥ø -t·¥µ; t·¥µ t·¥ø], the above product can then be reexpressed as: Re(Œ±t) = Œ±·¥øt·¥ø - Œ±·¥µt·¥µ = (T * [Œ±·¥ø; Œ±·¥µ])[1:n] and Im(Œ±t) = Œ±·¥øt·¥µ + Œ±·¥µt·¥ø = (T * [Œ±·¥ø; Œ±·¥µ])[n+1:2n]. I.e., the \"upper half\" of the product T * [real(Œ±), imag(Œ±)] is real(Œ± * t) and the  \"lower half\" is imag(Œ±t).\n\nThis functionality is used to avoid complex numbers in amplitude basis coefficients, which simplifies the application of time-reversal symmetry and hermiticity.\n\nExamples\n\njulia> using SymmetricTightBinding: split_complex\n\njulia> t = [im,0]\n2-element Vector{Complex{Int64}}:\n 0 + 1im\n 0 + 0im\n\njulia> T = split_complex(t)\n4√ó2 Matrix{Int64}:\n 0  -1\n 0   0\n 1   0\n 0   0\n\njulia> Œ± = 0.5+0.2im; Œ±v = [real(Œ±), imag(Œ±)];\n\njulia> (T * Œ±v)[1:2] == real(Œ±*t) && (T * Œ±v)[3:4] == imag(Œ±*t)\n\njulia> t = [1,im]\n2-element Vector{Complex{Int64}}:\n 1 + 0im\n 0 + 1im\n\njulia> split_complex(t)\n4√ó2 Matrix{Int64}:\n 1   0\n 0  -1\n 0   1\n 1   0\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.zassenhaus_intersection-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, Real}} where T<:Number","page":"Internal API","title":"SymmetricTightBinding.zassenhaus_intersection","text":"zassenhaus_intersection(U::AbstractArray{<:Number}, W::AbstractArray{<:Number}) \n    --> AbstractArray{<:Number}\n\nFinds the intersection of two bases U and W using the Zassenhaus algorithm. It assumes that the basis are given by columns.\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Zassenhaus_algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#Crystalline.collect_compatible-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, Vararg{Any}}} where D","page":"API","title":"Crystalline.collect_compatible","text":"collect_compatible(ptbm::ParameterizedTightBindingModel{D}; multiplicities_kws...)\n\nDetermine a decomposition of the bands associated with ptbm into a set of SymmetryVectors, with each symmetry vector corresponding to a set of compatibility-respecting (i.e., energy separable along high-symmetry k-lines) bands.\n\nKeyword arguments\n\nmultiplicities_kws...: keyword arguments passed to Crystalline.collect_compatible used in determining the multiplicities of irreps across high-symmetry k-points.\n\nExample\n\njulia> using Crystalline, SymmetricTightBinding\n\njulia> brs = calc_bandreps(221);\n\njulia> cbr = @composite brs[1] + brs[2]\n40-irrep CompositeBandRep{3}:\n (3d|A‚ÇÅg) + (3d|A‚ÇÅ·µ§) (6 bands)\n\njulia> tbm = tb_hamiltonian(cbr); # a 4-term, 6-band model\n\njulia> ptbm = tbm([1.0, 0.1, -1.0, 0.1]); # fix free coefficients\n\njulia> collect_compatible(ptbm)\n2-element Vector{SymmetryVector{3}}:\n [M‚ÇÖ‚Å∫+M‚ÇÅ‚Åª, X‚ÇÉ‚Å∫+X‚ÇÅ‚Åª+X‚ÇÇ‚Åª, Œì‚ÇÅ‚Åª+Œì‚ÇÉ‚Åª, R‚ÇÑ‚Å∫] (3 bands)\n [M‚ÇÅ‚Å∫+M‚ÇÖ‚Åª, X‚ÇÅ‚Å∫+X‚ÇÇ‚Å∫+X‚ÇÉ‚Åª, Œì‚ÇÅ‚Å∫+Œì‚ÇÉ‚Å∫, R‚ÇÑ‚Åª] (3 bands)\n\nIn the above example, the bands separate into two symmetry vectors, one for each of the original EBRs in cbr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.collect_irrep_annotations-Tuple{ParameterizedTightBindingModel}","page":"API","title":"Crystalline.collect_irrep_annotations","text":"collect_irrep_annotations(ptbm::ParameterizedTightBindingModel; kws...)\n\nCollect the irrep labels across the high-symmetry k-points referenced by the underlying composite band representation of ptbm, across the bands of the model.\n\nUseful for annotating irrep labels in band structure plots (via the Makie extension call plot(ks, energies; annotations=collect_irrep_annotations(ptbm)))\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.complement-Union{Tuple{D}, Tuple{TightBindingModel{D}, Int64}} where D","page":"API","title":"SymmetricTightBinding.complement","text":"complement(tbm::TightBindingModel{D}, sgnum·¥¥::Int; timereversal) --> TightBindingModel{D}\n\nGiven a model tbm associated with a space group G, determine the new, independent tight-binding terms (i.e., the the orthogonal complement of terms) that become  symmetry-allowed when the model's space group is reduced to a subgroup H  G with space group number sgnum·¥¥ and time-reversal symmetry timereversal.\n\nPractically, the function answers the question: which new tight-binding terms become allowed if the symmetry of the model is reduced from space group G to subgroup H?\n\nImplementation\n\nThe function computes a basis of allowed tight-binding terms in the subgroup setting H by simply restricting the constraints in G to generators in H. This gives a basis for the tight-binding terms in the subduced G  H setting.  The space spanned by this basis is compared to the space spanned in the original model; in particular new terms are identified as the orthogonal complement of the spaces associated with G  H relative to G.\n\nKeywords\n\ntimereversal::Bool: Specifies whether time-reversal symmetry is present in the subgroup H. By default, the presence or absence is inherited from the original model tbm. Note that timereversal must be \"lower or equal to\" the time-reversal of the original model.\n\nExample\n\nIt is well-known that the Dirac point of graphene is gapped under mirror and time-reversal symmetry breaking. We can see this by constructing a tight-binding model first for a model of graphene (plane group ‚ãï17) and then subducing it to a setting without mirror symmetry (plane group ‚ãï16) and without time-reversal symmetry (timereversal = false). First, we construct the tight-binding model for graphene (via the (2a|A‚ÇÅ) band representation):\n\njulia> using SymmetricTightBinding, Crystalline\n\njulia> brs = calc_bandreps(17, Val(2); timereversal = true);\n\njulia> cbr = @composite brs[5]\n\njulia> tbm = tb_hamiltonian(cbr, [[0,0], [1,0]])\n\nEach of the 4 terms in this model is proportional to an identity matrix at K = (1/3, 1/3). By using complement, we can find the new terms that appear if we imagine lowering the symmetry from plane group ‚ãï17 to ‚ãï16 (which has no mirror symmetry) while also removing time-reversal symmetry.\n\njulia> Œîtbm = complement(tbm, 16; timereversal = false)\n2-term 2√ó2 TightBindingModel{2} over (2b|A‚ÇÅ):\n‚îå‚îÄ\n1. ‚é° iùïñ(Œ¥‚ÇÅ)+iùïñ(Œ¥‚ÇÇ)+iùïñ(Œ¥‚ÇÉ)-iùïñ(Œ¥‚ÇÑ)-iùïñ(Œ¥‚ÇÖ)-iùïñ(Œ¥‚ÇÜ)  0                                          ‚é§\n‚îÇ  ‚é£ 0                                          -iùïñ(Œ¥‚ÇÅ)-iùïñ(Œ¥‚ÇÇ)-iùïñ(Œ¥‚ÇÉ)+iùïñ(Œ¥‚ÇÑ)+iùïñ(Œ¥‚ÇÖ)+iùïñ(Œ¥‚ÇÜ) ‚é¶\n‚îî‚îÄ (2b|A‚ÇÅ) self-term:  Œ¥‚ÇÅ=[1,0], Œ¥‚ÇÇ=[0,1], Œ¥‚ÇÉ=[-1,-1], Œ¥‚ÇÑ=-Œ¥‚ÇÅ, Œ¥‚ÇÖ=-Œ¥‚ÇÇ, Œ¥‚ÇÜ=-Œ¥‚ÇÉ\n‚îå‚îÄ\n2. ‚é° 0                                       ùïñ(Œ¥‚ÇÅ)+ùïñ(Œ¥‚ÇÇ)+ùïñ(Œ¥‚ÇÉ)-ùïñ(Œ¥‚Çá)-ùïñ(Œ¥‚Çà)-ùïñ(Œ¥‚Çâ) ‚é§\n‚îÇ  ‚é£ ùïñ(Œ¥‚ÇÑ)+ùïñ(Œ¥‚ÇÖ)+ùïñ(Œ¥‚ÇÜ)-ùïñ(Œ¥‚ÇÅ‚ÇÄ)-ùïñ(Œ¥‚ÇÅ‚ÇÅ)-ùïñ(Œ¥‚ÇÅ‚ÇÇ)  0                                   ‚é¶\n‚îî‚îÄ (2b|A‚ÇÅ) self-term:  Œ¥‚ÇÅ=[4/3,-1/3], Œ¥‚ÇÇ=[1/3,5/3], Œ¥‚ÇÉ=[-5/3,-4/3], Œ¥‚ÇÑ=-Œ¥‚ÇÅ, Œ¥‚ÇÖ=-Œ¥‚ÇÇ, Œ¥‚ÇÜ=-Œ¥‚ÇÉ, Œ¥‚Çá=[1/3,-4/3], Œ¥‚Çà=[-5/3,-1/3], Œ¥‚Çâ=[4/3,5/3], Œ¥‚ÇÅ‚ÇÄ=-Œ¥‚Çá, Œ¥‚ÇÅ‚ÇÅ=-Œ¥‚Çà, Œ¥‚ÇÅ‚ÇÇ=-Œ¥‚Çâ\n\nThe first of the of these terms is not diagonal at K and so opens a gap at the Dirac point:\n\njulia> Œîtbm[1](ReciprocalPoint(1/3, 1/3))\n2√ó2 Matrix{ComplexF64}:\n 5.19615+1.73195e-14im       0.0+0.0im\n     0.0+0.0im          -5.19615+1.43774e-14im\n\nAdding symmetry-breaking terms to the original model\n\nTo build a \"complete\" model, with both the original and symmetry-breaking terms, use vcat:\n\njulia> tbm‚Ä≤ = vcat(tbm, Œîtbm); length(tbm‚Ä≤) == length(tbm) + length(Œîtbm)\ntrue\n\nLimitations\n\nThe subgroup H must be a volume-preserving subgroup of the original group G. I.e. H must be a translationen-gleiche subgroup of G (or G itself), and there must exist a transformation from G to H that preserves volume (i.e., has det(t.P) == 1 for t denoting an element returned by Crystalline.jl's conjugacy_relations).\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.energy_gradient_wrt_hopping-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{ParameterizedTightBindingModel{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Any}} where D","page":"API","title":"SymmetricTightBinding.energy_gradient_wrt_hopping","text":"energy_gradient_wrt_hopping(\n    ptbm::ParameterizedTightBindingModel{D},\n    k::ReciprocalPointLike{D}\n    (Es, us) = solve(ptbm, k; bloch_phase=Val(false));\n    degen_rtol::Float64 = 1e-12,\n    degen_atol::Float64 = 1e-12\n) where D\n\nReturn the hopping gradient of the energy of each band in ptbm evaluated at momentum k.\n\nThe gradient is computed using the Feynman-Hellmann theorem. For degenerate bands (assessed energetically using relative and absolute tolerances degen_rtol and degen_atol), a degenerate variant is used, equivalent to degenerate perturbation theory.\n\nThe gradient is returned as column vectors, one for each band, with each column containing the gradient of the corresponding energy with respect to the hopping coefficients of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.gradient_wrt_hopping-Tuple{TightBindingModel}","page":"API","title":"SymmetricTightBinding.gradient_wrt_hopping","text":"gradient_wrt_hopping(tbm :: TightBindingModel)\ngradient_wrt_hopping(ptbm :: ParameterizedTightBindingModel)\n\nReturn a structure that encodes the gradient of a tight-binding model tbm or ptbm with respect to the hopping coefficients.\n\nTo evaluate the gradient at a particular momentum k, use the returned structure as a functor at k. I.e., gradient(tbm)(k) returns the gradient of the tight-binding Hamiltonian with respect to all hoppping coefficients at momentum k. This gradient is a vector of matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.obtain_symmetry_related_hoppings-Union{Tuple{V}, Tuple{D}, Tuple{AbstractVector{V}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}} where {D, V<:Union{Crystalline.RVec{D}, AbstractVector{<:Integer}}}","page":"API","title":"SymmetricTightBinding.obtain_symmetry_related_hoppings","text":"obtain_symmetry_related_hoppings(\n    Rs::AbstractVector{V}, \n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D},\n) --> Vector{HoppingOrbit{D}}\n\nCompute the symmetry related hopping terms from the points in WP of br‚Çê to the  WP of br·µ¶ displaced a set of primitive lattice vectors representatives Rs.\n\nImplementation\n\nTake a point a in the WP of br‚Çê and a point b in the WP of br·µ¶. We \n\ncompute the displacement vector Œ¥ = b + R - a, where R ‚àà Rs.\n\nIf Œ¥ ‚àà representatives then we add Œ¥ => (a, b, R) to the list of hoppings   of that representative and continue. If not then, we search inside of all the   representatives for the one that Œ¥ => (a, b, R) in the list of hoppings.   If not found, then we add Œ¥ as a new representative and add Œ¥ => (a, b, R)   to its list of hoppings.\nTake g ‚àà generators and compute Œ¥' = g Œ¥ and (a', b', R') = (g a, g b, g R),   and repeat step 2.\nRepeat all steps 1 to 3 for all pair of points in the WPs of br‚Çê and br·µ¶.\n\nAdditionally, if we have time-reversal symmetry, we check if orbits that relate Œ¥ and  -Œ¥ are present; if not, we add them. The presence or absence of time-reversal symmetry is automatically inferred from br‚Çê and br·µ¶ (which must be identical).\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.pin_free!-Tuple{Crystalline.Collection{<:Crystalline.NewBandRep}, AbstractVector{<:Pair{Int64, <:AbstractVector{<:Real}}}}","page":"API","title":"SymmetricTightBinding.pin_free!","text":"pin_free!(\n    brs::Collection{NewBandRep{D}},\n    idx2Œ±Œ≤Œ≥::Pair{Int, <:AbstractVector{<:Real}}\n)\n\npin_free!(\n    brs::Collection{NewBandRep{D}},\n    idx2Œ±Œ≤Œ≥s::AbstractVector{<:Pair{Int, <:AbstractVector{<:Real}}}\n)\n\nFor idx2Œ±Œ≤Œ≥ = idx => Œ±Œ≤Œ≥, update brs[idx] such that the free parameters of its associated Wyckoff positions are pinned to Œ±Œ≤Œ≥.\n\nA vector of pairs idx2Œ±Œ≤Œ≥s can also be provided, to pin multiple distinct band representations.\n\nSee also pin_free for non-mutated input.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.sgrep_induced_by_siteir-Union{Tuple{D}, Tuple{Union{Crystalline.CompositeBandRep{D}, Crystalline.NewBandRep{D}}, Crystalline.SymOperation{D}}, Tuple{Union{Crystalline.CompositeBandRep{D}, Crystalline.NewBandRep{D}}, Crystalline.SymOperation{D}, Array{Bravais.DirectPoint{D}, 1}}} where D","page":"API","title":"SymmetricTightBinding.sgrep_induced_by_siteir","text":"sgrep_induced_by_siteir(\n    br::Union{NewBandRep, CompositeBandRep},\n    op::SymOperation, [positions::Vector{<:DirectPoint}]\n)\nsgrep_induced_by_siteir(\n    tbm::Union{TightBindingModel,ParameterizedTightBindingModel}, op::SymOperation\n)\n    --> SiteInducedSGRepElement\n\nComputes the representation matrix of a symmetry operation op induced by the site symmetry group associated with an elementary or composite band representation br , including the global momentum-dependent phase factor, returning a SiteInducedSGRepElement, which is a functor over momentum inputs.\n\nA (possibly parameterized) tight-binding model tbm can be specified instead of a band representation, in which case the latter is inferred from the former.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.spectrum-Tuple{ParameterizedTightBindingModel, Any}","page":"API","title":"SymmetricTightBinding.spectrum","text":"spectrum(ptbm::ParameterizedTightBindingModel, ks; transform = identity)\n\nEvaluate the spectrum, i.e., energies, of the tight-binding model ptbm over an iterable of input momenta ks. \n\nEnergies are returned as a matrix, with rows running over momenta and columns over distinct bands.\n\nKeyword arguments\n\ntransform: a function to apply to the resulting matrix of energies, defaulting to the identity function. This can be used to e.g., convert the energies to a different scaling.\n\nExample\n\nAs an example, we evaluating the band structure of graphene. Below, we first construct and parameterize a tight-binding model for the the (2b|A‚ÇÅ) EBR in plane group 17, corresponding to the highest-lying orbitals in graphene. Next, we construct a path along high-symmetry directions of the Brillouin zone using Brillouin.jl, calculate the spectrum across this path; and finally, plot the band structure using Brillouin and GLMakie (or PlotlyJS):\n\njulia> using Crystalline, SymmetricTightBinding\n\njulia> brs = calc_bandreps(17, Val(2));\n\njulia> cbr = @composite brs[5]\n13-irrep CompositeBandRep{2}:\n (2b|A‚ÇÅ) (2 bands)\n\njulia> ptbm = tb_hamiltonian(cbr, [zeros(Int, dim(cbr))])([0.0, 1.0]);\n\njulia> using Brillouin, GLMakie\n\njulia> kpi = interpolate(irrfbz_path(17, directbasis(17, Val(2))), 100);\n\njulia> plot(kpi, spectrum(ptbm, kpi))\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.spectrum-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, AbstractVector{<:Real}}} where D","page":"API","title":"SymmetricTightBinding.spectrum","text":"spectrum(ptbm::ParameterizedTightBindingModel, k::AbstractVector{<:Real})\n\nEvaluate the spectrum, i.e., energies, of the tight-binding model ptbm at a single momentum k, across all the bands of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.symmetry_eigenvalues-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, AbstractArray{Crystalline.SymOperation{D}, 1}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{ParameterizedTightBindingModel{D}, AbstractArray{Crystalline.SymOperation{D}, 1}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, AbstractArray{SymmetricTightBinding.SiteInducedSGRepElement{D}, 1}}} where D","page":"API","title":"SymmetricTightBinding.symmetry_eigenvalues","text":"symmetry_eigenvalues(\n    ptbm::ParameterizedTightBindingModel{D},\n    ops::AbstractVector{SymOperation{D}},\n    k::ReciprocalPointLike{D},\n    [sgreps::AbstractVector{SiteInducedSGRepElement{D}}]\n)\nsymmetry_eigenvalues(\n    ptbm::ParameterizedTightBindingModel{D},\n    lg::LittleGroup{D},\n    [sgreps::AbstractVector{SiteInducedSGRepElement{D}}]\n)\n    --> Matrix{ComplexF64}\n\nCompute the symmetry eigenvalues of a coefficient-parameterized tight-binding model ptbm at the k-point k for the symmetry operations ops. A LittleGroup can also be provided instead of ops and k.\n\nRepresentations of the symmetry operations ops as acting on the orbitals of the tight-binding setting can optionally be provided in sgreps (see sgrep_induced_by_siteir) and are otherwise initialized by the function.\n\nThe symmetry eigenvalues are returned as a matrix, with rows running over the elements of ops and columns running over the bands of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.tb_hamiltonian-Union{Tuple{Crystalline.CompositeBandRep{D}}, Tuple{D}, Tuple{Crystalline.CompositeBandRep{D}, AbstractVector{Vector{Int64}}}} where D","page":"API","title":"SymmetricTightBinding.tb_hamiltonian","text":"tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) \n    --> Vector{TightBindingTerm{D}}\n\nConstruct the TB Hamiltonian matrix from a given composite band representation cbr and a set of global translation-representatives Rs. The Hamiltonian is constructed block by block according to the symmetry-related hoppings between the band representations in cbr. Several models returned, each representing a term that is closed under the symmetry operations of  the underlying space group.\n\n\n\n\n\n","category":"method"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#SymmetricTightBinding.HoppingOrbit","page":"API","title":"SymmetricTightBinding.HoppingOrbit","text":"HoppingOrbit{D}\n\nA structure holding information about symmetry-related spatial hopping vectors.\n\nAn orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the symmetry operations of the underlying space group to a representative vector Œ¥.\n\nFor each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site a to site b, possibly related by a lattice translation R. Each such set of possible hopping term (a, b, R) is for each Œ¥·µ¢ is stored elements as the ith element of the vector hoppings.\n\nFields\n\nrepresentative :: RVec{D}: the representative hopping vector Œ¥\norbit :: Vector{RVec{D}}: the Œ¥·µ¢ elements of the orbit generated by Œ¥. Generally orbit[1] == representative, i.e., Œ¥‚ÇÅ = Œ¥\nhoppings :: Vector{Vector{NTuple{3,RVec{D}}}}: the ith element gives the possible physical hopping terms (a,b,R) associated to orbit[i]. Multiple physical hopping terms may correspond to each element of the orbit.  For (a, b, R) = hoppings[i][j], we have orbit[i] = Œ¥·µ¢ = b + R - a\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.ParameterizedTightBindingModel","page":"API","title":"SymmetricTightBinding.ParameterizedTightBindingModel","text":"ParameterizedTightBindingModel{D}\n\nA coefficient-parameterized tight-binding model, that can be used as a functor for evaluation at input momenta k.\n\nFields\n\ntbm :: TightBindingModel{D}: A tight-binding model, consisting of a set of a list of TightBindingTerm{D}s.\ncs :: Vector{Float64}: A vector of coefficients, each associated to a corresponding element of tbm.\nscratch :: Matrix{ComplexF64}: A scratch space for evaluating the Hamiltonian matrix at at specific momenta. This is a N√óN matrix, where N is the number of orbitals in tbm (i.e., tbm.N). The scratch space is instantiated automatically on construction.\n\nFunctor over momenta\n\nA ParameterizedTightBindingModel ptbm can be be evaluated at any ¬¥D-dimensional momentumkby usingptbmas a functor. That is,ptbm(k)returns a numerical representation of the Hamiltonian matrix forptbmevaluated at momentumk.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.TightBindingElementString","page":"API","title":"SymmetricTightBinding.TightBindingElementString","text":"TightBindingElementString\n\nA structure for pretty-printing tight-binding matrix elements.\n\nFields\n\ns :: String: the string representing the tight-binding matrix element\nactive :: Bool: whether the element belongs to an \"active\" block - i.e., one we want to highlight (then shown in blue).\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.TightBindingModel","page":"API","title":"SymmetricTightBinding.TightBindingModel","text":"TightBindingModel{D}\n\nA structure storing a list of TightBindingTerm{D}s. Each term is assumed to associated with an identical list of EBRs.\n\nTo associate a set of coefficients to each term, see ParameterizedTightBindingModel, which also allows evaluation at specific momenta.\n\nFields\n\nterms :: Vector{TightBindingTerm{D}}: a vector of TightBindingTerm{D}s, each of which represents a block (or conjugated pairs of blocks) of the Hamiltonian matrix.\ncbr :: CompositeBandRep{D}: the composite band representation associated to the model.\npositions :: Vector{DirectPoint{D}}: a vector of positions, specified in the lattice basis, associated to each orbital of the model.\nN :: Int: the total number of orbitals in the model, i.e., the size of the Hamiltonian matrix associated to each element of terms.\n\n\n\n\n\n","category":"type"},{"location":"symmetry-breaking/#Symmetry-breaking","page":"Symmetry breaking","title":"Symmetry breaking","text":"","category":"section"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"A frequent question in tight-binding modelling is whether ‚Äì and which ‚Äì new hoppings terms might become allowed if the overall symmetry is reduced, either by breaking spatial symmetries or time-reversal symmetry. Such terms might e.g., break degeneracies or enable topological phase transitions.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"SymmetricTightBinding.jl exports complement as a tool to answer exactly this question. Here, we apply it to understand the effect of symmetry breaking on a 2-band model in plane group p4mm (‚ãï11).","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"We start by constructing our symmetry-unbroken model, picking the (2c|A‚ÇÅ) band representation of p4mm:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"using Crystalline, SymmetricTightBinding\nbrs = calc_bandreps(11, Val(2))\ncbr = @composite brs[1]\ntbm = tb_hamiltonian(cbr, [[0,0], [1,0]])\nptbm = tbm([0, 1, -1, 1])","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"note: Interpretation of tight-binding terms\nWe can visualize the tight-binding terms using plot, providing also a lattice basis for the illustration:using GLMakie\nplot(tbm, directbasis(11, Val(2)))While terms 3 and 4 appear identical in this visualization, they are not (cf. issue #75): in term 3, horizontal hoppings (Œ¥‚ÇÅ and Œ¥‚ÇÇ) are associated to the first Wyckoff position (at [1/2, 0]) and vertical hoppings to the second Wyckoff position (at [0, 1/2]), and vice versa for term 4.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"The parameterized model has a quadratic degeneracy at M, associated with the M‚ÇÖ irrep:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"using Brillouin, GLMakie\nRs = directbasis(11, Val(2))\nkp = irrfbz_path(11, Rs)\nkpi = interpolate(kp, 100);","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"plot(kpi, spectrum(ptbm, kpi))","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Next, we may study which terms become allowed if we break either time-reversal symmetry or the mirror symmetries of the system. In the latter case, this corresponds to lowering the plane group symmetry to p4 (‚ãï10):","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Œîtbm_mirror = complement(tbm, 10)                   # maintain TR, break mirror symmetry\nŒîtbm_tr = complement(tbm, 11; timereversal = false) # maintain spatial symmetries, break TR","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"todo: Todo\nIs the above for Œîtbm_tr wrong? It looks wrong relative to the result below. Maybe the effect of breaking either is equivalent, but the effect of breaking both is \"more than the sum of their parts\" - would make sense.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"We can also break both simultaneously:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Œîtbm = complement(tbm, 10; timereversal = false)","category":"page"},{"location":"theory/#Theory-Notes","page":"Theory","title":"Theory Notes","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"This package heavily relays on representation theory of groups and in band theory of crystals. Almost all this theory was introduced before, and, can be found in Bradley & Cracknell and, later, developed by Bradlyn et al.. Here, we aim to make a practical introduction to the main concepts and deduce the essential functions and relations that we needed for the implementation of this package. Additionally, we generalize some of the results previously derived and make them more accessible to the general public.","category":"page"},{"location":"theory/#Table-of-contents","page":"Theory","title":"Table of contents","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Theory Notes\nTable of contents\nIntroduction\nTransformation properties of orbitals\nTransformation properties of induced Bloch functions\nBuild a tight-binding Hamiltonian from a set of symmetric orbitals\nTransformation properties of the Bloch states\nTransformation properties under lattice translations\nTransformation properties under symmetry operations\nAppendix A\nTransformation properties within Convention 2\nBloch Hamiltonian under Convention 2\nBloch states under Convention 2\nTransformation under lattice translations\nTransformation properties under symmetry operations\nConversions between Convention 1 and 2","category":"page"},{"location":"theory/#Introduction","page":"Theory","title":"Introduction","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The introduction of Topological Quantum Chemistry (TQC) made a link between trivial insulators and atomic limits. It states that if a set of isolated bands can be described by a set of isolated ‚Äî atomic-like ‚Äî orbitals, the set must be topologically trivial. This link is determined by, first, analyzing all band symmetries of this \"atomic-like\" orbitals. Then, the band's set under study will be non-trivial if it doesn't fit in that list.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The analysis of the band symmetries of the isolated orbitals can be performed by placing localized, symmetric orbitals at some high-symmetry points ùê™_Œ± ‚Äî Wyckoff position ‚Äî with some internal symmetry ‚Äî corresponding to a particular site-symmetry irrep œÅ. Those orbitals can be labeled as œï_Œ±i(ùê´), where i runs in the dimension of the irrep œÅ, or just by (ùê™_Œ±œÅ). By applying the Fourier transform, the induced Bloch functions can be obtain as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÜ_Œ±iùê§(ùê´) = sum_ùê≠ e^iùê§ùê≠ œï_Œ±i(ùê´-ùê≠)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"How œÜ_Œ±iùê§(ùê´) transform under symmetries will define a band representation.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The idea behind this package is to use these orbitals to build a tight-binding model that respect the symmetries and topology of the (trivial) set of bands whose band representation is matched by such set of orbitals.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To do so, it is necessary to access all possible types of symmetry-independent orbitals and high-symmetry points in every space group. Luckily, this was tabulated by Bradley & Cracknell and implemented in the Julia package Crystalline.jl. This package is going to depend on the former package to access that information.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now that the basic framework has been stablish, in the following sections, we are going to deduce how those functions will transform and how they can be used to build a symmetric tight-binding model.","category":"page"},{"location":"theory/#Transformation-properties-of-orbitals","page":"Theory","title":"Transformation properties of orbitals","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us assume we have identified a set of orbitals that describe the band structure of a trivial set of bands. This can be achieved through a TQC analysis of the bands, and several tools exist to perform such decomposition. For example, the package PhotonicTightBinding.jl provides this functionality for photonic bands.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[!NOTE] For instance, Graphene's two p<sub>z</sub> orbitals sit at the 2b Wyckoff position. Although these orbitals are odd (i.e., changing sign) under mirror in the out-of-plane direction, they are even (i.e., invariant) under all in-plane symmetries, including rotations and mirrors. The corresponding site-symmetry irrep is the A‚ÇÅ irrep of the 2b Wyckoff position. Thus, these orbitals can be expressed as (2b|A‚ÇÅ). However, take into account that not all band representations can be induced from a set of atomic (electronic) orbitals. Some might correspond to a hybridization or a complex mixture of them.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us denote by Œ± as the site in the Wyckoff position where the orbital is located, and i labels the number of orbitals associated to that site. Then, the orbital i at site Œ± can be denoted as œï_I(ùê´), where we introduce the compound index I=(Œ± i). The complete set of orbitals that will be needed to describe the system is obtained by considering all orbitals at all sites and all lattice translations of them, i.e., œï_I(ùê´-ùê≠)_Iùê≠, where ùê≠ is a lattice translation vector.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We are going to focus on a particular site ùê™_1, whose orbitals œï_1i(ùê´) will transform under a particular site-symmetry representation œÅ of the site-symmetry group G_ùê™_1. Then, for h  G_ùê™_1, this function will transform as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"h œï_1i(ùê´) = œÅ(h)_ji œï_1j(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since the orbitals are localized at a Wyckoff position, there exist a coset decomposition of the space group G that relates each site in the Wyckoff position, i.e., ùê™_Œ± = g_Œ± ùê™_1 with g_Œ±  G.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[!NOTE] The set of g_Œ±, in combination with translations T, will generate a decomposition of G with respect to G_ùê™:G = bigcup_Œ± g_Œ± (G_ùê™_1 ltimes T)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Thus, each function in the unit cell can be built from the ones at site ùê™_1 as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œï_Œ±i(ùê´) = g_Œ± œï_1i(ùê´) = œï_1i(g_Œ±^-1 ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"By extension, translated counterparts can be defined by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Eùê≠ œï_I(ùê´) = œï_I(ùê´-ùê≠)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The aforementioned coset decomposition also have an interesting implication: for any operation g = RùêØ  G, there is an unique choice of Œ≤ for each Œ± such that g g_Œ± = Eùê≠_Œ≤Œ± g_Œ≤ h, for some h  G_ùê™_1 and ùê≠_Œ≤Œ± = g ùê™_Œ± - ùê™_Œ≤. The formal proof of this statement is out of the scope of this notes and can be found in this article. An intuitive picture of this statement is represented by the following figure:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: Coset decomposition)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Taking into consideration the definitions of the transformed orbitals and the previous decomposition, we deduce that the orbitals transform under the induced representation œÅ_G according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÅ_G(g) œï_Œ±i(ùê´-ùê≠) = g Eùê≠ œï_Œ±i(ùê´) \n= ERùê≠ g œï_Œ±i(ùê´) \n= ERùê≠ Eùê≠_Œ≤Œ± g_Œ≤ h g_Œ±^-1 œï_Œ±i(ùê´) \n= ERùê≠ + ùê≠_Œ≤Œ± g_Œ≤ h œï_1i(ùê´) \n= sum_j ERùê≠ + ùê≠_Œ≤Œ± g_Œ≤ œÅ(h)_ji œï_1j(ùê´) \n= sum_j œÅ(h)_ji ERùê≠ + ùê≠_Œ≤Œ± œï_Œ≤j(ùê´) \n= sum_j œÅ(h)_ji œï_Œ≤j(ùê´ - Rùê≠ - ùê≠_Œ≤Œ±)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In principle, we could use the complete set of orbitals ‚Äî œï_I(ùê´-ùê≠), with all degrees of freedom I and all lattice translations ùê≠ ‚Äî to build a tight-binding model. However, it is more practical (and usual) to use the translational invariance of this orbitals to define a Fourier transform, and use their Fourier transformed functions as a basis ‚Äî we are going to label such functions as induced Bloch functions. By doing so, instead of working with dim(I) times N orbitals, where dim(I) is the number of sites plus the number of orbitals at each site and N is the number of unit cells; you can consider dim(I) functions evaluated at N points inside the Brillouin zone.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"However, when defining a Fourier transform, there is a gauge freedom which leads to different, so-called, \"conventions\". This choice has important implications on the representations of the symmetry operations and, even, in the representation of the Hamiltonian. Here, we are going to focus on one convention, and we are going to discuss changes and similarities with another convention in Appendix A.","category":"page"},{"location":"theory/#Transformation-properties-of-induced-Bloch-functions","page":"Theory","title":"Transformation properties of induced Bloch functions","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Using the translational invariance of the orbitals, we can formally define a Fourier transform of them. This functions will not be solution to any Schr√∂dinger-like problem, so instead of calling them Bloch states we pick up the term of induced Bloch functions, or just Bloch functions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As mentioned before, there is a gauge freedom on the choice of the Fourier transform. Here, we are going to choose the following one:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÜ_Iùê§(ùê´)  sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) œï_I(ùê´-ùê≠)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The main reason behind this choice is due to fact that, with this gauge choice, the ùê§-space dependence of the space group transformations' representations enters as a global phase, as we will see. This is really convenient for computation purposes and that is why we picked it. However, this convention enforced that the Bloch functions are not periodic in reciprocal space:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÜ_Iùê§+ùêÜ = sum_ùê≠ e^i(ùê§+ùêÜ)(ùê≠+ùê™_Œ±) œï_I(ùê´-ùê≠) \n= sum_ùê≠ e^iùêÜ(ùê≠+ùê™_Œ±) e^iùê§(ùê≠+ùê™_Œ±) œï_I(ùê´-ùê≠) \n= e^iùêÜùê™_Œ± œÜ_Iùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This implies that if the orbital is located at a non-integer position in the unit-cell, i.e, located at positions that are integer combinations of lattice vectors, the phase factor will differ from unity and the Bloch function will gain a phase. This yields that, in general, Bloch functions are not periodic under reciprocal lattice translations within this convention. This has interesting implications in the computation of some parts of this package, such as, the representation of symmetry operations or symmetry eigenvalues.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since this functions are derived from the orbitals, the transformations properties of this functions can be obtained. How this functions transform under symmetry operations will conform what is usually called a band representation. In particular, this band representation will be:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g œÜ_iŒ±ùê§(ùê´) = frac1sqrtN sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) g œï_iŒ±(ùê´-ùê≠) \n= frac1sqrtN sum_ùê≠j e^iùê§(ùê≠+ùê™_Œ±) œÅ(h)_ji œï_jŒ≤(ùê´-Rùê≠-ùê≠_Œ≤Œ±) \n= frac1sqrtN sum_ùê≠j œÅ(h)_ji e^iùê§R^-1(ùê≠+ùê™_Œ≤-ùêØ) œï_jŒ≤(ùê´-ùê≠) \n= e^-i(R^-1^T ùê§)ùêØ frac1sqrtN sum_ùê≠j œÅ(h)_ji e^i(R^-1^T ùê§)(ùê≠+ùê™_Œ≤) œï_jŒ≤(ùê´-ùê≠) \n= e^-i(R^-1^T ùê§)ùêØ sum_j œÅ(h)_ji œÜ_jŒ≤R^-1^T ùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have defined ùê≠ = Rùê≠ + ùê≠_Œ≤Œ±  ùê≠ = R^-1 (ùê≠-ùê≠_Œ≤Œ±), and we have used the following property: ùê§(R ùê´) = (R^T ùê§)ùê´. Finally, if the define the action of a symmetry operation g = RùêØ on a reciprocal space vector ùê§ as: gùê§  R^-1^T ùê§, we can rewrite the previous relation as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g œÜ_Iùê§(ùê´) = e^-i(g ùê§)ùêØ sum_J œÅ(h)_JI œÜ_Jg ùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This relation will be crucial in the implementation of the package, since it states the band representation of the system. If a tight-binding model is built from this set of functions, its band structure will, by construction, replicate the one of the original system. In other words, the tight-binding model will inherit all symmetries of the system, forcing the same degeneracies the system has, and exhibit the same symmetry-indicated topology.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the sake of simplicity, we are going to define a matrix D_ùê§(g), whose entries will be conformed by the previous operation, i.e., D_ùê§(g)_JI = e^-i(g ùê§)ùêØ œÅ(h)_JI, where remember that: I = (Œ±i), J = (Œ≤j) and ùê≠_Œ≤Œ± = g ùê™_Œ± - ùê™_Œ≤. Then, we can rewrite the previous relation as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"boxedg œÜ_Iùê§(ùê´) = sum_J D_ùê§(g)_JI œÜ_Jg ùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"It is important to notice that the dependence on ùê§ of the representation D_ùê§ is a global phase factor. This is really convenient for computational purposes when imposing the symmetry constraints in the Hamiltonian.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, our next objective is to build a tight-binding model that uses this functions as basis and replicates the band structure of the system. We perform this construction in the next section.","category":"page"},{"location":"theory/#Build-a-tight-binding-Hamiltonian-from-a-set-of-symmetric-orbitals","page":"Theory","title":"Build a tight-binding Hamiltonian from a set of symmetric orbitals","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Second quantization rephrases quantum mechanics in terms of fields and occupation numbers. Instead of tracking individual particles, we describe how many particles occupy each quantum state. This is ideal for many-body physics and that's why we are going to implement it here.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In order to do so, we need to introduce a creation and annihilation operators. Since we want to use the basis of orbitals previously introduced, we can define them as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœï_Iùê≠  ƒâ^_Iùê≠ kettextvac","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, the most general tight-binding Hamiltonian can be written using those operators as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùê≠ùê≠ h_IJùê≠-ùê≠ ƒâ^_Iùê≠ ƒâ_Jùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This Hamiltonian reads that the probability of \"hopping\" from an orbital ketœï_Jùê≠ to an orbital ketœï_Iùê≠ is given by the amplitude term h_IJùê≠-ùê≠. Notice that we assumed that the hopping amplitude only depends on the relative distance between both orbitals. This implies that the Hamiltonian will be translational invariant, as it should be. In the following, we are going to refer to that distance as ùêë = ùê≠-ùê≠. Realize that it must be a lattice translation. Using this definition we can rewrite the previous Hamiltonian as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùêëùê≠ h_IJùêë ƒâ^_Iùêë+ùê≠ ƒâ_Jùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In order to be consistent with the previous choice of the Fourier transform, we obtain that the creation operator in reciprocal space must be related to ƒâ^_Iùê≠ as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœÜ_Iùê§ = √¢_Iùê§^ kettextvac \n= frac1sqrtN sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠ = frac1sqrtN sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) ƒâ_Iùê≠^ kettextvac \n √¢_Iùê§^ = frac1sqrtN sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) ƒâ_Iùê≠^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that since œÜ_Iùê§+ùêÜ(ùê´) = e^iùêÜùê™_Œ± œÜ_Iùê§(ùê´), we also have that √¢_Iùê§+ùêÜ^ = e^iùêÜùê™_Œ± √¢_Iùê§^, consistently.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Considering this, we can rewrite the tight-binding Hamiltonian in reciprocal space as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = frac1N sum_IJùêëùê≠ h_IJùêë sum_ùê§ùê§ e^iùê§(ùêë+ùê≠+ùê™_Œ±) e^-iùê§(ùê≠+ùê™_Œ≤) √¢_Iùê§^ √¢_Jùê§ \n= frac1N sum_IJùêëùê≠ùê§ùê§ h_IJùêë e^iùê§(ùêë+ùê™_Œ±) e^i(ùê§-ùê§)ùê≠ e^-ùê§ùê™_Œ≤ √¢_Iùê§^ √¢_Jùê§ \n= sum_IJùêëùê§ h_IJùêë e^iùê§(ùêë+ùê™_Œ±-ùê™_Œ≤) √¢_Iùê§^ √¢_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have used the property of exponential functions: sum_ùê≠ e^i(ùê§-ùê§)ùê≠ = N Œ¥_ùê§ùê§.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Finally, if we define h_IJùê§ = sum_ùêë h_IJùêë e^iùê§(ùêë+ùê™_Œ±-ùê™_Œ≤), we obtain the usual expression for a tight-binding Hamiltonian in reciprocal space:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùê§ h_IJùê§ √¢_Iùê§^ √¢_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As shown, the hopping amplitude in reciprocal space is computed from a summatory of the real space hopping amplitudes for all lattice translations ùêë. Usually, such summation is cut with some \"arbitrary\" (subjective) cutoff. One common approach is to just consider a certain number of nearest neighbors. Since we are interested in building a symmetry-constrained tight-binding model, as the symmetry-related terms might not be equal to the number of n-th nearest neighbors, we are going to consider a different approach. As we are going to develop later, our strategy will be focus on asking the user to provide a set of ùêë-vectors where to look, at least, for hopping terms, and then, search for all symmetry-related terms starting from that initial, but potentially not complete, set.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As can be seen, the tight-binding Hamiltonian is diagonal in reciprocal space. This is due to the assumption that the Hamiltonian must be translational invariant. Then, it is natural to define what is usually called the Bloch Hamiltonian ƒ§_ùê§, which consist on the diagonal blocks in reciprocal space of the tight-binding Hamiltonian:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§ = sum_IJ h_IJùê§ √¢_Iùê§^ √¢_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Some general properties must be fulfilled independent of its representation, such as its periodicity in reciprocal space. However, as shown above, the creation and annihilation operators are not periodic under reciprocal lattice translations and we also have that:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"h_IJùê§+ùêÜ = sum_ùêë h_IJùêë e^i(ùê§+ùêÜ)(ùêë+ùê™_Œ≤-ùê™_Œ±) \n= e^iùêÜ(ùê™_Œ≤-ùê™_Œ±) sum_ùêë h_IJùêë cancele^iùêÜùêë e^iùê§(ùêë+ùê™_Œ≤-ùê™_Œ±) \n= e^iùêÜ(ùê™_Œ≤-ùê™_Œ±) h_IJùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"However, all these phase factors cancel out in the Bloch Hamiltonian so it is translational invariant in reciprocal space, as can be seeing:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§+ùêÜ = sum_IJ h_IJùê§+ùêÜ √¢_Iùê§+ùêÜ^ √¢_Jùê§+ùêÜ \n= sum_IJ e^iùêÜ(ùê™_Œ≤-ùê™_Œ±) h_IJùê§ e^iùêÜùê™_Œ± √¢_Iùê§^ e^-iùêÜùê™_Œ≤ √¢_Jùê§ \n= sum_IJ h_IJùê§ √¢_Iùê§^ √¢_Jùê§ = ƒ§_ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, we obtain the important translational invariance in reciprocal space of the Bloch Hamiltonian: ƒ§_ùê§+ùêÜ = ƒ§_ùê§. This property allow us to just consider the first Brillouin zone when we examine the Bloch Hamiltonian.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch Hamiltonian can be expressed as a matrix by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§ = √Ç_ùê§^ H_ùê§ √Ç_ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where √Ç_ùê§^ =  √¢_1ùê§^ √¢_2ùê§^   is a row vector collecting all creation operators, similarly with √Ç_ùê§, and H_ùê§ is a complex matrix which each entry is defined by: H_ùê§_IJ  h_IJùê§. The matrix H_ùê§ is the one we are going to use in our package to compute the eigenvectors and eigenvalues for each ùê§-point.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this matrix H_ùê§ is strongly dependent on the Fourier transformation picked. As proved above, within this convention, this matrix is not invariant under reciprocal lattice translations. However, this does not hold under other conventions as exposed in Appendix A. This property is not suitable for computing some fundamental properties such as the symmetry eigenvalues, but it will have some computational advantages when encoding the matrix representation H_ùê§ in the package.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Before proceeding, we are going to deduce the constraints that the symmetries of the system impose on the matrix H_ùê§. This will ensure that the model replicates the symmetry and (symmetry-indicated) topology of the system. For that purpose, first, we are going to deduce how the creation and annihilation operators transform under the symmetry operations. Let us start with the creation operator:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒù √¢_Iùê§^ ƒù^-1 kettextvac = ƒù √¢_Iùê§^ kettextvac = ƒù ketœÜ_Iùê§ \n= sum_J D_ùê§(g)_JI ketœÜ_Jgùê§ = sum_J D_ùê§(g)_JI √¢_Jgùê§^ kettextvac \n ƒù √¢_Iùê§^ ƒù^-1 = sum_J D_ùê§(g)_JI √¢_Jgùê§^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since the symmetry operations ƒù are unitary, i.e., ƒù^-1 = ƒù^, we can easily deduce the transformation properties of the annihilation operator from the creation one, and it reads as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒù √¢_Iùê§ ƒù^-1 = sum_J D_ùê§^*(g)_JI √¢_Jgùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Considering this two transformation properties of the operators, we can deduce the set of relations that the symmetry operations will enforce in the Bloch Hamiltonian. The invariance of the Hamiltonian under symmetry operations reads as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = ƒù ƒ§ ƒù^-1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Expanding the Hamiltonian in terms of the creation and annihilation operator basis leads us to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"sum_IJùê§ √¢_Iùê§^ h_IJùê§ √¢_Jùê§ = sum_IJùê§ ƒù √¢_Iùê§^ h_IJùê§ √¢_Jùê§ ƒù^-1 \n= sum_IJùê§ ƒù √¢_Iùê§^ ƒù^-1 h_IJùê§ ƒù √¢_Jùê§ ƒù^-1 \n= sum_IJùê§IJ D_ùê§(g)_II √¢_Igùê§^  h_IJùê§ D_ùê§^*(g)_JJ √¢_Jgùê§ \n= sum_ùê§IJ √¢_Igùê§^ D_ùê§(g) H_ùê§ D_ùê§^(g)_IJ √¢_Jgùê§ \n boxedH_gùê§ = D_ùê§(g) H_ùê§ D_ùê§^(g)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This symmetry constraints strongly restrict the functional form of H_ùê§. Rather than being a completely general Hermitian (or anti-Hermitian) matrix, H_ùê§ must now lie in the subspace of matrices that fulfill the previous constraints. This ensures that the model preserves all symmetries and reproduces the correct degeneracies and connectivity of the original band structure.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Additionally, as exposed above, the ùê§-dependence on the representation matrices of operations D_ùê§ is only a global phase factor, so it can be dropped in the previous relation. This is really practical in the implementation of the package since the ùê§-dependence on the previous relation will be just located at the matrix H_ùê§ making it easier to encode in non-symbolic programming languages as Julia.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As stated previously, we are interested on diagonalizing this matrix and find the eigenvectors and eigenvalues associated to it at each ùê§-point. Those eigenvectors will correspond to a vector of coefficients, associated to the basis set we built the Bloch Hamiltonian on, and will describe the Bloch state of the system at a particular ùê§-point and energy. In the following section, we will elaborate on this topic and will develop how this Bloch states will transform under the symmetry operations of the system. A sanity check will be to compare the band representation of both, the real system's band structure and the tight-binding model's band structure, which should be equal.","category":"page"},{"location":"theory/#Transformation-properties-of-the-Bloch-states","page":"Theory","title":"Transformation properties of the Bloch states","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Until now we have focus on building a symmetry-constrained Hamiltonian to model the band structure of a physical system. Now, we shift our attention to analyze the properties of the Bloch states of the model, which must replicate the band structure of the physical system.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us start by defining the eigenvalue problem from where we start:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"H_ùê§ ùê∞_nùê§ = E_nùê§ ùê∞_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where E_nùê§ is the set of eigenvalues (energies) at each ùê§-point and ùê∞_nùê§ the set of eigenvectors associated to them. Each eigenvector is a vector of coefficients which will correspond to a particular Bloch state in the basis used for describing the Bloch Hamiltonian, i.e.:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœà_nùê§ = sum_I w_Inùê§ ketœÜ_Iùê§ = frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now that the Bloch states have been defined, we can deduce their transformation properties. First, we are going to analyze their transformation properties under lattice translations in real and reciprocal space, and later, we will analyze their transformation properties under symmetry operation of the space group of the crystal.","category":"page"},{"location":"theory/#Transformation-properties-under-lattice-translations","page":"Theory","title":"Transformation properties under lattice translations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here we are going to analyze how the Bloch states of the model transform under lattice translations in real and in reciprocal space. They should transform as Bloch functions transform under these transformations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Firstly, let us start with lattice translations in real space:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œà_nùê§(ùê´+ùêë) = braketùê´+ùêëœà_nùê§ \n= frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) braketùê´+ùêëœï_nùê≠ \n= frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) braketùê´œï_nùê≠-ùêë \n= e^iùê§ùêë frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠-ùêë+ùê™_Œ±) braketùê´œï_nùê≠-ùêë \n= e^iùê§ùêë braketùê´œà_nùê§ = e^iùê§ùêë œà_nùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch states transform as Bloch functions under translations in real space, as expected.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, let us analyze how they transform under reciprocal lattice translations. Remind that, within this convention, the matrix representation H_ùê§ is not periodic under reciprocal lattice translations. This implies that ùê∞_nùê§ will not be either, but the eigenvalues E_nùê§ must be periodic since does are the energies associated to each Bloch state ‚Äî independent of the basis chosen to represent the Hamiltonian. Let us analyze this odd behavior:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"H_ùê§+ùêÜ ùê∞_nùê§+ùêÜ = E_nùê§+ùêÜ ùê∞_nùê§+ùêÜ \n sum_J h_IJùê§+ùêÜ w_Jnùê§+ùêÜ = E_nùê§ w_Inùê§+ùêÜ \n sum_J e^iùêÜ(ùê™_Œ≤-ùê™_Œ±) h_IJùê§ w_Jnùê§+ùêÜ = E_nùê§ w_Inùê§+ùêÜ \n sum_J h_IJùê§ e^iùêÜùê™_Œ≤ w_Jnùê§+ùêÜ = E_nùê§ e^iùêÜùê™_Œ± w_Inùê§+ùêÜ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, this implies that the eigenvectors gain a phase factor we translated in reciprocal space such that:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"w_Inùê§+ùêÜ = e^-iùêÜùê™_Œ± w_Inùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To make this easier, we ca define a diagonal matrix such that Œò_ùêÜ_II = e^-iùêÜùê™_Œ±, then the previous expression can be rewritten as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùê∞_nùê§+ùêÜ = Œò_ùêÜ ùê∞_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this transformation is not a simple phase factor ‚Äî which is indeterminate on eigenvectors, yet it acts differently in each entry of the eigenvector. This extra factor is crucial when analyzing the invariance of the Bloch states under reciprocal lattice translations, as we will see now.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us deduce how Bloch states will transform under reciprocal lattice translations:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœà_nùê§+ùêÜ = frac1sqrtN sum_Iùê≠ w_Inùê§+ùêÜ e^i(ùê§+ùêÜ)(ùê≠+ùê™_Œ±) ketœï_Iùê≠ \n= frac1sqrtN sum_Iùê≠ cancele^-iùêÜùê™_Œ± w_Inùê§ cancele^iùêÜùê≠ cancele^iùêÜùê™_Œ± e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠ \n= frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠ = ketœà_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch states will be invariant under reciprocal lattice translations. This is an important feature and must remain independently of which basis is used for representing the Hamiltonian. This property is proven for another Fourier convention in Appendix A.","category":"page"},{"location":"theory/#Transformation-properties-under-symmetry-operations","page":"Theory","title":"Transformation properties under symmetry operations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here we analyze how the Bloch states transform under more complex symmetry operations g = RùêØ that might involve translations ùêØ and site-symmetry operations R. The Bloch state will transform under this operations as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒù ketœà_nùê§ = sum_I w_Inùê§ ƒù ketœÜ_Iùê§ \n= sum_IJ w_Inùê§ D_ùê§(g)_JI ketœÜ_Jgùê§ \n= sum_IJ D_ùê§(g)_JI w_Inùê§ ketœÜ_Jgùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We are particularly interested in the transformation under operations ƒù in the little-group G_ùê§ of a particular ùê§-point. This operations will leave invariant the particular ùê§-point up to a lattice translation, i.e., g ùê§ = ùê§ + ùêÜ. How these functions transform under those operations at each high-symmetry point will allow us to assign an irrep to each of the Bloch states at that ùê§-point. Those should coincide with the ones obtained from the original system's band structure. The irrep could be assigned by computing the symmetry eigenvalues associated to each Bloch state. Those are compute by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"braketœà_nùê§ƒùœà_nùê§ = sum_IJ (w_Inùê§)^* w_Jnùê§ braketœÜ_Iùê§ƒùœÜ_Jùê§ \n= sum_IJJ (w_Inùê§)^* w_Jnùê§ D_ùê§(g)_JJ braketœÜ_Iùê§œÜ_Jgùê§ \n= sum_IJJ (w_Inùê§)^* w_Jnùê§ D_ùê§(g)_JJ braketœÜ_Iùê§œÜ_Jùê§+ùêÜ \n= sum_IJJ (w_Inùê§)^* w_Jnùê§ D_ùê§(g)_JJ e^iùêÜùê™_Œ≤ braketœÜ_Iùê§œÜ_Jùê§ \n= sum_IJJ (w_Inùê§)^* w_Jnùê§ D_ùê§(g)_JJ e^iùêÜùê™_Œ≤ delta_IJ \n= sum_IJ (w_Inùê§)^* e^iùêÜùê™_Œ± D_ùê§(g)_IJ w_Jnùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have used how the Bloch functions transform under reciprocal lattice translations ‚Äî a property inherit from the convention choice ‚Äî and their orthogonality.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this expression has a phase factor that needs to be accounted for. In other conventions this phase factor does not appears making it easier to compute. Nevertheless, we stick to the current convention due to the property of the ùê§-dependence in the representation matrices of symmetry operations. However, it is interesting to be able to change from one convention to others. Because of that, we include some functions in the package to be able to change from one convention to another one ‚Äî heavily used in the literature. The relation between these two conventions can be found in Appendix A.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Finally, it is interesting to vectorize the previous expression in order to implemented it in the package. To do so, we make use of the previous phase factor matrix Œò_ùê§. Making use of it, the previous expression can be written as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"boxedbraketœà_nùê§ƒùœà_nùê§ = (Œò_ùêÜ ùê∞_nùê§)  (D_ùê§(g) ùê∞_nùê§)","category":"page"},{"location":"theory/#Appendix-A","page":"Theory","title":"Appendix A","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In this appendix we aim to present, develop and compare two of the main conventions present on the literature for Fourier transforms. The two Fourier transform conventions we are going to analyze are:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Convention 1: œÜ^(1)_Iùê§(ùê´)  sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) œï_I(ùê´-ùê≠)\nConvention 2: œÜ^(2)_Iùê§(ùê´)  sum_ùê≠ e^iùê§ùê≠ œï_I(ùê´-ùê≠)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where Convention 1 is the one we have been using in the theory notes and Convention 2 is another one commonly used in the literature and other packages such as Bradlyn et al.. This second convention does not includes the position of the orbital ùê™_Œ± in the phase factor of the Fourier transform.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The former is the one used in the PythTB package, where they claim it to be more suitable for computing topological invariants as Berry phases or Wilson loops. The later is more common in the literature since it is not necessary to trace back the extra phase factor. Additionally, as we will see later, the later makes easier to compute the symmetry eigenvalues.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The arguments of which one is better than the other are out of the scope of this notes, so we are going to focus on developing both of them and pointing out their main differences. The package uses ‚Äî for now ‚Äî Convention 1, since it is more suitable for accounting on the ùê§-dependence, but it also provide several tools to convert its outcome into Convention 2.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Firstly, we are going to do a similar analysis to the previous one in Convention 1, but now on Convention 2. We are going to analyze the transformation properties of the Bloch functions induced from the orbitals, the effect of this choice on the representation of the Bloch Hamiltonian and its Bloch states. Secondly, we are going to point out the main differences and similarities between both conventions. We aim to point out in which situations one more suitable than the other and when it is irrelevant. Finally, we are going to cover the conversion rules to change to one another ‚Äî which are the ones we implement in this package.","category":"page"},{"location":"theory/#Transformation-properties-within-Convention-2","page":"Theory","title":"Transformation properties within Convention 2","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Firstly, we are going to prove the previous statement: Convention 2 is periodic in reciprocal space, on the contrary, to Convention 1. Let us deduce how a reciprocal lattice translation ùêÜ acts on the Bloch functions under Convention 2:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÜ^(2)_Iùê§+ùêÜ = sum_ùê≠ e^i(ùê§+ùêÜ)ùê≠ œï_I(ùê´-ùê≠) \n= sum_ùê≠ cancele^iùêÜùê≠ e^iùê§ùê≠ œï_I(ùê´-ùê≠) \n= œÜ^(2)_Iùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This implies that the Bloch functions are periodic under reciprocal lattice translations within this convention. This has interesting implications in the computation of some parts of this package, such as, the representation of symmetry operations or symmetry eigenvalues. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, let us reproduce the transformation properties of the Bloch functions under symmetry operations g =  RùêØ  of the space group under Convention 2. Following a similar approach to the one previously developed:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g œÜ^(2)_Iùê§(ùê´) = frac1sqrtN sum_ùê≠ e^iùê§ùê≠ g œï_I(ùê´-ùê≠) \n= frac1sqrtN sum_ùê≠J e^iùê§ùê≠ œÅ(h)_JI œï_J(ùê´-Rùê≠-ùê≠_Œ≤Œ±) \n= frac1sqrtN sum_ùê≠J e^iùê§R^-1(ùê≠-ùê≠_Œ≤Œ±) œÅ(h)_JI œï_J(ùê´-ùê≠) \n= e^-i(g ùê§)ùê≠_Œ≤Œ± sum_J œÅ(h)_JI frac1sqrtN sum_ùê≠ e^i(g ùê§)ùê≠ œï_J(ùê´-ùê≠) \n= e^-i(g ùê§)ùê≠_Œ≤Œ± sum_J œÅ(h)_JI œÜ^(2)_Jg ùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we made the substitution ùê≠ = Rùê≠ + ùê≠_Œ≤Œ±, and used the definition stated before: gùê§  R^-1^T ùê§.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Similarly as before, we can define a representation matrix D^(2)_ùê§(g) whose entries are D^(2)_ùê§(g)_IJ = e^-i(gùê§)ùê≠_Œ≤Œ± œÅ(h)_IJ, where I = (iŒ±) and J = (jŒ≤). Then, the previous expression reduces to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g œÜ^(2)_Iùê§(ùê´) = sum_j D^(2)_ùê§(g)_JI œÜ^(2)_jŒ≤gùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that the representation matrix for the space group operations differs between conventions, i.e., D^(1)_ùê§(g)  D^(2)_ùê§(g). The representation under Convention 1 depends on the translational part ùêØ, as shown before, meanwhile, under Convention 2, it presents not on a global phase factor, but on a local phase factor depending on ùê≠_Œ≤Œ±.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The next step will be to build a tight-binding model using this set of functions as a basis. For that, in the following section, we will follow the same steps as in Convention 1 by introducing the creation and annihilation operators associated to such functions, and how the Bloch Hamiltonian will look like.","category":"page"},{"location":"theory/#Bloch-Hamiltonian-under-Convention-2","page":"Theory","title":"Bloch Hamiltonian under Convention 2","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We want to use the previously introduced Bloch functions as a basis to construct a Bloch Hamiltonian in reciprocal space. Once again, we start from the most general tight-binding Hamiltonian, which, as we described, can be written as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùêëùê≠ h_IJùêë ƒâ^_Iùê≠+ùêë ƒâ_Jùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since we want to use the previous Bloch functions as a basis, we have to introduce a set of creation and annihilation operators that are consistent with the convention choice ‚Äî Convention 2 in this case. This is satisfied by the following relation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatb_Iùê§^ = frac1sqrtN sum_ùê≠ e^iùê§ùê≠ ƒâ_Iùê≠^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have used hatb as the notation for the operators under this new convention. It is interesting to notice that you can obtain one from the other by using the following relation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatb_Iùê§^ = e^-iùê§ùê™_Œ± √¢_Iùê§^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Introducing the previous transformation into the tight-binding Hamiltonian we obtain that:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùêëùê§ h_IJùêë e^iùê§ùêë hatb_Iùê§^ hatb_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If we define h^(2)_IJùê§ = sum_ùêë h_IJùêë e^iùê§ùêë, we obtain the usual expression for a tight-binding Hamiltonian in reciprocal space:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùê§ h^(2)_IJùê§ hatb_Iùê§^ hatb_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"From here, we can define the Bloch Hamiltonian which will be the diagonal part of the Hamiltonian in reciprocal space, i.e.:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§ = sum_IJ h^(2)_IJùê§ hatb_Iùê§^ hatb_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Considering that now the Bloch functions are periodic it is easier to prove that the Bloch Hamiltonian is periodic also, but, nevertheless, we are going to prove it. Firstly, let us examine how the creation operator transform under a reciprocal lattice translation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatb_Iùê§+ùêÜ^ = frac1sqrtN sum_ùê≠ e^i(ùê§+ùêÜ)ùê≠ ƒâ_Iùê≠^ \n= frac1sqrtN sum_ùê≠ cancele^iùêÜùê≠ e^iùê§ùê≠ ƒâ_Iùê≠^ \n= hatb_Iùê§^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, let us study how the coefficients transform under a reciprocal lattice translation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"h^(2)_IJùê§+ùêÜ = sum_ùêë h_IJùêë e^i(ùê§+ùêÜ)ùêë \n= sum_ùêë h_IJùêë cancele^iùêÜùêë e^iùê§ùêë \n= h^(2)_IJùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As can be seen, all the components are periodic within this convention. This is the common reason why it is heavily used in the literature. Proving now the translational invariance of the Bloch Hamiltonian:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§+ùêÜ = sum_IJ h^(2)_IJùê§+ùêÜ hatb_Iùê§+ùêÜ^ hatb_Jùê§+ùêÜ \n= sum_IJ h^(2)_IJùê§ hatb_Iùê§^ hatb_Jùê§ = ƒ§_ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is an important property since the eigenvalues of this Bloch Hamiltonian, which correspond to the energies of the Bloch states of the system, must be periodic in reciprocal space, allowing us to restrict to the first Brillouin zone. Additionally, since the representation matrix H_ùê§ is now periodic by itself, the eigenvectors ùê∞^(2)_nùê§ will also be periodic. This has important implications, for example, when computing the symmetry eigenvalues.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Before studying the transformation properties of the Bloch states, we want to mention that the creation and annihilation operators and the Bloch Hamiltonian within this convention will have the same transformation properties under symmetry operations but now using the representation matrix of the operations D^(2)_ùê§ associated to Convention 2.","category":"page"},{"location":"theory/#Bloch-states-under-Convention-2","page":"Theory","title":"Bloch states under Convention 2","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us now jump into the transformation properties of the Bloch states. The Bloch states are represented using the basis obtained by Convention 2 as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœà_nùê§ = sum_I w^(2)_Inùê§ ketœÜ^(2)_Iùê§ = frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us first study how the Bloch states transform under lattice translations in real and reciprocal space and, then, deduce how they transform under more complex symmetry operations.","category":"page"},{"location":"theory/#Transformation-under-lattice-translations","page":"Theory","title":"Transformation under lattice translations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Firstly, we are going to consider lattice translations in real space. This can be obtained by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œà_nùê§(ùê´+ùêë) = braketùê´+ùêëœà_nùê§ \n= frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§ùê≠ braketùê´+ùêëœï_nùê≠ \n= frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§ùê≠ braketùê´œï_nùê≠-ùêë \n= e^iùê§ùêë frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§(ùê≠-ùêë) braketùê´œï_nùê≠-ùêë \n= e^iùê§ùêë braketùê´œà_nùê§ = e^iùê§ùêë œà_nùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch states transform as Bloch functions under translations in real space, as expected.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, let us analyze how they transform under reciprocal lattice translations. Remind that the matrix representation H^(2)_ùê§ is periodic under reciprocal lattice translations. This implies that ùê∞^(2)_nùê§+ùêÜ = ùê∞^(2)_nùê§, and E_nùê§+ùêÜ = E_nùê§, i.e., they are periodic under reciprocal lattice translations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us deduce how Bloch states will transform under reciprocal lattice translations:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœà_nùê§+ùêÜ = frac1sqrtN sum_Iùê≠ w^(2)_Inùê§+ùêÜ e^i(ùê§+ùêÜ)ùê≠ ketœï_Iùê≠ \n= frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ cancele^iùêÜùê≠ e^iùê§ùê≠ ketœï_Iùê≠ \n= frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§ùê≠ ketœï_Iùê≠ = ketœà_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch states will remain invariant under reciprocal lattice translations, as it should be.","category":"page"},{"location":"theory/#Transformation-properties-under-symmetry-operations-2","page":"Theory","title":"Transformation properties under symmetry operations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here we analyze how the Bloch states transform under more complex symmetry operations g = RùêØ that might involve translations ùêØ and site-symmetry operations R. The Bloch state will transform under this operations as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒù ketœà_nùê§ = sum_I w^(2)_Inùê§ ƒù ketœÜ^(2)_Iùê§ \n= sum_IJ w^(2)_Inùê§ D^(2)_ùê§(g)_JI ketœÜ^(2)_Jgùê§ \n= sum_IJ D^(2)_ùê§(g)_JI w^(2)_Inùê§ ketœÜ^(2)_Jgùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We are particularly interested in the transformation under operations ƒù in the little-group G_ùê§ of a particular ùê§-point. This operations will leave invariant the particular ùê§-point up to a lattice translation, i.e., g ùê§ = ùê§ + ùêÜ. How these functions transform under those operation at each high-symmetry point will allow us to assign an irrep to each of the Bloch states at that ùê§-point. Those should coincide with the ones obtained from the original system's band structure. The irrep could be assigned by computing the symmetry eigenvalues associated to each Bloch state. Those are compute by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"braketœà_nùê§ƒùœà_nùê§ = sum_IJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ braketœÜ^(2)_Iùê§ƒùœÜ^(2)_Jùê§ \n= sum_IJJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ D^(2)_ùê§(g)_JJ braketœÜ^(2)_Iùê§œÜ^(2)_Jgùê§ \n= sum_IJJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ D^(2)_ùê§(g)_JJ braketœÜ^(2)_Iùê§œÜ^(2)_Jùê§+ùêÜ \n= sum_IJJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ D^(2)_ùê§(g)_JJ braketœÜ^(2)_Iùê§œÜ^(2)_Jùê§ \n= sum_IJJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ D^(2)_ùê§(g)_JJ delta_IJ \n= sum_IJ (w^(2)_Inùê§)^* D_ùê§(g)_IJ w^(2)_Jnùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this expression differs from the previous one due to a phase factor. This is the main reason why some authors decided to use Convention 2 instead Convention 1: it is not necessary to account for phase factors in the symmetry eigenvalues computations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Nevertheless, it is interesting to be able to consider both conventions and that is why, in the next section, we develop conversion properties between the two conventions for several convention-dependent expressions.","category":"page"},{"location":"theory/#Conversions-between-Convention-1-and-2","page":"Theory","title":"Conversions between Convention 1 and 2","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Firstly, ley us start with the conversion between the Bloch functions that the different Fourier transformations inherit. Since there is just an additional phase factor, we can just convert from one convention to the other adding that extra factor as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœÜ^(2)_Iùê§ = e^-iùê§ùê™_Œ± ketœÜ^(1)_Iùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Obviously, the creation and annihilation operators will convert in a similar fashion, in particular, as said previously:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatb_Iùê§^ = e^-iùê§ùê™_Œ± √¢_Iùê§^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, the Hamiltonian must be invariant independent of what basis we use to define it. Considering this, we can deduce how the matrix H_ùê§, which is representation dependent, convert from one convention to the other. Let us start with the Bloch Hamiltonian:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§ = sum_IJ h^(1)_IJùê§ √¢_Iùê§^ √¢_Jùê§ \n= sum_IJ e^iùê§ùê™_Œ± h^(1)_IJùê§ e^-iùê§ùê™_Œ≤ hatb_Iùê§^ hatb_Jùê§ \n h^(2)_IJùê§ = e^iùê§ùê™_Œ± h^(1)_IJùê§ e^-iùê§ùê™_Œ≤","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This allow us to convert from one representation matrix of the Hamiltonian to the other. It is more interesting to rewrite the previous relation in matrix form, which will be:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"H^(2)_ùê§ = Œò^_ùê§ H^(1)_ùê§ Œò_ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where Œò_ùê§ is a diagonal matrix containing the phase factor as defined previously: Œò_ùê§_II = e^-iùê§ùê™_Œ±. This relation allow us to transform from one representation of the Bloch Hamiltonian into the other.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Finally, we are interested in deducing the conversion properties of the eigenvector obtained from diagonalizing the representation matrix H_ùê§. Since H^(1)_ùê§ and H^(2)_ùê§ are related by a change of basis, the eigenvalue of both of them can be easily related to one each other as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùê∞^(2)_nùê§ = Œò^_ùê§ ùê∞^(1)_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"With this relations we are able to to go back and forward from one convention to the other, making it possible to use both depending on which one is the most suitable for each case.","category":"page"},{"location":"band-symmetry/#Band-symmetry-and-topology","page":"Band symmetry","title":"Band symmetry and topology","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Since the theory behind SymmetricTightBinding.jl is anchored in symmetry analysis, the package naturally provides several tools to analyze band symmetry, as well as to use this information to apply the frameworks of topological quantum chemistry and symmetry indicators to analyze band topology.","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"To explore these tools, we first re-build the graphene model previously explored in the tutorial section, instantiating the variables tbm (model), ptbm (coefficient-parameterized model), kpi (interpolated k-path, via Brillouin.jl), and Es (band structure of ptbm, evaluated over kpi).","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"details: Setup details\nusing Crystalline, SymmetricTightBinding\nusing Brillouin, GLMakie           # for k-space path and plotting\nsgnum = 17                         # plane group p6mm\nbrs = calc_bandreps(sgnum, Val(2)) # band representations\ncbr = @composite brs[5]            # (2b|A‚ÇÅ) EBR\ntbm = tb_hamiltonian(cbr)          # tight-binding model (nearest neigbors)\nptbm = tbm([0, 1])                 # zero self-energy, nonzero nearest-neighbor hopping\nRs = directbasis(sgnum, Val(2))    # (conventional) direct lattice basis\nkp = irrfbz_path(sgnum, Rs)        # high-symmetry k-path\nkpi = interpolate(kp, 100)         # interpolated k-path\nEs = spectrum(ptbm, kpi)           # band structure over `kpi`\nnothing # hide","category":"page"},{"location":"band-symmetry/#Annotating-little-group-irrep-labels","page":"Band symmetry","title":"Annotating little group irrep labels","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"To annotate a band structure plot with the little group irrep labels at high-symmetry k-points, we can use collect_irrep_annotations in combination with the annotations keyword argument of the Makie plot extension:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"plot(kpi, Es; annotations = collect_irrep_annotations(ptbm))","category":"page"},{"location":"band-symmetry/#Collecting-compatibility-respecting-band-groups","page":"Band symmetry","title":"Collecting compatibility respecting band groups","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Similarly, we can analyze the compatibility respecting bands contained in ptbm via collect_compatible:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"collect_compatible(ptbm)","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"collect_compatible returns a list of symmetry vectors, from lowest-energy band grouping to highest, each aggregating the symmetry content of a minimal set of compatibility-respecting bands. Here, since our model contains only a single band representation ‚Äì which is additionally an intrinsically connected one ‚Äì such a list can have only one possible element: the only possible band groupings is the original band representation. We can verify this by comparing with the symmetry vector of the band representation used to build tbm:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"SymmetryVector(CompositeBandRep(ptbm))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can set up a more interesting situation by incorporating more band representations (i.e., more orbitals) into our model. E.g., below, we add three s-like orbitals placed at the 3c Wyckoff position (edges of the hexagonal unit cell; i.e., a kagome-like lattice) to the usual graphene model. First, we look at a situation without hybridization and with the bands of the two orbitals sets overlapping:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"cbr‚Ä≤ = @composite brs[3] + brs[5] # (2a|A‚ÇÅ) + (3c|B‚ÇÇ)\ntbm‚Ä≤ = tb_hamiltonian(cbr‚Ä≤)\nptbm‚Ä≤ = tbm‚Ä≤([2.5, 0, 0.2, 0, -1, 0])\nplot(kpi, spectrum(ptbm‚Ä≤, kpi); annotations = collect_irrep_annotations(ptbm‚Ä≤))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Next, we turn on hybridization (controlled by the fifth term of tbm‚Ä≤):","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"ptbm‚Ä≤‚Ä≤ = tbm‚Ä≤([2.5, 0, 0.2, 0, -1, .5])\nplot(kpi, spectrum(ptbm‚Ä≤‚Ä≤, kpi); annotations = collect_irrep_annotations(ptbm‚Ä≤‚Ä≤))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can verify that neither of the band groupings in the hybridized band structure have the same content as either of the underlying band representations. In particular, the band symmetry content of the underlying band representations is:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"SymmetryVector.([brs[3], brs[5]])","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can compare this against the band symmetry content of each of the hybridized bands is obtained from collect_compatible (using a compatibility analysis that involves only the high-symmetry k-points):","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"ns = collect_compatible(ptbm‚Ä≤‚Ä≤)","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"In the hybridized model above, the symmetry content of each band grouping differs from any of the original band representations used to build the model: in particular, the assignment of the Œì‚ÇÉ and Œì‚ÇÜ irreps and the M‚ÇÇ and M‚ÇÑ irreps are inverted.","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"details: Recovering an EBR decomposition\nThe new bands can still be interpreted as induced by band representations: the lowest bands correspond to (1aE‚ÇÅ) + (1aA‚ÇÅ), or brs[end]+brs[end-5], while the upper bands are topologically fragile with a possible decomposition of the form (2bA‚ÇÅ) + (1aB‚ÇÇ) + (1aE‚ÇÇ) - (3cA‚ÇÅ), or brs[5] + brs[end-3] + brs[end-1] - brs[1]. These expansions can be obtained using SymmetryBases.jl's decompose function.","category":"page"},{"location":"band-symmetry/#Band-topology","page":"Band symmetry","title":"Band topology","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Using the extracted symmetry vectors, we can compute the associated symmetry-diagnosable band topology of each band grouping. We can obtain e.g., a coarse topological diagnosis of TRIVIAL (encompassing both trivial and fragile phases) and NONTRIVIAL using Crystalline.jl's calc_topology:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"calc_topology.(ns, Ref(brs))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"I.e., in this example, both band representations are either a trivial or a fragile phase. To resolve this distinction, we can use SymmetryBases.jl's calc_detailed_topology:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"using SymmetryBases\ncalc_detailed_topology.(ns, Ref(brs))","category":"page"},{"location":"#SymmetricTightBinding.jl","page":"Home","title":"SymmetricTightBinding.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymmetricTightBinding.jl provides tools for the construction and manipulation of tight-binding models. The main novelty ‚Äì and principal strength ‚Äì of the package is that every such model is associated with, and specified by, a set of band representations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Put more simply, SymmetricTightBinding.jl will automatically generate all possible tight-binding Hamiltonians that are compatible with a global (space group) symmetry, as well as a selection of orbitals with specified local symmetries (i.e., transforming as specific site symmetry irreps), each situated at specified positions in the unit cell (i.e., at specific Wyckoff positions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying physics is that the Bloch Hamiltonian of a Wannierizable set of bands must transform under under a site-symmetry induced representation (also called band representation) D(g) for operations g in the associated space group. That is, the Bloch Hamiltonian mathbfh(mathbfk) must be symmetric in the sense:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbfD_mathbfk(g) mathbfh_mathbfk mathbfD_mathbfk^dagger(g) = mathbfh_gmathbfk","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfD_mathbfk(g) is the (momentum-)block-diagonal part of the Fourier transformed band representation D(g). This is simply the familiar operator relation g hath_mathbfk g^-1 = hath_gmathbfk cast into the basis of local orbitals.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is registered in the Julia General registry and can be installed from the pkg> command line (entered by pressing ] in the Julia REPL):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SymmetricTightBinding, Crystalline","category":"page"},{"location":"","page":"Home","title":"Home","text":"SymmetricTightBinding.jl is designed to work as a companion package to Crystalline.jl; so we add Crystalline.jl in the above as well. The packages can subsequently be loaded at the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SymmetricTightBinding, Crystalline","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"tutorial.md\", \"band-symmetry.md\", \"symmetry-breaking.md\", \"api.md\", \"internal-api.md\"]\nDepth = 2","category":"page"},{"location":"tutorial/#tutorial","page":"Tutorial","title":"Tutorial example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a first step, we load both Crystalline.jl and SymmetricTightBinding.jl into our current Julia session:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Crystalline, SymmetricTightBinding","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As our first example, we'll build and explore the tight-binding model of graphene. Once we've done that, we'll explore how to create related tight-binding models in the same symmetry setting. Subsequently, we'll take a look at building 3D tight-binding models.","category":"page"},{"location":"tutorial/#Graphene","page":"Tutorial","title":"Graphene","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Graphene is a two-dimensional material, with two carbon atoms arranged in a honeycomb lattice. For our purposes, the important aspect is its crystal symmetry: the lattice has 6-fold rotation symmetry and associated in-plane mirror symmetry. In the language of crystallography, its symmetry is that of plane group p6mm (here, specified by its Hermann‚ÄìMauguin label). This plane group has a conventional numbering assigned ‚Äì namely, plane group ‚ãï17. The mapping between the Hermann‚ÄìMauguin label and the conventional number can e.g., be determined using Crystalline.jl's iuc or looked up in online tables, such as the Bilbao Crystallographic Server.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using Crystalline, we can build the maximal band representations of plane group ‚ãï17:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sgnum = 17 # space group number of p6mm\nbrs = calc_bandreps(sgnum, Val(2)) # `Val(2)` specifies the dimensionality (here, 2D)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The top row of the output lists the possible positions that a symmetrically placed orbital can reside, specified as a Wyckoff position label (e.g., 1a, 2b, 3c). In the second row, the possible local symmetry that an orbital placed there can have (e.g., A‚ÇÅ, A‚ÇÇ, B‚ÇÅ, ‚Ä¶) are listed, specified in Mulikken notation. The remaining rows contain information about the projection of each band representation to band symmetries at high-symmetry k-points and which is not needed in the present context.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Graphene's two p<sub>z</sub> orbitals sit at the 2b Wyckoff position: though odd (i.e., changing sign) under mirror in the out-of-plane direction, the p<sub>z</sub> orbital is even (i.e., invariant) under all in-plane symmetries (rotations and mirrors). The associated site-symmetry irrep is the A‚ÇÅ site-symmetry irrep of the 2b Wyckoff position. In the above tables, this is the fifth column of brs, which we may select by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"brs[1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To construct a tight-binding model, we must construct a CompositeBandRepresentation: this is necessary because we may generally be interested in building models for multiple band representations (say, for placing orbitals at multiple distinct Wyckoff positions). We can construct such a composite representation by @composite a*brs[i] + b*brs[j] + ‚Ä¶ which will contain a times the brs[i] band representation and so on. Here, we just need the (2b|A‚ÇÅ) representation once:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cbr = @composite brs[5]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With this in hand, we can finally use SymmetricTightBinding.jl. In particular, we may use tb_hamiltonian. First, we build the nearest-neighbor tight-binding Hamiltonian:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tbm = tb_hamiltonian(cbr)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The output lists the \"basis terms\" of the tight-binding Bloch Hamiltonian, each implicitly parameterized by a free on-site energy or hopping amplitude. The notation ùïñ(Œ¥·µ¢) is introduced for brevity, a short-hand for the complex momentum-dependent exponential mathrme^mathrmimathbfkcdotboldsymboldelta_i. Here boldsymboldelta_i denotes a hopping vector; in turn, these vectors are expressed above as Œ¥·µ¢, given in the basis of the primitive direct lattice mathbfa_i. I.e., a term like Œ¥‚ÇÅ = [-1/3, 1/3] really means boldsymboldelta_1 = -tfrac13mathbfa_1 + tfrac13mathbfa_2.","category":"page"},{"location":"tutorial/#Visualization","page":"Tutorial","title":"Visualization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It's often helpful to visualize model terms, and SymmetricTightBinding.jl facilitates this via a Makie extension. We may e.g., use GLMakie.jl to plot the second tight-binding term:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GLMakie\nRs = directbasis(sgnum, Val(2)) # a direct lattice basis, to allow plotting in a Cartesian setting\nplot(tbm[2], Rs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, red markers indicate \"source\" sites while blue markers indicat \"drains\"; electrons hop from sources to drains, as also indicated by the arrowheads. The visualization (and the internal representation of tbm) includes only the hoppings for a single unit cell, such that tiling unit cells do not lead to counting hoppings multiple times.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We might want to go beyond nearest-neighbor in our tight-binding model. To do so, we must provide tb_hamiltonian with a second argument that gives a set of possible direct-lattice vector separations of sources and drains (in addition to an intra-lattice term). It is enough to include a representative direct lattice vector; if e.g., [1,0] and [0,1] are symmetry-related, the latter will be automatically included by providing the former.  For the graphene example, we might include direct lattice separations [0,0] (default, if a second argument is not provided) and [1,0]:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tbm = tb_hamiltonian(cbr, [[0,0], [1,0]])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And we now have four terms. We can visualize tbm[3] and tbm[4] as before, individually, or we can visualize all terms at once:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(tbm, Rs)","category":"page"},{"location":"tutorial/#Model-evaluation-and-band-structures","page":"Tutorial","title":"Model evaluation & band structures","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To evaluate the tight-binding model, we must specify a set of (real) hopping amplitudes. To associate coefficients c‚ÇÅ, c‚ÇÇ, c‚ÇÉ, c‚ÇÑ to each of the basis terms of the model tbm, we can invoke it as a functor to create a ParameterizedTightBindingModel:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cs = [0, 1, 0, 0] # set c‚ÇÇ = 1 and all other c·µ¢ to zero\nptbm = tbm(cs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then evaluate the parameterized model ptbm at k-point, again using ptbm as a functor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"k = ReciprocalPoint(1/2, 0) # the M point\nh = ptbm(k)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the k-point coordinates must be given in the basis of the primitive reciprocal lattice vectors mathbfb_i (the dual lattice to mathbfa_i), i.e., the k variable above corresponds to the point mathbfk = tfrac12mathbfb_1 + 0mathbfb_2.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will usually be more interested in the overall behavior of the model across the Brillouin zone than its behavior at any single k-point. E.g., we might be interested in the band structure along high-symmetry lines of the Brillouin zone. To quickly build such a path, we leverage Brillouin.jl's irrfbz_path:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Brillouin\nkp = irrfbz_path(sgnum, Rs)\nkpi = interpolate(kp, 200) # aim for 200 interpolations points","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, to obtain the band structure along the interpolated k-path, we use SymmetricTightBinding.jl's spectrum function and plot the result using the Brillouin.jl's Makie.jl extension:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Es = spectrum(ptbm, kpi); # a 200√ó2 Matrix\nplot(kpi, Es)","category":"page"}]
}
