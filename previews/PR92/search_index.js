var documenterSearchIndex = {"docs":
[{"location":"internal-api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"This page lists unexported functionality from SymmetricTightBinding.jl that may be of interest to developers.","category":"page"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"","category":"page"},{"location":"internal-api/#Unexported,-internal-functionality","page":"Internal API","title":"Unexported, internal functionality","text":"","category":"section"},{"location":"internal-api/#SymmetricTightBinding.OrbitalOrdering-Union{Tuple{Crystalline.NewBandRep{D}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.OrbitalOrdering","text":"OrbitalOrdering(br::NewBandRep{D}) --> OrbitalOrdering{D}\n\nEstablishes a canonical, local ordering for the orbitals associated to a band representation br. This is the default ordering used when associating row/column indices in a tight-binding Hamiltonian block to specific orbitals in the associated band representations.\n\nThe canonical orbital ordering is stored in .ordering. The ith elements of ordering, ordering[i], is a NamedTuple with two fields: wp and idx:\n\nwp: stores a Wyckoff position in the orbit of the Wyckoff position associated to br.wp.\nidx: stores the index of the partner function of the site-symmetry irrep associated to br at wp.\n\nI.e., the ith orbital associated to br is located at wp and transforms as the idxth partner function of the site-symmetry irrep of br.siteir. The total number of orbitals associated to a band representation, and hence the length of ordering, is the product of the site-symmetry irrep dimensionality and the number of sites in the Wyckoff position orbit.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.SiteInducedSGRepElement","page":"Internal API","title":"SymmetricTightBinding.SiteInducedSGRepElement","text":"SiteInducedSGRepElement{D}(\n    œÅ::AbstractMatrix,\n    positions::Vector{DirectPoint{D}},\n    op::SymOperation{D}\n)\n\nRepresents a matrix-valued element of a site-induced representation of a space group, including a global momentum-dependent phase factor.\n\nThis structure behaves like a functor: calling it with a momentum k :: AbstractVector  returns the matrix representation at k.\n\nFields (internal)\n\nœÅ :: Matrix{ComplexF64} : The momentum-independent matrix part of the representation.\npositions :: Vector{DirectPoint{D}}: Real-space positions corresponding to the orbitals in the orbit of the associated site-symmetry group.\n\n\n\n\n\n","category":"type"},{"location":"internal-api/#SymmetricTightBinding._maybe_add_hoppings!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding._maybe_add_hoppings!","text":"Computes and adds the symmetry related partners of a hopping term Œ¥ to the Œ¥_orbit.\n\nwarning: Warning\nThis function is an internal helper function for maybe_add_hoppings! and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._permute_symmetry_related_hoppings_under_symmetry_operation-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.SymOperation{D}}} where D","page":"Internal API","title":"SymmetricTightBinding._permute_symmetry_related_hoppings_under_symmetry_operation","text":"Build the P matrix for a particular symmetry operation acting on k-space, which permutes the rows of the M matrix.\n\nFor obtaining the P matrix, we make use that the action is on exponential of the type: ùêûxp(2œÄkŒ¥), to instead act on Œ¥ ‚àà h_orbit.orbit instead of k, which is a symbolic variable. Because of that, we need to use the inverse of the rotation part of the symmetry operation.\n\ndetails: Sketch of proof\nAssume g={R|œÑ} and Crystalline implements gk=(R‚Åª¬π)·µÄk. Then (gk)‚ãÖŒ¥ = ((R‚Åª¬π)·µÄk)‚ãÖŒ¥ + œÑ = k‚ãÖ(R‚Åª¬π)Œ¥.\n\ninfo: Info\nIt is assumed that the operation op is provided in a primitive setting.\n\nwarning: Warning\nThis function is an internal helper function for reciprocal_constraints_matrices and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._poormans_sparsification-Tuple{AbstractMatrix{<:Number}}","page":"Internal API","title":"SymmetricTightBinding._poormans_sparsification","text":"Poor man's \"matrix sparsification\" via the reduced row echelon form.\n\nwarning: Warning\nThis function is an internal helper function for obtain_basis_free_parameters and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._prune_at_threshold!-Union{Tuple{AbstractVector{<:AbstractVector{T}}}, Tuple{T}} where T<:Complex","page":"Internal API","title":"SymmetricTightBinding._prune_at_threshold!","text":"Prune near-zero elements of vectors in vs.\n\nwarning: Warning\nThis function is an internal helper function for obtain_basis_free_parameters and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.add_reversed_orbits!-Union{Tuple{Array{HoppingOrbit{D}, 1}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.add_reversed_orbits!","text":"add_reversed_orbits!(h_orbits::Vector{HoppingOrbit{D}}) where {D}\n\nAdds the reversed hopping terms to the hopping orbits in h_orbits. The reversed hopping terms are added to the orbit of the hopping term they are related to, and if they are already present in another orbit, the two orbits are merged.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.construct_M_matrix-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.construct_M_matrix","text":"construct_M_matrix(\n    h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D},\n    [ordering1, ordering2]) \n    --> Array{Int,4}\n\nConstruct a set of matrices that encodes a Hamiltonian's term which resembles the hopping from EBR br1 to EBR br2.\n\nThe encoding is stored as a 4D matrix. Its last two axes correspond to elements of the Bloch Hamiltonian H(k); its first axis corresponds to orbit(h_orbit) and the associated complex exponentials stored in v; and its second axis to the elements of the vector t. That is:\n\nH‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º\n\nSee devdocs.md for details.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.evaluate_tight_binding_term!-Union{Tuple{D}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Union{Nothing, Number}}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Union{Nothing, Number}, Matrix{ComplexF64}}} where D","page":"Internal API","title":"SymmetricTightBinding.evaluate_tight_binding_term!","text":"evaluate_tight_binding_term!(tbt::TightBindingTerm, k, [c, H])\n\nEvaluate the tight-binding term tbt at momentum k, possibly multiplied by a scalar coefficient c (unity if omitted). The term is added into the scratch space matrix H; if H is not provided, it is initialized as a zero matrix of the appropriate size.\n\nThe function returns the modified H matrix.\n\nNote\n\nThe two-argument form of the function, i.e., returning the value of tbt at k, can be more simply achieved via tbt(k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.inversion-Tuple{Val{3}}","page":"Internal API","title":"SymmetricTightBinding.inversion","text":"inversion(::Val{D}) --> SymOperation{D}\n\nReturn the inversion operation in dimension D.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.maybe_add_hoppings!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding.maybe_add_hoppings!","text":"maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops) --> Vector{HoppingOrbit{D}}\n\nChecks if a hopping term Œ¥ is already in the list of representatives. If not, adds it and its symmetry-related partners. If it is, it only adds the symmetry-related partners.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters","text":"obtain_basis_free_parameters(\n    h_orbit::HoppingOrbit{D},\n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D}, \n    [ordering‚Çê = OrbitalOrdering(br‚Çê), ordering·µ¶ = OrbitalOrdering(br·µ¶)]\n    )                            --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}\n\nObtain the basis of free parameters for the hopping terms between br‚Çê and br·µ¶  associated with the hopping orbit h_orbit.\n\nNote\n\nThe presence or absence of time-reversal symmetry is inferred implicitly from br‚Çê and br·µ¶.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters_TRS-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}, AbstractArray{Int64, 4}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters_TRS","text":"obtain_basis_free_parameters_TRS(\n    h_orbit::HoppingOrbit{D}, \n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D}, \n    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),\n    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶),\n    Mm::AbstractArray{4, Int} = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶)\n    )                             --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}}\n\nObtain the basis of free parameters for the hopping terms between br‚Çê and br·µ¶ associated with the hopping orbit h_orbit under time-reversal symmetry.\n\nReal and imaginary parts of the basis vectors are differentiated explicitly: internally, we consider only variables.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters_hermiticity-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}, AbstractArray{Int64, 4}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters_hermiticity","text":"obtain_basis_free_parameters_hermiticity(\n    h_orbit::HoppingOrbit{D},\n    br‚Çê::NewBandRep{D},\n    br·µ¶::NewBandRep{D},\n    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),\n    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶),\n    Mm::AbstractArray{Int, 4} = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶);\n    antihermitian::Bool = false,\n) where {D}\n\nConstructs a basis for the coefficient vectors t‚ÅΩ‚Åø‚Åæ that span the space of Hermitian (or antihermitian if true) TB Hamiltonians H‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º = v·µÄ(k) M‚ÅΩÀ¢·µó‚Åæ t. We do this by assuming that each coefficient vector t is sorted into a vector of the form [t·¥ø; it·¥µ] so that we can take the complex conjugate by as t* = œÉ‚ÇÉt, which can then be moved onto M‚ÅΩÀ¢·µó‚Åæ instead of t. The constraint H‚Çõ‚Çú(k) = (H‚Ä†)‚Çõ‚Çú(k) = H‚Çú‚Çõ*(k) can then be expressed as v·µÄ(k) M‚ÅΩÀ¢·µó‚Åæ t‚±º = v*·µÄ(k) M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ t = v·µÄ(k) (P·µÄ M‚ÅΩ·µóÀ¢‚ÅæœÉ‚ÇÉ) t, which requires that t be a solution to the nullspace M‚ÅΩÀ¢·µó‚Åæ - P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ = 0. We cast this as Z - Q = 0, with Z = M‚ÅΩÀ¢·µó‚Åæ and Q = P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ.\n\nNotes\n\nFor anti-Hermitian symmetry, we require H‚Çõ‚Çú(k) = -H‚Çú‚Çõ*(k), which translates to M‚ÅΩÀ¢·µó‚Åæ + P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ = 0; i.e., simply swaps the sign of Q\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.pin_free-Union{Tuple{D}, Tuple{Crystalline.NewBandRep{D}, AbstractVector{<:Real}}} where D","page":"Internal API","title":"SymmetricTightBinding.pin_free","text":"pin_free(br::NewBandRep{D}, Œ±Œ≤Œ≥::AbstractVector{<:Real}) where D\n\nPin the free parameters of the Wyckoff position associated with the band representation br to the values in Œ±Œ≤Œ≥.\n\nReturns a new band representation with all other properties, apart from the Wyckoff position, identical to (and sharing memory with) br.\n\nNote that the associated orbit of the Wyckoff position will be automatically adjusted to ensure that each position in the orbit lies within the primitive unit cell [0,1)·¥∞. That is, if a choice of Œ±Œ≤Œ≥ sends a position in the orbit outside the primitive unit cell, the position will be adjusted by integer lattice translations to lie within.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.primitivized_orbit-Union{Tuple{Crystalline.NewBandRep{D}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.primitivized_orbit","text":"primitivized_orbit(br::NewBandRep{D}) where D\n\nReturn the orbit of the Wyckoff position associated with the band representation br. The coordinates of positions in the orbit are given relative to the primitive unit cell.\n\nPositions are returned as a Vector{DirectPoint{D}}.\n\nThe following checks are made, producing an error if violated:\n\nThere are no free parameters associated with the Wyckoff position.\nFor every position, its coordinates, referred to the primitive basis, is in the range [0,1); i.e., every position lies in the parallepiped primitive unit cell [0,1)·¥∞.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.reciprocal_constraints_matrices-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, AbstractArray{Crystalline.SymOperation{D}, 1}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.reciprocal_constraints_matrices","text":"reciprocal_constraints_matrices(\n                                Mm::AbstractArray{Int,4}, \n                                gens::AbstractVector{SymOperation{D}}, \n                                h_orbit::HoppingOrbit{D}\n                                ) --> Vector{Array{Int,4}}\n\nCompute the reciprocal constraints matrices for the generators of the SG. This is done by permuting the rows of the M matrix according to the symmetry operation acting on k-space. See more details in permute_symmetry_related_hoppings_under_symmetry_operation and devdocs.md.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.representation_constraint_matrices-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding.representation_constraint_matrices","text":"representation_constraints_matrices(\n    Mm::AbstractArray{Int,4}, \n    br‚Çê::NewBandRep{D},\n    br·µ¶::NewBandRep{D}) --> Vector{Array{ComplexF64,4}}\n\nBuild the Q matrix for a particular symmetry operation (or, equivalently, a particular matrix from the site-symmetry representation), acting on the M matrix. Relative to our white-board notes, Q has swapped indices, in the sense we below give Q[i,j,r,l].\n\n(œÅ‚Çê‚Çê)·µ£‚Çõ H‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ v·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = v·µ¢ (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó t‚±º,\n\nthen we can define: Q·µ¢‚±º·µ£‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.sgrep_induced_by_siteir_excl_phase-Union{Tuple{D}, Tuple{Crystalline.NewBandRep{D}, Crystalline.SymOperation{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.sgrep_induced_by_siteir_excl_phase","text":"sgrep_induced_by_siteir_excl_phase(br::NewBandRep, op::SymOperation)\nsgrep_induced_by_siteir_excl_phase(cbr::CompositeBandRep, op::SymOperation)\n    --> Matrix{ComplexF64}\n\nReturn the representation matrix of a symmetry operation op induced by the site symmetry group of a band representation br or composite band representation cbr, excluding the global momentum-dependent phase factor.\n\nNote\n\nThis function assumes Convention 1 for the Fourier transform, so the momentum dependence is introduced as a global phase factor. This is not true if Convention 2 is used. See  /docs/src/theory.md for more details.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.split_complex-Tuple{AbstractVector{<:Number}}","page":"Internal API","title":"SymmetricTightBinding.split_complex","text":"split_complex(t::Vector{<:Number}) -> Matrix{Real}\n\nConsider Œ±t where Œ± ‚àà ‚ÑÇ and t ‚àà ‚ÑÇ‚Åø and build from t a matrix representation T that allows access to the real and imaginary parts of the product Œ±t without using complex numbers by splitting Œ± into a real 2-vector of its real and imaginary parts.\n\nIn particular, let Œ± = Œ±·¥ø + iŒ±·¥µ and t = t·¥ø + it·¥µ with Œ±·¥ø, Œ±·¥µ ‚àà ‚Ñù and t·¥ø t·¥µ  ‚Ñù‚Åø, then Œ±t can be rewritten as\n\nŒ±t = (Œ±·¥ø + iŒ±·¥µ)(t·¥ø + it·¥µ)\n   = (Œ±·¥øt·¥ø - Œ±·¥µt·¥µ) + i(Œ±·¥øt·¥µ + Œ±·¥µt·¥ø)\n   = t·¥ø t·¥µ·µÄ Œ±·¥ø Œ±·¥µ + i t·¥µ t·¥ø·µÄ Œ±·¥ø Œ±·¥µ\n\nThen, defining T = [t·¥ø -t·¥µ; t·¥µ t·¥ø], the above product can then be reexpressed as: Re(Œ±t) = Œ±·¥øt·¥ø - Œ±·¥µt·¥µ = (T * [Œ±·¥ø; Œ±·¥µ])[1:n] and Im(Œ±t) = Œ±·¥øt·¥µ + Œ±·¥µt·¥ø = (T * [Œ±·¥ø; Œ±·¥µ])[n+1:2n]. I.e., the \"upper half\" of the product T * [real(Œ±), imag(Œ±)] is real(Œ± * t) and the  \"lower half\" is imag(Œ±t).\n\nThis functionality is used to avoid complex numbers in amplitude basis coefficients, which simplifies the application of time-reversal symmetry and hermiticity.\n\nExamples\n\njulia> using SymmetricTightBinding: split_complex\n\njulia> t = [im,0]\n2-element Vector{Complex{Int64}}:\n 0 + 1im\n 0 + 0im\n\njulia> T = split_complex(t)\n4√ó2 Matrix{Int64}:\n 0  -1\n 0   0\n 1   0\n 0   0\n\njulia> Œ± = 0.5+0.2im; Œ±v = [real(Œ±), imag(Œ±)];\n\njulia> (T * Œ±v)[1:2] == real(Œ±*t) && (T * Œ±v)[3:4] == imag(Œ±*t)\n\njulia> t = [1,im]\n2-element Vector{Complex{Int64}}:\n 1 + 0im\n 0 + 1im\n\njulia> split_complex(t)\n4√ó2 Matrix{Int64}:\n 1   0\n 0  -1\n 0   1\n 1   0\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.zassenhaus_intersection-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, Real}} where T<:Number","page":"Internal API","title":"SymmetricTightBinding.zassenhaus_intersection","text":"zassenhaus_intersection(U::AbstractArray{<:Number}, W::AbstractArray{<:Number}) \n    --> AbstractArray{<:Number}\n\nFinds the intersection of two bases U and W using the Zassenhaus algorithm. It assumes that the basis are given by columns.\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Zassenhaus_algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#Crystalline.collect_compatible-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, Vararg{Any}}} where D","page":"API","title":"Crystalline.collect_compatible","text":"collect_compatible(ptbm::ParameterizedTightBindingModel{D}; multiplicities_kws...)\n\nDetermine a decomposition of the bands associated with ptbm into a set of SymmetryVectors, with each symmetry vector corresponding to a set of compatibility-respecting (i.e., energy separable along high-symmetry k-lines) bands.\n\nKeyword arguments\n\nmultiplicities_kws...: keyword arguments passed to Crystalline.collect_compatible used in determining the multiplicities of irreps across high-symmetry k-points.\n\nExample\n\njulia> using Crystalline, SymmetricTightBinding\n\njulia> brs = calc_bandreps(221);\n\njulia> cbr = @composite brs[1] + brs[2]\n40-irrep CompositeBandRep{3}:\n (3d|A‚ÇÅg) + (3d|A‚ÇÅ·µ§) (6 bands)\n\njulia> tbm = tb_hamiltonian(cbr); # a 4-term, 6-band model\n\njulia> ptbm = tbm([1.0, 0.1, -1.0, 0.1]); # fix free coefficients\n\njulia> collect_compatible(ptbm)\n2-element Vector{SymmetryVector{3}}:\n [M‚ÇÖ‚Å∫+M‚ÇÅ‚Åª, X‚ÇÉ‚Å∫+X‚ÇÅ‚Åª+X‚ÇÇ‚Åª, Œì‚ÇÅ‚Åª+Œì‚ÇÉ‚Åª, R‚ÇÑ‚Å∫] (3 bands)\n [M‚ÇÅ‚Å∫+M‚ÇÖ‚Åª, X‚ÇÅ‚Å∫+X‚ÇÇ‚Å∫+X‚ÇÉ‚Åª, Œì‚ÇÅ‚Å∫+Œì‚ÇÉ‚Å∫, R‚ÇÑ‚Åª] (3 bands)\n\nIn the above example, the bands separate into two symmetry vectors, one for each of the original EBRs in cbr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.collect_irrep_annotations-Tuple{ParameterizedTightBindingModel}","page":"API","title":"Crystalline.collect_irrep_annotations","text":"collect_irrep_annotations(ptbm::ParameterizedTightBindingModel; kws...)\n\nCollect the irrep labels across the high-symmetry k-points referenced by the underlying composite band representation of ptbm, across the bands of the model.\n\nUseful for annotating irrep labels in band structure plots (via the Makie extension call plot(ks, energies; annotations=collect_irrep_annotations(ptbm)))\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.energy_gradient_wrt_hopping-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{ParameterizedTightBindingModel{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Any}} where D","page":"API","title":"SymmetricTightBinding.energy_gradient_wrt_hopping","text":"energy_gradient_wrt_hopping(\n    ptbm::ParameterizedTightBindingModel{D},\n    k::ReciprocalPointLike{D}\n    (Es, us) = solve(ptbm, k; bloch_phase=Val(false));\n    degen_rtol::Float64 = 1e-12,\n    degen_atol::Float64 = 1e-12\n) where D\n\nReturn the hopping gradient of the energy of each band in ptbm evaluated at momentum k.\n\nThe gradient is computed using the Feynman-Hellmann theorem. For degenerate bands (assessed energetically using relative and absolute tolerances degen_rtol and degen_atol), a degenerate variant is used, equivalent to degenerate perturbation theory.\n\nThe gradient is returned as column vectors, one for each band, with each column containing the gradient of the corresponding energy with respect to the hopping coefficients of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.gradient_wrt_hopping-Tuple{TightBindingModel}","page":"API","title":"SymmetricTightBinding.gradient_wrt_hopping","text":"gradient_wrt_hopping(tbm :: TightBindingModel)\ngradient_wrt_hopping(ptbm :: ParameterizedTightBindingModel)\n\nReturn a structure that encodes the gradient of a tight-binding model tbm or ptbm with respect to the hopping coefficients.\n\nTo evaluate the gradient at a particular momentum k, use the returned structure as a functor at k. I.e., gradient(tbm)(k) returns the gradient of the tight-binding Hamiltonian with respect to all hoppping coefficients at momentum k. This gradient is a vector of matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.obtain_symmetry_related_hoppings-Union{Tuple{V}, Tuple{D}, Tuple{AbstractVector{V}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}} where {D, V<:Union{Crystalline.RVec{D}, AbstractVector{<:Integer}}}","page":"API","title":"SymmetricTightBinding.obtain_symmetry_related_hoppings","text":"obtain_symmetry_related_hoppings(\n    Rs::AbstractVector{V}, \n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D};\n    diagonal_block::Bool = true,\n) --> Vector{HoppingOrbit{D}}\n\nCompute the symmetry related hopping terms from the points in WP of br‚Çê to the  WP of br·µ¶ displaced a set of primitive lattice vectors representatives Rs.\n\nImplementation\n\nTake a point a in the WP of br‚Çê and a point b in the WP of br·µ¶. We \n\ncompute the displacement vector Œ¥ = b + R - a, where R ‚àà Rs.\n\nIf Œ¥ ‚àà representatives then we add Œ¥ => (a, b, R) to the list of hoppings   of that representative and continue. If not then, we search inside of all the   representatives for the one that Œ¥ => (a, b, R) in the list of hoppings.   If not found, then we add Œ¥ as a new representative and add Œ¥ => (a, b, R)   to its list of hoppings.\nTake g ‚àà generators and compute Œ¥' = g Œ¥ and (a', b', R') = (g a, g b, g R),   and repeat step 2.\nRepeat all steps 1 to 3 for all pair of points in the WPs of br‚Çê and br·µ¶.\n\nAdditionally, if we are considering a diagonal block (which must be Hermitian or anti-Hermitian), we check if orbits that relate Œ¥ and -Œ¥ are present; if not, we add them.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.pin_free!-Tuple{Crystalline.Collection{<:Crystalline.NewBandRep}, AbstractVector{<:Pair{Int64, <:AbstractVector{<:Real}}}}","page":"API","title":"SymmetricTightBinding.pin_free!","text":"pin_free!(\n    brs::Collection{NewBandRep{D}},\n    idx2Œ±Œ≤Œ≥::Pair{Int, <:AbstractVector{<:Real}}\n)\n\npin_free!(\n    brs::Collection{NewBandRep{D}},\n    idx2Œ±Œ≤Œ≥s::AbstractVector{<:Pair{Int, <:AbstractVector{<:Real}}}\n)\n\nFor idx2Œ±Œ≤Œ≥ = idx => Œ±Œ≤Œ≥, update brs[idx] such that the free parameters of its associated Wyckoff positions are pinned to Œ±Œ≤Œ≥.\n\nA vector of pairs idx2Œ±Œ≤Œ≥s can also be provided, to pin multiple distinct band representations.\n\nSee also pin_free for non-mutated input.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.sgrep_induced_by_siteir-Union{Tuple{D}, Tuple{Union{Crystalline.CompositeBandRep{D}, Crystalline.NewBandRep{D}}, Crystalline.SymOperation{D}}, Tuple{Union{Crystalline.CompositeBandRep{D}, Crystalline.NewBandRep{D}}, Crystalline.SymOperation{D}, Array{Bravais.DirectPoint{D}, 1}}} where D","page":"API","title":"SymmetricTightBinding.sgrep_induced_by_siteir","text":"sgrep_induced_by_siteir(\n    br::Union{NewBandRep, CompositeBandRep},\n    op::SymOperation, [positions::Vector{<:DirectPoint}]\n)\nsgrep_induced_by_siteir(\n    tbm::Union{TightBindingModel,ParameterizedTightBindingModel}, op::SymOperation\n)\n    --> SiteInducedSGRepElement\n\nComputes the representation matrix of a symmetry operation op induced by the site symmetry group associated with an elementary or composite band representation br , including the global momentum-dependent phase factor, returning a SiteInducedSGRepElement, which is a functor over momentum inputs.\n\nA (possibly parameterized) tight-binding model tbm can be specified instead of a band representation, in which case the latter is inferred from the former.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.spectrum-Tuple{ParameterizedTightBindingModel, Any}","page":"API","title":"SymmetricTightBinding.spectrum","text":"spectrum(ptbm::ParameterizedTightBindingModel, ks; transform = identity)\n\nEvaluate the spectrum, i.e., energies, of the tight-binding model ptbm over an iterable of input momenta ks. \n\nEnergies are returned as a matrix, with rows running over momenta and columns over distinct bands.\n\nKeyword arguments\n\ntransform: a function to apply to the resulting matrix of energies, defaulting to the identity function. This can be used to e.g., convert the energies to a different scaling.\n\nExample\n\nAs an example, we evaluating the band structure of graphene. Below, we first construct and parameterize a tight-binding model for the the (2b|A‚ÇÅ) EBR in plane group 17, corresponding to the highest-lying orbitals in graphene. Next, we construct a path along high-symmetry directions of the Brillouin zone using Brillouin.jl, calculate the spectrum across this path; and finally, plot the band structure using Brillouin and GLMakie (or PlotlyJS):\n\njulia> using Crystalline, SymmetricTightBinding\n\njulia> brs = calc_bandreps(17, Val(2));\n\njulia> cbr = @composite brs[5]\n13-irrep CompositeBandRep{2}:\n (2b|A‚ÇÅ) (2 bands)\n\njulia> ptbm = tb_hamiltonian(cbr, [zeros(Int, dim(cbr))])([0.0, 1.0]);\n\njulia> using Brillouin, GLMakie\n\njulia> kpi = interpolate(irrfbz_path(17, directbasis(17, Val(2))), 100);\n\njulia> plot(kpi, spectrum(ptbm, kpi))\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.spectrum-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, AbstractVector{<:Real}}} where D","page":"API","title":"SymmetricTightBinding.spectrum","text":"spectrum(ptbm::ParameterizedTightBindingModel, k::AbstractVector{<:Real})\n\nEvaluate the spectrum, i.e., energies, of the tight-binding model ptbm at a single momentum k, across all the bands of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.subduced_complement-Union{Tuple{D}, Tuple{TightBindingModel{D}, Int64}} where D","page":"API","title":"SymmetricTightBinding.subduced_complement","text":"subduced_complement(tbm::TightBindingModel{D}, sgnum·¥¥::Int; timereversal)\n                                                    --> TightBindingModel{D}\n\nGiven a model tbm associated with a space group G, determine the new, independent tight-binding terms (i.e., the the orthogonal complement of terms) that become  symmetry-allowed when the model's space group is reduced to a subgroup H  G with space group number sgnum·¥¥ and time-reversal symmetry timereversal.\n\nPractically, the function answers the question: which new tight-binding terms become allowed if the symmetry of the model is reduced from space group G to subgroup H?\n\nImplementation\n\nThe function computes a basis of allowed tight-binding terms in the subgroup setting H by simply restricting the constraints in G to generators in H. This gives a basis for the tight-binding terms in the subduced G  H setting.  The space spanned by this basis is compared to the space spanned in the original model; in particular new terms are identified as the orthogonal complement of the spaces associated with G  H relative to G.\n\nKeywords\n\ntimereversal::Bool: Specifies whether time-reversal symmetry is present in the subgroup H. By default, the presence or absence is inherited from the original model tbm. Note that timereversal must be \"lower or equal to\" the time-reversal of the original model.\n\nExample\n\nIt is well-known that the Dirac point of graphene is gapped under mirror and time-reversal symmetry breaking. We can see this by constructing a tight-binding model first for a model of graphene (plane group ‚ãï17) and then subducing it to a setting without mirror symmetry (plane group ‚ãï16) and without time-reversal symmetry (timereversal = false). First, we construct the tight-binding model for graphene (via the (2a|A‚ÇÅ) band representation):\n\njulia> using SymmetricTightBinding, Crystalline\n\njulia> brs = calc_bandreps(17, Val(2); timereversal = true);\n\njulia> cbr = @composite brs[5]\n\njulia> tbm = tb_hamiltonian(cbr, [[0,0], [1,0]])\n\nEach of the 4 terms in this model is proportional to an identity matrix at K = (1/3, 1/3). Using subduced_complement, we can find the new terms that appear if we imagine lowering the symmetry from plane group ‚ãï17 to ‚ãï16 (which has no mirror symmetry) while also removing time-reversal symmetry.\n\njulia> Œîtbm = subduced_complement(tbm, 16; timereversal = false)\n2-term 2√ó2 TightBindingModel{2} over (2b|A‚ÇÅ):\n‚îå‚îÄ\n1. ‚é° iùïñ(Œ¥‚ÇÅ)+iùïñ(Œ¥‚ÇÇ)+iùïñ(Œ¥‚ÇÉ)-iùïñ(Œ¥‚ÇÑ)-iùïñ(Œ¥‚ÇÖ)-iùïñ(Œ¥‚ÇÜ)  0                                          ‚é§\n‚îÇ  ‚é£ 0                                          -iùïñ(Œ¥‚ÇÅ)-iùïñ(Œ¥‚ÇÇ)-iùïñ(Œ¥‚ÇÉ)+iùïñ(Œ¥‚ÇÑ)+iùïñ(Œ¥‚ÇÖ)+iùïñ(Œ¥‚ÇÜ) ‚é¶\n‚îî‚îÄ (2b|A‚ÇÅ) self-term:  Œ¥‚ÇÅ=[1,0], Œ¥‚ÇÇ=[0,1], Œ¥‚ÇÉ=[-1,-1], Œ¥‚ÇÑ=-Œ¥‚ÇÅ, Œ¥‚ÇÖ=-Œ¥‚ÇÇ, Œ¥‚ÇÜ=-Œ¥‚ÇÉ\n‚îå‚îÄ\n2. ‚é° 0                                       ùïñ(Œ¥‚ÇÅ)+ùïñ(Œ¥‚ÇÇ)+ùïñ(Œ¥‚ÇÉ)-ùïñ(Œ¥‚Çá)-ùïñ(Œ¥‚Çà)-ùïñ(Œ¥‚Çâ) ‚é§\n‚îÇ  ‚é£ ùïñ(Œ¥‚ÇÑ)+ùïñ(Œ¥‚ÇÖ)+ùïñ(Œ¥‚ÇÜ)-ùïñ(Œ¥‚ÇÅ‚ÇÄ)-ùïñ(Œ¥‚ÇÅ‚ÇÅ)-ùïñ(Œ¥‚ÇÅ‚ÇÇ)  0                                   ‚é¶\n‚îî‚îÄ (2b|A‚ÇÅ) self-term:  Œ¥‚ÇÅ=[4/3,-1/3], Œ¥‚ÇÇ=[1/3,5/3], Œ¥‚ÇÉ=[-5/3,-4/3], Œ¥‚ÇÑ=-Œ¥‚ÇÅ, Œ¥‚ÇÖ=-Œ¥‚ÇÇ, Œ¥‚ÇÜ=-Œ¥‚ÇÉ, Œ¥‚Çá=[1/3,-4/3], Œ¥‚Çà=[-5/3,-1/3], Œ¥‚Çâ=[4/3,5/3], Œ¥‚ÇÅ‚ÇÄ=-Œ¥‚Çá, Œ¥‚ÇÅ‚ÇÅ=-Œ¥‚Çà, Œ¥‚ÇÅ‚ÇÇ=-Œ¥‚Çâ\n\nThe first of the of these terms is not diagonal at K and so opens a gap at the Dirac point:\n\njulia> Œîtbm[1](ReciprocalPoint(1/3, 1/3))\n2√ó2 Matrix{ComplexF64}:\n 5.19615+1.73195e-14im       0.0+0.0im\n     0.0+0.0im          -5.19615+1.43774e-14im\n\nAdding symmetry-breaking terms to the original model\n\nTo build a \"complete\" model, with both the original and symmetry-breaking terms, use vcat:\n\njulia> tbm‚Ä≤ = vcat(tbm, Œîtbm); length(tbm‚Ä≤) == length(tbm) + length(Œîtbm)\ntrue\n\nLimitations\n\nThe subgroup H must be a volume-preserving subgroup of the original group G. I.e. H must be a translationen-gleiche subgroup of G (or G itself), and there must exist a transformation from G to H that preserves volume (i.e., has det(t.P) == 1 for t denoting an element returned by Crystalline.jl's conjugacy_relations).\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.symmetry_eigenvalues-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, AbstractArray{Crystalline.SymOperation{D}, 1}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{ParameterizedTightBindingModel{D}, AbstractArray{Crystalline.SymOperation{D}, 1}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, AbstractArray{SymmetricTightBinding.SiteInducedSGRepElement{D}, 1}}} where D","page":"API","title":"SymmetricTightBinding.symmetry_eigenvalues","text":"symmetry_eigenvalues(\n    ptbm::ParameterizedTightBindingModel{D},\n    ops::AbstractVector{SymOperation{D}},\n    k::ReciprocalPointLike{D},\n    [sgreps::AbstractVector{SiteInducedSGRepElement{D}}]\n)\nsymmetry_eigenvalues(\n    ptbm::ParameterizedTightBindingModel{D},\n    lg::LittleGroup{D},\n    [sgreps::AbstractVector{SiteInducedSGRepElement{D}}]\n)\n    --> Matrix{ComplexF64}\n\nCompute the symmetry eigenvalues of a coefficient-parameterized tight-binding model ptbm at the k-point k for the symmetry operations ops. A LittleGroup can also be provided instead of ops and k.\n\nRepresentations of the symmetry operations ops as acting on the orbitals of the tight-binding setting can optionally be provided in sgreps (see sgrep_induced_by_siteir) and are otherwise initialized by the function.\n\nThe symmetry eigenvalues are returned as a matrix, with rows running over the elements of ops and columns running over the bands of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.tb_hamiltonian-Union{Tuple{Crystalline.CompositeBandRep{D}}, Tuple{D}, Tuple{Crystalline.CompositeBandRep{D}, AbstractVector{Vector{Int64}}}} where D","page":"API","title":"SymmetricTightBinding.tb_hamiltonian","text":"tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) \n    --> Vector{TightBindingTerm{D}}\n\nConstruct the TB Hamiltonian matrix from a given composite band representation cbr and a set of global translation-representatives Rs. The Hamiltonian is constructed block by block according to the symmetry-related hoppings between the band representations in cbr. Several models returned, each representing a term that is closed under the symmetry operations of  the underlying space group.\n\n\n\n\n\n","category":"method"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#SymmetricTightBinding.HoppingOrbit","page":"API","title":"SymmetricTightBinding.HoppingOrbit","text":"HoppingOrbit{D}\n\nA structure holding information about symmetry-related spatial hopping vectors.\n\nAn orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the symmetry operations of the underlying space group to a representative vector Œ¥.\n\nFor each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site a to site b, possibly related by a lattice translation R. Each such set of possible hopping term (a, b, R) is for each Œ¥·µ¢ is stored elements as the ith element of the vector hoppings.\n\nFields\n\nrepresentative :: RVec{D}: the representative hopping vector Œ¥\norbit :: Vector{RVec{D}}: the Œ¥·µ¢ elements of the orbit generated by Œ¥. Generally orbit[1] == representative, i.e., Œ¥‚ÇÅ = Œ¥\nhoppings :: Vector{Vector{NTuple{3,RVec{D}}}}: the ith element gives the possible physical hopping terms (a,b,R) associated to orbit[i]. Multiple physical hopping terms may correspond to each element of the orbit.  For (a, b, R) = hoppings[i][j], we have orbit[i] = Œ¥·µ¢ = b + R - a\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.ParameterizedTightBindingModel","page":"API","title":"SymmetricTightBinding.ParameterizedTightBindingModel","text":"ParameterizedTightBindingModel{D}\n\nA coefficient-parameterized tight-binding model, that can be used as a functor for evaluation at input momenta k.\n\nFields\n\ntbm :: TightBindingModel{D}: A tight-binding model, consisting of a set of a list of TightBindingTerm{D}s.\ncs :: Vector{Float64}: A vector of coefficients, each associated to a corresponding element of tbm.\nscratch :: Matrix{ComplexF64}: A scratch space for evaluating the Hamiltonian matrix at at specific momenta. This is a N√óN matrix, where N is the number of orbitals in tbm (i.e., tbm.N). The scratch space is instantiated automatically on construction.\n\nFunctor over momenta\n\nA ParameterizedTightBindingModel ptbm can be be evaluated at any ¬¥D-dimensional momentumkby usingptbmas a functor. That is,ptbm(k)returns a numerical representation of the Hamiltonian matrix forptbmevaluated at momentumk.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.TightBindingElementString","page":"API","title":"SymmetricTightBinding.TightBindingElementString","text":"TightBindingElementString\n\nA structure for pretty-printing tight-binding matrix elements.\n\nFields\n\ns :: String: the string representing the tight-binding matrix element\nactive :: Bool: whether the element belongs to an \"active\" block - i.e., one we want to highlight (then shown in blue).\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.TightBindingModel","page":"API","title":"SymmetricTightBinding.TightBindingModel","text":"TightBindingModel{D}\n\nA structure storing a list of TightBindingTerm{D}s. Each term is assumed to associated with an identical list of EBRs.\n\nTo associate a set of coefficients to each term, see ParameterizedTightBindingModel, which also allows evaluation at specific momenta.\n\nFields\n\nterms :: Vector{TightBindingTerm{D}}: a vector of TightBindingTerm{D}s, each of which represents a block (or conjugated pairs of blocks) of the Hamiltonian matrix.\ncbr :: CompositeBandRep{D}: the composite band representation associated to the model.\npositions :: Vector{DirectPoint{D}}: a vector of positions, specified in the lattice basis, associated to each orbital of the model.\nN :: Int: the total number of orbitals in the model, i.e., the size of the Hamiltonian matrix associated to each element of terms.\n\n\n\n\n\n","category":"type"},{"location":"symmetry-breaking/#Symmetry-breaking","page":"Symmetry breaking","title":"Symmetry breaking","text":"","category":"section"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"A frequent question in tight-binding modelling is whether ‚Äì and which ‚Äì new hoppings terms might become allowed if the overall symmetry is reduced, either by breaking spatial symmetries or time-reversal symmetry. Such terms might e.g., break degeneracies or enable topological phase transitions.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"SymmetricTightBinding.jl exports subduced_complement as a tool to answer exactly this question. Here, we apply it to understand the effect of symmetry breaking on a 2-band model in plane group p4mm (‚ãï11).","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"We start by constructing our symmetry-unbroken model, picking the (2c|A‚ÇÅ) band representation of p4mm:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"using Crystalline, SymmetricTightBinding\nbrs = calc_bandreps(11, Val(2))\ncbr = @composite brs[1]\ntbm = tb_hamiltonian(cbr, [[0,0], [1,0]])\nptbm = tbm([0, 1, -1, 1])","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"note: Interpretation of tight-binding terms\nWe can visualize the tight-binding terms using plot, providing also a lattice basis for the illustration:using GLMakie\nplot(tbm, directbasis(11, Val(2)))While terms 3 and 4 appear identical in this visualization, they are not (cf. issue #75): in term 3, horizontal hoppings (Œ¥‚ÇÅ and Œ¥‚ÇÇ) are associated to the first Wyckoff position (at [1/2, 0]) and vertical hoppings to the second Wyckoff position (at [0, 1/2]), and vice versa for term 4.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"The parameterized model has a quadratic degeneracy at M, associated with the M‚ÇÖ irrep:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"using Brillouin, GLMakie\nRs = directbasis(11, Val(2));\nkp = irrfbz_path(11, Rs);\nkpi = interpolate(kp, 100);","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"plot(kpi, spectrum(ptbm, kpi))","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"We can study whether any additional terms become allowed if we reduce the symmetry. For instance, we might breaj the 4-fold rotational symmetry, reducing the plane group symmetry from p4mm (#11) to p2mm (#6):","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Œîtbm_C‚ÇÑ = subduced_complement(tbm, 6) # break 4-fold rotation sym.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"This allows three additional terms. Conversely, we could have also tried to break time-reversal or mirror symmetry (in the latter case, reducing the plane group symmetry to p4 (‚ãï10)). However, both of these cases allow no new terms [1]:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Œîtbm_m  = subduced_complement(tbm, 10);                       # break mirror\nŒîtbm_tr = subduced_complement(tbm, 11; timereversal = false); # break TR","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"[1]: For mirror symmetry-breaking, the absence of new terms is a result of looking only at a limited set of hopping orbits (in the original model tb_hamiltonian(cbr, [[0,0], [1,0]])): by including longer-range hopping orbits, we would eventually find new mirror-symmetry-broken terms. This is not so for time-reversal breaking, however: in p4mm, mirror symmetry and hermicity jointly impose an effective time-reversal symmetry.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"However, by breaking both mirror and time-reversal symmetry simultaneously, additional terms do appear:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"We can also break both symmetry simultaneously:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"Œîtbm_mtr = subduced_complement(tbm, 10; timereversal = false) # break mirror & TR","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"That the result is effecitvely \"more than the sum of the parts\" of breaking time-reversal and mirror symmetry individually is merely a reflection of the fact that the term is only allowed when both time-reversal symmetry and mirror symmetry is broken (or, put differently, the term is not invariant under either symmetry, and so forbidden in the presence of either).","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"note: Subgroup relationships\nTo determine which symmetry-reductions are possible ‚Äì or, equivalently, which subgroups a particular group might have ‚Äì use Crystalline.jl's maximal_subgroups(num(tbm)). Note, however, that subduced_complement only allows subgroup-relationships that do not involve a change of unit cell volume; i.e., the subgroup relationship cannot be associated with a change of translational symmetry.","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"We can build a new \"total\" model, incorporating both the original terms as well as any additional symmetry-breaking terms by using vcat. For instance, we could incorporate the mirror-and-time-reversal symmetry breaking term into the original model:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"tbm‚Ä≤ = vcat(tbm, Œîtbm_mtr)","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"And we can then verify that the original band degeneracy at M is split when the mirror-and-time-reversal-breaking term is nonzero:","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"ptbm‚Ä≤ = tbm‚Ä≤([0, 1, -1, 1 #= original terms =#,\n              0.1         #= symmetry breaking =#])","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"plot(kpi, spectrum(ptbm‚Ä≤, kpi))","category":"page"},{"location":"symmetry-breaking/","page":"Symmetry breaking","title":"Symmetry breaking","text":"warning: Symmetry analysis in a symmetry-broken setting\nWhile the \"total\" models tbm‚Ä≤ and ptbm‚Ä≤ work well for e.g., band structure purposes, they are not amenable to symmetry analysis in the symmetry-reduced setting. This is because the associated band representations in tbm‚Ä≤, which are used to infer the \"ingredients\" of the symmetry analysis, still refer to the original group's symmetry, i.e., to p11 rather than p10.This may change in future versions of SymmetricTightBinding.jl, depending on available time.","category":"page"},{"location":"theory/#Theory-Notes","page":"Theory","title":"Theory Notes","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"This package heavily relies on representation theory of groups and on band theory of crystals. Almost all of this theory was introduced before and can be found in Bradley & Cracknell and later developed by Bradlyn et al.. Here, we aim to provide a practical introduction to the main concepts and derive the essential functions and relations that we need for the implementation of this package. Additionally, we generalize some of the previously derived results and make them more accessible to the general public.","category":"page"},{"location":"theory/#Table-of-contents","page":"Theory","title":"Table of contents","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Theory Notes\nTable of contents\nIntroduction\nTransformation properties of orbitals\nTransformation properties of induced Bloch functions\nBuild a tight-binding Hamiltonian from a set of symmetric orbitals\nTransformation properties under symmetry operations\nTransformation properties under time reversal symmetry\nTransformation properties of the Bloch states\nTransformation properties under lattice translations\nTransformation properties under symmetry operations\nImplementing Symbolic Hamiltonians in Non-Symbolic Environments\nSymmetry constraints in the numerical matrix ùêå\nTime reversal constraint in the numerical matrix ùêå\nAppendix A\nTransformation properties within Convention 2\nBloch Hamiltonian under Convention 2\nBloch states under Convention 2\nTransformation under lattice translations\nTransformation properties under symmetry operations\nConversions between Convention 1 and 2\nAppendix B","category":"page"},{"location":"theory/#Introduction","page":"Theory","title":"Introduction","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The introduction of Topological Quantum Chemistry (TQC) established a link between trivial insulators and atomic limits. It states that if a set of isolated bands can be described by a set of isolated ‚Äî atomic-like ‚Äî orbitals, the set must be topologically trivial. This link is determined by first analyzing all band symmetries of these \"atomic-like\" orbitals. Then, the set of bands under study will be nontrivial if it does not fit into that list.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The analysis of the band symmetries of the isolated orbitals can be performed by placing localized, symmetric orbitals at some high-symmetry points ùê™_Œ± ‚Äî Wyckoff positions ‚Äî with some internal symmetry ‚Äî corresponding to a particular site-symmetry irrep œÅ. Those orbitals can be labeled as œï_Œ±i(ùê´), where i runs over the dimension of the irrep œÅ, or just by (ùê™_Œ±œÅ). By applying the Fourier transform, the induced Bloch functions can be obtained as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÜ_Œ±iùê§(ùê´) = sum_ùê≠ e^iùê§ùê≠ œï_Œ±i(ùê´-ùê≠)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"How œÜ_Œ±iùê§(ùê´) transforms under symmetries will define a band representation.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The idea behind this package is to use these orbitals to build a tight-binding model that respects the symmetries and topology of the (trivial) set of bands whose band representation is matched by such a set of orbitals.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To do so, it is necessary to access all possible types of symmetry-independent orbitals and high-symmetry points in every space group. Luckily, this was tabulated by Bradley & Cracknell and implemented in the Julia package Crystalline.jl. This package depends on the latter package to access that information.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now that the basic framework has been established, in the following sections we deduce how these functions transform and how they can be used to build a symmetric tight-binding model.","category":"page"},{"location":"theory/#Transformation-properties-of-orbitals","page":"Theory","title":"Transformation properties of orbitals","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us assume we have identified a set of orbitals that describe the band structure of a trivial set of bands. This can be achieved through a TQC analysis of the bands, and several tools exist to perform such a decomposition. For example, the package PhotonicTightBinding.jl provides this functionality for photonic bands.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[!NOTE] For instance, Graphene's two p<sub>z</sub> orbitals sit at the 2b Wyckoff position. Although these orbitals are odd (i.e., changing sign) under mirror in the out-of-plane direction, they are even (i.e., invariant) under all in-plane symmetries, including rotations and mirrors. The corresponding site-symmetry irrep is the A‚ÇÅ irrep of the 2b Wyckoff position. Thus, these orbitals can be expressed as (2b|A‚ÇÅ). However, take into account that not all band representations can be induced from a set of atomic (electronic) orbitals. Some might correspond to a hybridization or a complex mixture of them.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us denote by Œ± the site in the Wyckoff position where the orbital is located, and let i label the orbitals associated with that site. Then, the orbital i at site Œ± can be denoted as œï_I(ùê´), where we introduce the compound index I=(Œ±i). The complete set of orbitals needed to describe the system is obtained by considering all orbitals at all sites and all lattice translations of them, i.e., œï_I(ùê´-ùê≠)_Iùê≠, where ùê≠ is a lattice translation vector.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We focus on a particular site ùê™_1, whose orbitals œï_1i(ùê´) transform under a particular site-symmetry representation œÅ of the site-symmetry group G_ùê™_1. Then, for h  G_ùê™_1, this function transforms as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"h œï_1i(ùê´) = œÅ(h)_ji œï_1j(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since the orbitals are localized at a Wyckoff position, there exists a coset decomposition of the space group G relating each site in the Wyckoff position, i.e., ùê™_Œ± = g_Œ± ùê™_1 with g_Œ±  G.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[!NOTE] The set of g_Œ±, in combination with translations T, will generate a decomposition of G with respect to G_ùê™:G = bigcup_Œ± g_Œ± (G_ùê™_1 ltimes T)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Thus, each function in the unit cell can be built from the ones at site ùê™_1 as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œï_Œ±i(ùê´) = g_Œ± œï_1i(ùê´) = œï_1i(g_Œ±^-1 ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"By extension, translated counterparts can be defined by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Eùê≠ œï_I(ùê´) = œï_I(ùê´-ùê≠)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The aforementioned coset decomposition also has an interesting implication: for any operation g = RùêØ  G, there is a unique choice of Œ≤ for each Œ± such that g g_Œ± = Eùê≠_Œ≤Œ± g_Œ≤ h, for some h  G_ùê™_1 and ùê≠_Œ≤Œ± = g ùê™_Œ± - ùê™_Œ≤. The formal proof of this statement is beyond the scope of these notes and can be found in this article. An intuitive picture of this statement is shown in the following figure:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: Coset decomposition)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Taking into consideration the definitions of the transformed orbitals and the previous decomposition, we deduce that the orbitals transform under the induced representation œÅ_G according to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÅ_G(g) œï_Œ±i(ùê´-ùê≠) = g Eùê≠ œï_Œ±i(ùê´) \n= ERùê≠ g œï_Œ±i(ùê´) \n= ERùê≠ Eùê≠_Œ≤Œ± g_Œ≤ h g_Œ±^-1 œï_Œ±i(ùê´) \n= ERùê≠ + ùê≠_Œ≤Œ± g_Œ≤ h œï_1i(ùê´) \n= sum_j ERùê≠ + ùê≠_Œ≤Œ± g_Œ≤ œÅ(h)_ji œï_1j(ùê´) \n= sum_j œÅ(h)_ji ERùê≠ + ùê≠_Œ≤Œ± œï_Œ≤j(ùê´) \n= sum_j œÅ(h)_ji œï_Œ≤j(ùê´ - Rùê≠ - ùê≠_Œ≤Œ±)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In principle, we could use the complete set of orbitals ‚Äî œï_I(ùê´-ùê≠), with all degrees of freedom I and all lattice translations ùê≠ ‚Äî to build a tight-binding model. However, it is more practical (and usual) to use the translational invariance of these orbitals to define a Fourier transform and use their Fourier-transformed functions as a basis ‚Äî we label such functions as induced Bloch functions. By doing so, instead of working with dim(I)  N orbitals, where dim(I) is the number of sites plus the number of orbitals at each site and N is the number of unit cells, we consider dim(I) functions evaluated at N points inside the Brillouin zone.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"However, when defining a Fourier transform, there is a gauge freedom which leads to different, so-called, ‚Äúconventions.‚Äù This choice has important implications for the representations of the symmetry operations and even for the representation of the Hamiltonian. Here, we focus on one convention and discuss changes and similarities with another convention in Appendix A.","category":"page"},{"location":"theory/#Transformation-properties-of-induced-Bloch-functions","page":"Theory","title":"Transformation properties of induced Bloch functions","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Using the translational invariance of the orbitals, we can formally define a Fourier transform of them. These functions will not be solutions to any Schr√∂dinger-like problem, so instead of calling them Bloch states, we use the term induced Bloch functions, or just Bloch functions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As mentioned before, there is a gauge freedom in the choice of the Fourier transform. Here, we choose the following one:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÜ_Iùê§(ùê´)  sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) œï_I(ùê´-ùê≠)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The main reason behind this choice is the fact that, with this gauge, the ùê§-space dependence of the representation of space-group transformations enters as a global phase, as we will see. This is convenient for computational purposes, which is why we chose it. However, this convention implies that the Bloch functions are not periodic in reciprocal space:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÜ_Iùê§+ùêÜ = sum_ùê≠ e^i(ùê§+ùêÜ)(ùê≠+ùê™_Œ±) œï_I(ùê´-ùê≠) \n= sum_ùê≠ e^iùêÜ(ùê≠+ùê™_Œ±) e^iùê§(ùê≠+ùê™_Œ±) œï_I(ùê´-ùê≠) \n= e^iùêÜùê™_Œ± œÜ_Iùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This implies that if the orbital is located at a non-integer position in the unit cell (i.e., not at positions that are integer combinations of lattice vectors), the phase factor will differ from unity and the Bloch function will gain a phase. Thus, in general, the Bloch functions are not periodic under reciprocal lattice translations within this convention. This has implications for computing parts of this package, such as the representation of symmetry operations or symmetry eigenvalues.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since these functions are derived from the orbitals, the transformation properties of these functions can be obtained. How these functions transform under symmetry operations constitutes what is usually called a band representation. In particular, this band representation will be:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g œÜ_iŒ±ùê§(ùê´) = frac1sqrtN sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) g œï_iŒ±(ùê´-ùê≠) \n= frac1sqrtN sum_ùê≠j e^iùê§(ùê≠+ùê™_Œ±) œÅ(h)_ji œï_jŒ≤(ùê´-Rùê≠-ùê≠_Œ≤Œ±) \n= frac1sqrtN sum_ùê≠j œÅ(h)_ji e^iùê§R^-1(ùê≠+ùê™_Œ≤-ùêØ) œï_jŒ≤(ùê´-ùê≠) \n= e^-i(R^-1^T ùê§)ùêØ frac1sqrtN sum_ùê≠j œÅ(h)_ji e^i(R^-1^T ùê§)(ùê≠+ùê™_Œ≤) œï_jŒ≤(ùê´-ùê≠) \n= e^-i(R^-1^T ùê§)ùêØ sum_j œÅ(h)_ji œÜ_jŒ≤R^-1^T ùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have defined ùê≠ = Rùê≠ + ùê≠_Œ≤Œ±  ùê≠ = R^-1 (ùê≠-ùê≠_Œ≤Œ±), and we have used the following property: ùê§(R ùê´) = (R^T ùê§)ùê´. Finally, if we define the action of a symmetry operation g = RùêØ on a reciprocal space vector ùê§ as: gùê§  R^-1^T ùê§, we can rewrite the previous relation as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g œÜ_Iùê§(ùê´) = e^-i(g ùê§)ùêØ sum_J œÅ(h)_JI œÜ_Jg ùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This relation is crucial in the implementation of the package, since it states the band representation of the system. If a tight-binding model is built from this set of functions, its band structure will, by construction, replicate that of the original system. In other words, the tight-binding model will inherit all symmetries of the system, forcing the same degeneracies the system has, and exhibit the same symmetry-indicated topology.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the sake of simplicity, we define a matrix ùêÉ_ùê§(g) whose entries are given by the previous operation, i.e., ùêÉ_ùê§(g)_JI = e^-i(g ùê§)ùêØ œÅ(h)_JI, where I = (Œ±i), J = (Œ≤j) and ùê≠_Œ≤Œ± = g ùê™_Œ± - ùê™_Œ≤. Then, we can rewrite the previous relation as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"boxedg œÜ_Iùê§(ùê´) = sum_J ùêÉ_ùê§(g)_JI œÜ_Jg ùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"It is important to notice that the dependence on ùê§ of the representation ùêÉ_ùê§ is a global phase factor. This is convenient for computational purposes when imposing the symmetry constraints in the Hamiltonian.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Our next objective is to build a tight-binding model that uses these functions as a basis and replicates the band structure of the system. We perform this construction in the next section.","category":"page"},{"location":"theory/#Build-a-tight-binding-Hamiltonian-from-a-set-of-symmetric-orbitals","page":"Theory","title":"Build a tight-binding Hamiltonian from a set of symmetric orbitals","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Second quantization rephrases quantum mechanics in terms of fields and occupation numbers. Instead of tracking individual particles, we describe how many particles occupy each quantum state.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In order to do so, we need to introduce creation and annihilation operators. Since we want to use the basis of orbitals previously introduced, we can define them as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœï_Iùê≠  ƒâ^_Iùê≠ kettextvac","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, the most general tight-binding Hamiltonian can be written using those operators as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùê≠ùê≠ h_IJùê≠-ùê≠ ƒâ^_Iùê≠ ƒâ_Jùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This Hamiltonian states that the probability amplitude of \"hopping\" from an orbital ketœï_Jùê≠ to an orbital ketœï_Iùê≠ is given by the amplitude term h_IJùê≠-ùê≠. Notice that we have assumed that the hopping amplitude depends only on the relative distance between both orbitals. This implies that the Hamiltonian is translation invariant, as it should be. In the following, we refer to that distance as ùêë = ùê≠-ùê≠. Realize that it must be a lattice translation. Using this definition we can rewrite the previous Hamiltonian as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùêëùê≠ h_IJùêë ƒâ^_Iùêë+ùê≠ ƒâ_Jùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In order to be consistent with the previous choice of the Fourier transform, the creation operator in reciprocal space must be related to ƒâ^_Iùê≠ by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœÜ_Iùê§ = √¢_Iùê§^ kettextvac \n= frac1sqrtN sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠ = frac1sqrtN sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) ƒâ_Iùê≠^ kettextvac \n √¢_Iùê§^ = frac1sqrtN sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) ƒâ_Iùê≠^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that since œÜ_Iùê§+ùêÜ(ùê´) = e^iùêÜùê™_Œ± œÜ_Iùê§(ùê´), we also have √¢_Iùê§+ùêÜ^ = e^iùêÜùê™_Œ± √¢_Iùê§^, consistently.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Considering this, we can rewrite the tight-binding Hamiltonian in reciprocal space as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = frac1N sum_IJùêëùê≠ h_IJùêë sum_ùê§ùê§ e^iùê§(ùêë+ùê≠+ùê™_Œ±) e^-iùê§(ùê≠+ùê™_Œ≤) √¢_Iùê§^ √¢_Jùê§ \n= frac1N sum_IJùêëùê≠ùê§ùê§ h_IJùêë e^iùê§(ùêë+ùê™_Œ±) e^i(ùê§-ùê§)ùê≠ e^-ùê§ùê™_Œ≤ √¢_Iùê§^ √¢_Jùê§ \n= sum_IJùêëùê§ h_IJùêë e^iùê§(ùêë+ùê™_Œ±-ùê™_Œ≤) √¢_Iùê§^ √¢_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have used the property of exponential functions: sum_ùê≠ e^i(ùê§-ùê§)ùê≠ = N Œ¥_ùê§ùê§.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Finally, if we define h_IJùê§ = sum_ùêë h_IJùêë e^iùê§(ùêë+ùê™_Œ±-ùê™_Œ≤), we obtain the usual expression for a tight-binding Hamiltonian in reciprocal space:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùê§ h_IJùê§ √¢_Iùê§^ √¢_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As shown, the hopping amplitude in reciprocal space is computed from a sum of the real-space hopping amplitudes for all lattice translations ùêë. Usually, such a sum is truncated with some \"arbitrary\" (subjective) cutoff. One common approach is to consider a certain number of nearest neighbors. Since we are interested in building a symmetry-constrained tight-binding model and symmetry-related terms might not coincide with n-th nearest neighbors, we consider a different approach. As we will develop later, our strategy focuses on asking the user to provide a set of ùêë-vectors where to look, at least, for hopping terms, and then search for all symmetry-related terms starting from that initial, but potentially not complete, set.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As can be seen, the tight-binding Hamiltonian is diagonal in reciprocal space. This is due to the assumption that the Hamiltonian is translation invariant. Then, it is natural to define what is usually called the Bloch Hamiltonian ƒ§_ùê§, which consists of the diagonal blocks in reciprocal space of the tight-binding Hamiltonian:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§ = sum_IJ h_IJùê§ √¢_Iùê§^ √¢_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Some general properties must be fulfilled independent of its representation, such as periodicity in reciprocal space. However, as shown above, the creation and annihilation operators are not periodic under reciprocal lattice translations and we also have that:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"h_IJùê§+ùêÜ = sum_ùêë h_IJùêë e^i(ùê§+ùêÜ)(ùêë+ùê™_Œ≤-ùê™_Œ±) \n= e^iùêÜ(ùê™_Œ≤-ùê™_Œ±) sum_ùêë h_IJùêë cancele^iùêÜùêë e^iùê§(ùêë+ùê™_Œ≤-ùê™_Œ±) \n= e^iùêÜ(ùê™_Œ≤-ùê™_Œ±) h_IJùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"However, all these phase factors cancel out in the Bloch Hamiltonian, so it is translationally invariant in reciprocal space, as can be seen:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§+ùêÜ = sum_IJ h_IJùê§+ùêÜ √¢_Iùê§+ùêÜ^ √¢_Jùê§+ùêÜ \n= sum_IJ e^iùêÜ(ùê™_Œ≤-ùê™_Œ±) h_IJùê§ e^iùêÜùê™_Œ± √¢_Iùê§^ e^-iùêÜùê™_Œ≤ √¢_Jùê§ \n= sum_IJ h_IJùê§ √¢_Iùê§^ √¢_Jùê§ = ƒ§_ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, we obtain the important translational invariance in reciprocal space of the Bloch Hamiltonian: ƒ§_ùê§+ùêÜ = ƒ§_ùê§. This property allows us to consider only the first Brillouin zone when we examine the Bloch Hamiltonian.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch Hamiltonian can be expressed as a matrix by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§ = √Ç_ùê§^ ùêá_ùê§ √Ç_ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where √Ç_ùê§^ =  √¢_1ùê§^ √¢_2ùê§^   is a row vector collecting all creation operators, similarly with √Ç_ùê§, and ùêá_ùê§ is a complex matrix whose each entry is defined by: ùêá_ùê§_IJ  h_IJùê§. The matrix ùêá_ùê§ is the one we are going to use in our package to compute the eigenvectors and eigenvalues for each ùê§-point.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this matrix ùêá_ùê§ is strongly dependent on the Fourier transform chosen. As proved above, within this convention, this matrix is not invariant under reciprocal lattice translations. However, this does not hold under other conventions as exposed in Appendix A. This property is not suitable for computing some fundamental properties such as the symmetry eigenvalues, but it has some computational advantages when encoding the matrix representation ùêá_ùê§ in the package.","category":"page"},{"location":"theory/#Transformation-properties-under-symmetry-operations","page":"Theory","title":"Transformation properties under symmetry operations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Before proceeding, we deduce the constraints that the symmetries of the system impose on the matrix ùêá_ùê§. This will ensure that the model replicates the symmetry and (symmetry-indicated) topology of the system. For that purpose, first, we deduce how the creation and annihilation operators transform under the symmetry operations. Let us start with the creation operator:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒù √¢_Iùê§^ ƒù^-1 kettextvac = ƒù √¢_Iùê§^ kettextvac = ƒù ketœÜ_Iùê§ \n= sum_J ùêÉ_ùê§(g)_JI ketœÜ_Jgùê§ = sum_J ùêÉ_ùê§(g)_JI √¢_Jgùê§^ kettextvac \n ƒù √¢_Iùê§^ ƒù^-1 = sum_J ùêÉ_ùê§(g)_JI √¢_Jgùê§^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since the symmetry operations ƒù are unitary, i.e., ƒù^-1 = ƒù^, we can deduce the transformation properties of the annihilation operator from those of the creation operator, resulting in the relation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒù √¢_Iùê§ ƒù^-1 = sum_J ùêÉ_ùê§^*(g)_JI √¢_Jgùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Considering these two transformation properties of the operators, we can deduce the set of relations that the symmetry operations enforce on the Bloch Hamiltonian. The invariance of the Hamiltonian under symmetry operations reads as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = ƒù ƒ§ ƒù^-1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Expanding the Hamiltonian in terms of the creation and annihilation operator basis leads us to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"sum_IJùê§ √¢_Iùê§^ h_IJùê§ √¢_Jùê§ = sum_IJùê§ ƒù √¢_Iùê§^ h_IJùê§ √¢_Jùê§ ƒù^-1 \n= sum_IJùê§ ƒù √¢_Iùê§^ ƒù^-1 h_IJùê§ ƒù √¢_Jùê§ ƒù^-1 \n= sum_IJùê§IJ ùêÉ_ùê§(g)_II √¢_Igùê§^  h_IJùê§ ùêÉ_ùê§^*(g)_JJ √¢_Jgùê§ \n= sum_ùê§IJ √¢_Igùê§^ ùêÉ_ùê§(g) ùêá_ùê§ ùêÉ_ùê§^(g)_IJ √¢_Jgùê§ \n boxedùêá_gùê§ = ùêÉ_ùê§(g) ùêá_ùê§ ùêÉ_ùê§^(g)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This symmetry constraint strongly restricts the functional form of ùêá_ùê§. Rather than being a completely general Hermitian (or anti-Hermitian) matrix, ùêá_ùê§ must now lie in the subspace of matrices that fulfill the previous constraints. This ensures that the model preserves all symmetries and reproduces the correct degeneracies and connectivity of the original band structure.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Additionally, as explained above, the ùê§-dependence of the representation matrices ùêÉ_ùê§ is only a global phase factor, so it can be dropped in the previous relation. This is very convenient in implementation-wise since the ùê§-dependence in the previous relation is restricted to just the matrix ùêá_ùê§, making it easier to encode in non-symbolic programming languages such as Julia.","category":"page"},{"location":"theory/#Transformation-properties-under-time-reversal-symmetry","page":"Theory","title":"Transformation properties under time reversal symmetry","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"For time reversal symmetry ùíØ, a similar computation can be performed. The representation of the action of time reversal in our basis can be decomposed into two parts: œÅ(ùíØ) = Œì(ùíØ) K, where K is complex conjugation.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us assume that our basis is real so we can pick Œì(ùíØ) = ùïÄ, i.e., the identity matrix. This choice can be made if the representations are realified as explained in Appendix B.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, the action of this symmetry over the Bloch functions will be the following:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatùíØ (Œ± ketœÜ_Iùê§) = Œ±^* hatùíØ sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠ \n= Œ±^* sum_ùê≠ e^-iùê§(ùê≠+ùê™_Œ±) hatùíØ ketœï_Iùê≠ \n= Œ±^* sum_ùê≠ e^-iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠ \n= Œ±^* ketœÜ_I-ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where Œ±  mathbbC. Notice that time reversal is not a linear operator.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Following a similar strategy as before, the following relations for the creation and annihilation operators can be found:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"boxedhatùíØ hata^_Imathbfk hatùíØ^-1 = \nhata^_I-mathbfk quad hatùíØ hata_Imathbfk \nhatùíØ^-1 = hata_I-mathbfk","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, the invariance under time reversal symmetry of the Hamiltonian is simply reduced to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"$","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"\\hat{ùíØ} \\hat{H} \\hat{ùíØ}^{-1} = \\sum{IJ,ùê§} \\hat{ùíØ} \\hat{a}^‚Ä†{I,ùê§} h{IJ,ùê§} \\hat{a}{J,ùê§} \\hat{ùíØ}^{-1} \\\n= \\sum{IJ,ùê§} \\hat{ùíØ} \\hat{a}^‚Ä†{I,ùê§} \\hat{ùíØ}^{-1} h^{IJ,ùê§} \\hat{ùíØ} \\hat{a}{J,ùê§} \\hat{ùíØ}^{-1} \\\n= \\sum{IJ,ùê§} \\hat{a}^‚Ä†{I,-ùê§} h^{IJ,ùê§} \\hat{a}{J,-ùê§} = \\\n\\hat{H} = \\sum{IJ,ùê§} \\hat{a}^‚Ä†{I,ùê§} h{IJ,ùê§} \\hat{a}{J,ùê§} $","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Obtaining the following relation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"$","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"\\boxed{ùêáùê§ = ùêá^*{-ùê§}} $","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As stated previously, we are interested in diagonalizing this matrix and finding the eigenvectors and eigenvalues associated with it at each ùê§-point. Those eigenvectors correspond to vectors of coefficients, associated with the basis set on which we built the Bloch Hamiltonian, and describe the Bloch state of the system at a particular ùê§-point and energy. In the following section, we elaborate on this topic and develop how these Bloch states transform under the symmetry operations of the system. A sanity check is to compare the band representation of both the real system‚Äôs band structure and the tight-binding model‚Äôs band structure, which should be equal.","category":"page"},{"location":"theory/#Transformation-properties-of-the-Bloch-states","page":"Theory","title":"Transformation properties of the Bloch states","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Until now we have focused on building a symmetry-constrained Hamiltonian to model the band structure of a physical system. Now, we shift our attention to analyze the properties of the Bloch states of the model, which must replicate the band structure of the physical system.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us start by defining the eigenvalue problem from which we start:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá_ùê§ ùê∞_nùê§ = E_nùê§ ùê∞_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where E_nùê§ is the set of eigenvalues (energies) at each ùê§-point and ùê∞_nùê§ the set of eigenvectors associated with them. Each eigenvector is a vector of coefficients which corresponds to a particular Bloch state in the basis used for describing the Bloch Hamiltonian, i.e.:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœà_nùê§ = sum_I w_Inùê§ ketœÜ_Iùê§ = frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now that the Bloch states have been defined, we can deduce their transformation properties. First, we analyze their transformation properties under lattice translations in real and reciprocal space and, subsequently, their transformation properties under symmetry operation of the space group.","category":"page"},{"location":"theory/#Transformation-properties-under-lattice-translations","page":"Theory","title":"Transformation properties under lattice translations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us first consider lattice translations in real space:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œà_nùê§(ùê´+ùêë) = braketùê´+ùêëœà_nùê§ \n= frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) braketùê´+ùêëœï_nùê≠ \n= frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) braketùê´œï_nùê≠-ùêë \n= e^iùê§ùêë frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠-ùêë+ùê™_Œ±) braketùê´œï_nùê≠-ùêë \n= e^iùê§ùêë braketùê´œà_nùê§ = e^iùê§ùêë œà_nùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch states transform as Bloch functions under translations in real space, as expected.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, let us analyze how they transform under reciprocal lattice translations. Recall that, within this convention, the matrix representation ùêá_ùê§ is not periodic under reciprocal lattice translations. This implies that ùê∞_nùê§ will not be either, but the eigenvalues E_nùê§ must be periodic since those are the energies associated with each Bloch state ‚Äî independent of the basis chosen to represent the Hamiltonian. Let us analyze this behavior:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá_ùê§+ùêÜ ùê∞_nùê§+ùêÜ = E_nùê§+ùêÜ ùê∞_nùê§+ùêÜ \n sum_J h_IJùê§+ùêÜ w_Jnùê§+ùêÜ = E_nùê§ w_Inùê§+ùêÜ \n sum_J e^iùêÜ(ùê™_Œ≤-ùê™_Œ±) h_IJùê§ w_Jnùê§+ùêÜ = E_nùê§ w_Inùê§+ùêÜ \n sum_J h_IJùê§ e^iùêÜùê™_Œ≤ w_Jnùê§+ùêÜ = E_nùê§ e^iùêÜùê™_Œ± w_Inùê§+ùêÜ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, this implies that the eigenvectors gain a phase factor when translated in reciprocal space such that:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"w_Inùê§+ùêÜ = e^-iùêÜùê™_Œ± w_Inùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To make this easier, we can define a diagonal matrix such that Œò_ùêÜ_II = e^-iùêÜùê™_Œ±; then the previous expression can be rewritten as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùê∞_nùê§+ùêÜ = Œò_ùêÜ ùê∞_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this transformation is not a simple phase factor ‚Äî which is indeterminate for eigenvectors; rather, it acts differently on each entry of the eigenvector. This extra factor is crucial when analyzing the invariance of the Bloch states under reciprocal lattice translations, as we will see now.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us deduce how Bloch states will transform under reciprocal lattice translations:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœà_nùê§+ùêÜ = frac1sqrtN sum_Iùê≠ w_Inùê§+ùêÜ e^i(ùê§+ùêÜ)(ùê≠+ùê™_Œ±) ketœï_Iùê≠ \n= frac1sqrtN sum_Iùê≠ cancele^-iùêÜùê™_Œ± w_Inùê§ cancele^iùêÜùê≠ cancele^iùêÜùê™_Œ± e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠ \n= frac1sqrtN sum_Iùê≠ w_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠ = ketœà_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch states remain invariant under reciprocal lattice translations, as they should. This is a a crucial feature which must be upheld, regardless of the basis used for representing the Hamiltonian or the Fourier convention used. We prove that the property also holds for another Fourier convention in Appendix A.","category":"page"},{"location":"theory/#Transformation-properties-under-symmetry-operations-2","page":"Theory","title":"Transformation properties under symmetry operations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here we analyze how the Bloch states transform under more complex symmetry operations g = RùêØ that might involve translations ùêØ and site-symmetry operations R. The Bloch state transforms under these operations as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒù ketœà_nùê§ = sum_I w_Inùê§ ƒù ketœÜ_Iùê§ \n= sum_IJ w_Inùê§ ùêÉ_ùê§(g)_JI ketœÜ_Jgùê§ \n= sum_IJ ùêÉ_ùê§(g)_JI w_Inùê§ ketœÜ_Jgùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We are particularly interested in the transformation under operations ƒù in the little group G_ùê§ of a particular ùê§-point. These operations leave the particular ùê§-point invariant up to a lattice translation, i.e., g ùê§ = ùê§ + ùêÜ. How these functions transform under those operations at each high-symmetry point allows us to assign an irrep to each of the Bloch states at that ùê§-point. Those should coincide with the ones obtained from the original system's band structure. The irrep can be assigned by computing the symmetry eigenvalues associated with each Bloch state. These are computed by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"braketœà_nùê§ƒùœà_nùê§ = sum_IJ (w_Inùê§)^* w_Jnùê§ braketœÜ_Iùê§ƒùœÜ_Jùê§ \n= sum_IJJ (w_Inùê§)^* w_Jnùê§ ùêÉ_ùê§(g)_JJ braketœÜ_Iùê§œÜ_Jgùê§ \n= sum_IJJ (w_Inùê§)^* w_Jnùê§ ùêÉ_ùê§(g)_JJ braketœÜ_Iùê§œÜ_Jùê§+ùêÜ \n= sum_IJJ (w_Inùê§)^* w_Jnùê§ ùêÉ_ùê§(g)_JJ e^iùêÜùê™_Œ≤ braketœÜ_Iùê§œÜ_Jùê§ \n= sum_IJJ (w_Inùê§)^* w_Jnùê§ ùêÉ_ùê§(g)_JJ e^iùêÜùê™_Œ≤ Œ¥_IJ \n= sum_IJ (w_Inùê§)^* e^iùêÜùê™_Œ± ùêÉ_ùê§(g)_IJ w_Jnùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have used how the Bloch functions transform under reciprocal lattice translations ‚Äî a property inherit from the convention choice ‚Äî and their orthogonality.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Acting with representation matrices: to transpose or not to transpose\nA subtly suprising feature may stand out from the above result: unlike previously, the representation matrix ùêÉ_ùê§(g) is acting \"directly\", i.e., untransposed, on the \"state\" w_Jnùê§. Although this may appear to be at odds with the earlier approach of the representation matrix acting via its transpose, it is entirely consistent. The key point is that previously, we defined the representation matrix to act via its transpose on basis vectors (e.g., ketœÜ_Jùê§). However, here, the representation matrix is acting on a coefficient vector.It's easy to see by example that the action on these two different kinds of vectors must be different. In particular, if we define the action of ƒù on a basis ùêØ_i as ƒù ùêØ_i = sum_j D_ji ùêØ_j, then any general vector œà = sum_i c_i ùêØ_i (specified by a basis ùêØ_i and a corresponding set of expansion coefficients c_i) must transform as:ƒù œà\n= ƒù sum_i c_i ùêØ_i\n=  sum_i c_i ƒù ùêØ_i \n=  sum_ij c_i D_ji ùêØ_jThe latter expression can be interpreted equivalently as eitherùêú^T ùêÉ^T ùêØ\n: i.e., ùêÉ acting transposed on the \"vector of basis vectors\" ùêØ = ùêØ_1 ùêØ_2 , or as \nùêÉ ùêú^T ùêØ\n: i.e., ùêÉ acting un-transposed on the coefficient vector ùêú = c_1 c_2 .I.e., the general rule is that the representation matrix acts transposed on basis vectors, and untransposed on coefficient vectors.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this expression has a phase factor that cannot be omitted. In Convention 2 this phase factor does not appear, producing an arguably simlper expression. Nevertheless, we stick to the current convention due to the property of the ùê§-dependence in the representation matrices of symmetry operations. However, it is interesting to be able to change from one convention to others. Because of that, we include some functions in the package to be able to change from one convention to another one ‚Äî heavily used in the literature. The relation between these two conventions can be found in Appendix A.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This expression for braketœà_nùê§ƒùœà_nùê§ = sum_IJ (w_Inùê§)^* w_Jnùê§ braketœÜ_Iùê§ƒùœÜ_Jùê§ can be rewritten in a vectorized form, convenient for implementation. To do so, we make use of the previously introduced phase-factor diagonal matrix Œò_ùê§, allowing:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"boxedbraketœà_nùê§ƒùœà_nùê§ = (Œò_ùêÜ ùê∞_nùê§)^ (ùêÉ_ùê§(g) ùê∞_nùê§)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Note that the Œò_ùêÜ_II = e^-iùêÜùê™_Œ±  matrix has been placed in the conjugated part of the dot product, reflecting the minus sign in its definition.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We have now developed the theory needed to explore the most important parts of the package. However, we have not tickle one important point: the package is implemented in Julia, a non-symbolic language. Then, it is not straightforward to encode the previous formulas and relations in order to obtain the model.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In the following section, we are going to present the strategy we have followed to surpass this apparent issue. The main idea will be based in storing the different nits of information in different structures which we can use to perform all relation and constraints.","category":"page"},{"location":"theory/#Implementing-Symbolic-Hamiltonians-in-Non-Symbolic-Environments","page":"Theory","title":"Implementing Symbolic Hamiltonians in Non-Symbolic Environments","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In this section we aim to introduce our strategy to encode the symbolic structures and formulas we have presented in a non-symbolic environments, such as Julia.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us consider a term in a general Hamiltonian which describes the hopping term between two EBRs. For the sake of simplicity let us call them Œ± (ùê™A) and Œ≤ (ùê∞B), where ùê™ and ùê∞ represent two certain WP in the SG and A and B are two site-symmetry irreps of any dimension.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the sake of notation, we will denote each point in the WPs and each term in the site-symmetry irreps in a similar fashion:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùê™ q_1 q_2  q_N \nùê∞ w_1 w_2  w_M \nA A_1 A_2  A_J \nB B_1 B_2  B_K","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As we have discussed previously, in reciprocal space the Hamiltonian term involving those EBRs, ùêá_ùê§ can be written as a matrix where each row denote an orbital from the \"arriving\" EBR and the column an orbital from the \"departing\" EBR. Each of its components will be a complex number which depend on the vector ùê§ and on some free-parameters that later on we will adjust to obtain the band structure.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In order to encode such Hamiltonian term, we will need to do some previous steps.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The first step we need to do is to list all the possible hopping distances that can be found between this two EBRs. Obviously, that set will be infinite so we need to impose a particular cutoff. As explained above, we will impose it by constraining the hopping terms to a particular set of lattice translations ‚Äî and obviously theirs symmetry partners. This complex structure is computed in the function obtain_symmetry_related_hoppings, where we provide a set of representatives of hopping distances which which is associated to a set of hopping terms that are symmetry related.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Inside of one of this representatives we will find different hopping distances Œ¥s = Œ¥_1 Œ¥_2  Œ¥_n, which will be associated to different hopping terms:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Œ¥_1 q_i  w_j + G_k q_l  w_l + G_n  \nŒ¥_2 q_o  w_p + G_r q_s  w_t + G_z  \nvdots","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where G_k are some particular lattice translations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"With this information we are able to numerically codify the Hamiltonian matrix by terms, as we will show in the following.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As we showed above, the phases in the Bloch Hamiltonian can be computed from this hopping vectors. First, we use them to create an abstract vector ùêØ which will store the phases that will appear in the Hamiltonian's term in reciprocal space. Being specific, this vector would like:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêØ^T = e^iùê§Œ¥_1 e^iùê§Œ¥_2  e^iùê§Œ¥_n","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Note that we are going to use here the order provided by the function obtain_symmetry_related_hoppings to store this phases.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Additionally, we will need to assign a free-parameter to each orbital hopping term in the Hamiltonian matrix ‚Äî the ones that afterwards we will tune to replicate the band structure. This vector then will have a length of textlen(Œ¥s)   ùê™   ùê∞  textdim(A)  textdim(B). In particular this vector will look like this:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùê≠^T = t(Œ¥_1)  t(Œ¥_i)  t(Œ¥_n)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where each t(Œ¥_i) represent a collection of free-parameter, one per hopping term inside the hopping distance Œ¥_i.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that, the ordering of ùê≠ is a bit subtle: ùê≠ is a kind of vector-flattened        tensor ùêì, with the following \"indexing convention\" for ùêì:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The elements ùêìi give a vector of hoppings corresponding to the i-th orbit Œ¥_i. \nThe elements Tij give a vector of hoppings corresponding to the j-th possible spatial hopping with displacement Œ¥·µ¢. This describes hoppings from site an \"origin\" q_r to a \"destination\" w_p + ùêÜ (where G is a lattice translation).\nFinally, ùêìijkm is a single hopping term from the k-th partner function of q_r site to the m-th partner function of w_p site.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If we are considering a diagonal block, i.e., (ùê™A) = (ùê∞B), then we also have to include the hermitian or anti-hermitian counterparts of each hopping term, i.e., for each hopping term from q_r to w_p + ùêÜ, we also have to include the hopping term from w_p to q_r - ùêÜ.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, each term of the Hamiltonian matrix ùêá_ùê§ can be written as bilinear form in the following way:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá_ùê§_ij = ùêØ_ùê§^T ùêå_ij ùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where ùêå_ij is a numerical matrix that will relate a phase with a free-parameter present on the Hamiltonian matrix term.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We will, then, work with a set of matrices  ùêå_ij _ij, each associated to a pair of EBRs, that will encode the tight-binding Hamiltonian and will allow us to operate with it.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In the following section, we will show how symmetry operations acts on this set of matrices and how to obtain the constraints they impose on the tight-binding Hamiltonian.","category":"page"},{"location":"theory/#Symmetry-constraints-in-the-numerical-matrix-ùêå","page":"Theory","title":"Symmetry constraints in the numerical matrix ùêå","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now we want to deduce how transformations on the Hamiltonian matrix ùêá_ùê§ translate into the set of numerical tensor ùêå_ij.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We will start from the condition imposed into the Hamiltonian term:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá_gùó∏ = ùêÉ_ùê§^Œ±(g) ùêá_ùó∏ ùêÉ_ùê§^Œ≤(g)^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where Œ± and Œ≤ indicates the EBRs involved in the Hamiltonian term.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then,","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùòÉ_gùó∏^T ùêå_ij ùòÅ = ùêÉ_ùê§^Œ±(g) ùòÉ_ùó∏^T ùêå_ij ùòÅ ùêÉ_ùê§^Œ≤(g)^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since the representation matrices act on different indices as ùòÉ and ùòÅ, we can permute them obtaining:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùòÉ^T_gùó∏ ùêå_ij ùòÅ = ùòÉ^T_ùó∏ ùêÉ_ùê§ir^Œ±(g) ùêå_rs ùêÉ_ùê§sj^Œ≤(g)^ ùòÅ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In order to compare both ùêå_ij matrices, we need to analyze what is ùòÉ_gùó∏. As can be seeing above, the ùòÉ_ùê§ vector is constructed as: ùòÉ^T_ùó∏ = e^iùó∏Œ¥‚ÇÅ e^iùó∏Œ¥‚ÇÇ  e^iùó∏Œ¥_n, where  Œ¥_i  is a closed orbit. Then, ùòÉ^T_gùó∏ = e^i(gùó∏)Œ¥‚ÇÅ e^i(gùó∏)Œ¥‚ÇÇ  e^i(gùó∏)Œ¥_n. As discussed above, we defined as (gùó∏)ùóø  (R^-1^T ùó∏)ùóø = ùê§  (R^-1 ùê´), where g =  RœÑ , then: ùòÉ^T_gùó∏ = e^iùó∏(R¬πŒ¥‚ÇÅ) e^iùó∏(R¬πŒ¥‚ÇÇ)  e^iùó∏(R¬πŒ¥_n). Additionally, since  Œ¥_i  is a closed orbit, ùòÉ_gùó∏ will be just a permutation of ùòÉ_ùó∏, in other words, ùòÉ_gùó∏ = œÉ(g) ùòÉ_ùó∏, with œÉ(g) a particular permutation. This permutation is obtained in _permute_symmetry_related_hoppings_under_symmetry_operation, allowing us to operate on the numerical tensor ùêå_ij as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(œÉ(g) ùòÉ_ùó∏)^T ùêå_ij ùòÅ = ùòÉ^T_ùó∏ ùêÉ_ùê§ir^Œ±(g) ùêå_rs ùêÉ_ùê§sj^Œ≤(g)^ ùòÅ \nùòÉ^T_ùó∏ œÉ(g)^T ùêå_ij ùòÅ = ùòÉ^T_ùó∏ ùêÉ_ùê§ir^Œ±(g) ùêå_rs ùêÉ_ùê§sj^Œ≤(g)^ ùòÅ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, performing some algebra we obtain that:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùòÉ^T_ùó∏ left( œÉ(g)^T ùêå_ij - ùêÉ_ùê§ir^Œ±(g) ùêå_rs ùêÉ_ùê§sj^Œ≤(g)^ right) ùòÅ = 0 \n boxedleft( œÉ(g)^T ùêå_ij - ùêÉ_ùê§ir^Œ±(g) ùêå_rs ùêÉ_ùê§sj^Œ≤(g)^ right) ùòÅ = 0","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This implies that if we compute the null-space of the previous subtraction, we will obtain a set of free-parameter vectors that will fulfill the constrains imposed by unitary operations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this set of vectors will be, in general, complex vector, since the matrices involved will have complex entries. Additionally, if ùê≠ is a possible solution to the nullspace, then iùê≠ will also be. Then, in order to avoid compilations, we will split our free-parameter vector ùòÅ into its real and imaginary part, so we can work only with real vector, and also add an extra possible solution which will be iùê≠, so we can assume that the parameter are always real. This is performed in split_complex. For now on, every ùê≠ can be though as a \"double vector\" such as: ùòÅ = ùòÅ_textreal i ùòÅ_textimag, and the matrices ùêå_ij as a \"double matrix\" like ùêå_ij ùêå_ij. Then, each element of the Hamiltonian matrix will be represented as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá_ùê§_ij = ùêØ_ùê§^T ùêå_ij ùêå_ij ùòÅ_textreal i ùòÅ_textimag","category":"page"},{"location":"theory/#Time-reversal-constraint-in-the-numerical-matrix-ùêå","page":"Theory","title":"Time reversal constraint in the numerical matrix ùêå","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We star again from the condition imposed into the Hamiltonian matrix:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá_-ùê§ = ùêá_ùê§^*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If we represent each element of each side by the numerical matrix:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá_-ùê§_ij = ùêØ·µÄ_-ùê§ ùêå·µ¢‚±º ùêå·µ¢‚±º ùê≠_textreal iùê≠_textimag","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá_ùê§^*_ij = (ùêØ_ùê§^*)·µÄ ùêå·µ¢‚±º ùêå·µ¢‚±º ùê≠_textreal -iùê≠_textimag \n= (ùêØ_ùê§^*)·µÄ ùêå·µ¢‚±º -ùêå·µ¢‚±º ùê≠_textreal iùê≠_textimag \n= ùêØ·µÄ_-ùê§ ùêå·µ¢‚±º -ùêå·µ¢‚±º ùê≠_textreal iùê≠_textimag","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have used the property that ùêØ_ùê§^* = ùêØ_-ùê§.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, the constraint reduces to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêØ·µÄ_-ùê§ ùêå·µ¢‚±º ùêå·µ¢‚±º ùê≠_textreal iùê≠_textimag = ùêØ·µÄ_-ùê§ ùêå·µ¢‚±º -ùêå·µ¢‚±º ùê≠_textreal iùê≠_textimag \n ùêØ·µÄ_-ùê§ 0 ùêå·µ¢‚±º ùê≠_textreal iùê≠_textimag = 0 \n boxed0 ùêå·µ¢‚±º ùê≠_textreal iùê≠_textimag = 0","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This implies that the action of time reversal symmetry using our implementation will just reduce to the condition that free-parameters must be real.","category":"page"},{"location":"theory/#Appendix-A","page":"Theory","title":"Appendix A","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In this appendix we aim to present, develop and compare two of the main conventions present on the literature for Fourier transforms. The two Fourier transform conventions we are going to analyze are:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Convention 1: œÜ^(1)_Iùê§(ùê´)  sum_ùê≠ e^iùê§(ùê≠+ùê™_Œ±) œï_I(ùê´-ùê≠)\nConvention 2: œÜ^(2)_Iùê§(ùê´)  sum_ùê≠ e^iùê§ùê≠ œï_I(ùê´-ùê≠)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where Convention 1 is the one we have been using in the theory notes and Convention 2 is another one commonly used in the literature and other packages such as Bradlyn et al.. This second convention does not includes the position of the orbital ùê™_Œ± in the phase factor of the Fourier transform.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The former is the one used in the PythTB package, where they claim it to be more suitable for computing topological invariants as Berry phases or Wilson loops. The later is more common in the literature since it is not necessary to trace back the extra phase factor. Additionally, as we will see later, the later makes easier to compute the symmetry eigenvalues.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The arguments of which one is better than the other are out of the scope of this notes, so we are going to focus on developing both of them and pointing out their main differences. The package uses ‚Äî for now ‚Äî Convention 1, since it is more suitable for accounting on the ùê§-dependence, but it also provide several tools to convert its outcome into Convention 2.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Firstly, we are going to do a similar analysis to the previous one in Convention 1, but now on Convention 2. We are going to analyze the transformation properties of the Bloch functions induced from the orbitals, the effect of this choice on the representation of the Bloch Hamiltonian and its Bloch states. Secondly, we are going to point out the main differences and similarities between both conventions. We aim to point out in which situations one more suitable than the other and when it is irrelevant. Finally, we are going to cover the conversion rules to change to one another ‚Äî which are the ones we implement in this package.","category":"page"},{"location":"theory/#Transformation-properties-within-Convention-2","page":"Theory","title":"Transformation properties within Convention 2","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Firstly, we are going to prove the previous statement: Convention 2 is periodic in reciprocal space, on the contrary, to Convention 1. Let us deduce how a reciprocal lattice translation ùêÜ acts on the Bloch functions under Convention 2:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÜ^(2)_Iùê§+ùêÜ = sum_ùê≠ e^i(ùê§+ùêÜ)ùê≠ œï_I(ùê´-ùê≠) \n= sum_ùê≠ cancele^iùêÜùê≠ e^iùê§ùê≠ œï_I(ùê´-ùê≠) \n= œÜ^(2)_Iùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This implies that the Bloch functions are periodic under reciprocal lattice translations within this convention. This has interesting implications in the computation of some parts of this package, such as, the representation of symmetry operations or symmetry eigenvalues. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, let us reproduce the transformation properties of the Bloch functions under symmetry operations g =  RùêØ  of the space group under Convention 2. Following a similar approach to the one previously developed:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g œÜ^(2)_Iùê§(ùê´) = frac1sqrtN sum_ùê≠ e^iùê§ùê≠ g œï_I(ùê´-ùê≠) \n= frac1sqrtN sum_ùê≠J e^iùê§ùê≠ œÅ(h)_JI œï_J(ùê´-Rùê≠-ùê≠_Œ≤Œ±) \n= frac1sqrtN sum_ùê≠J e^iùê§R^-1(ùê≠-ùê≠_Œ≤Œ±) œÅ(h)_JI œï_J(ùê´-ùê≠) \n= e^-i(g ùê§)ùê≠_Œ≤Œ± sum_J œÅ(h)_JI frac1sqrtN sum_ùê≠ e^i(g ùê§)ùê≠ œï_J(ùê´-ùê≠) \n= e^-i(g ùê§)ùê≠_Œ≤Œ± sum_J œÅ(h)_JI œÜ^(2)_Jg ùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we made the substitution ùê≠ = Rùê≠ + ùê≠_Œ≤Œ±, and used the definition stated before: gùê§  R^-1^T ùê§.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Similarly as before, we can define a representation matrix ùêÉ^(2)_ùê§(g) whose entries are ùêÉ^(2)_ùê§(g)_IJ = e^-i(gùê§)ùê≠_Œ≤Œ± œÅ(h)_IJ, where I = (iŒ±) and J = (jŒ≤). Then, the previous expression reduces to:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g œÜ^(2)_Iùê§(ùê´) = sum_j ùêÉ^(2)_ùê§(g)_JI œÜ^(2)_jŒ≤gùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that the representation matrix for the space group operations differs between conventions, i.e., ùêÉ^(1)_ùê§(g)  ùêÉ^(2)_ùê§(g). The representation under Convention 1 depends on the translational part ùêØ, as shown before, meanwhile, under Convention 2, it presents not on a global phase factor, but on a local phase factor depending on ùê≠_Œ≤Œ±.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The next step will be to build a tight-binding model using this set of functions as a basis. For that, in the following section, we will follow the same steps as in Convention 1 by introducing the creation and annihilation operators associated to such functions, and how the Bloch Hamiltonian will look like.","category":"page"},{"location":"theory/#Bloch-Hamiltonian-under-Convention-2","page":"Theory","title":"Bloch Hamiltonian under Convention 2","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We want to use the previously introduced Bloch functions as a basis to construct a Bloch Hamiltonian in reciprocal space. Once again, we start from the most general tight-binding Hamiltonian, which, as we described, can be written as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùêëùê≠ h_IJùêë ƒâ^_Iùê≠+ùêë ƒâ_Jùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since we want to use the previous Bloch functions as a basis, we have to introduce a set of creation and annihilation operators that are consistent with the convention choice ‚Äî Convention 2 in this case. This is satisfied by the following relation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatb_Iùê§^ = frac1sqrtN sum_ùê≠ e^iùê§ùê≠ ƒâ_Iùê≠^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have used hatb as the notation for the operators under this new convention. It is interesting to notice that you can obtain one from the other by using the following relation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatb_Iùê§^ = e^-iùê§ùê™_Œ± √¢_Iùê§^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Introducing the previous transformation into the tight-binding Hamiltonian we obtain that:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùêëùê§ h_IJùêë e^iùê§ùêë hatb_Iùê§^ hatb_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"If we define h^(2)_IJùê§ = sum_ùêë h_IJùêë e^iùê§ùêë, we obtain the usual expression for a tight-binding Hamiltonian in reciprocal space:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§ = sum_IJùê§ h^(2)_IJùê§ hatb_Iùê§^ hatb_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"From here, we can define the Bloch Hamiltonian which will be the diagonal part of the Hamiltonian in reciprocal space, i.e.:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§ = sum_IJ h^(2)_IJùê§ hatb_Iùê§^ hatb_Jùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Considering that now the Bloch functions are periodic it is easier to prove that the Bloch Hamiltonian is periodic also, but, nevertheless, we are going to prove it. Firstly, let us examine how the creation operator transform under a reciprocal lattice translation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatb_Iùê§+ùêÜ^ = frac1sqrtN sum_ùê≠ e^i(ùê§+ùêÜ)ùê≠ ƒâ_Iùê≠^ \n= frac1sqrtN sum_ùê≠ cancele^iùêÜùê≠ e^iùê§ùê≠ ƒâ_Iùê≠^ \n= hatb_Iùê§^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, let us study how the coefficients transform under a reciprocal lattice translation:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"h^(2)_IJùê§+ùêÜ = sum_ùêë h_IJùêë e^i(ùê§+ùêÜ)ùêë \n= sum_ùêë h_IJùêë cancele^iùêÜùêë e^iùê§ùêë \n= h^(2)_IJùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As can be seen, all the components are periodic within this convention. This is the common reason why it is heavily used in the literature. Proving now the translational invariance of the Bloch Hamiltonian:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§+ùêÜ = sum_IJ h^(2)_IJùê§+ùêÜ hatb_Iùê§+ùêÜ^ hatb_Jùê§+ùêÜ \n= sum_IJ h^(2)_IJùê§ hatb_Iùê§^ hatb_Jùê§ = ƒ§_ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This is an important property since the eigenvalues of this Bloch Hamiltonian, which correspond to the energies of the Bloch states of the system, must be periodic in reciprocal space, allowing us to restrict to the first Brillouin zone. Additionally, since the representation matrix ùêá^(2)_ùê§ is now periodic by itself, the eigenvectors ùê∞^(2)_nùê§ will also be periodic. This has important implications, for example, when computing the symmetry eigenvalues.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Before studying the transformation properties of the Bloch states, we want to mention that the creation and annihilation operators and the Bloch Hamiltonian within this convention will have the same transformation properties under symmetry operations but now using the representation matrix of the operations ùêÉ^(2)_ùê§ associated to Convention 2.","category":"page"},{"location":"theory/#Bloch-states-under-Convention-2","page":"Theory","title":"Bloch states under Convention 2","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us now jump into the transformation properties of the Bloch states. The Bloch states are represented using the basis obtained by Convention 2 as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœà_nùê§ = sum_I w^(2)_Inùê§ ketœÜ^(2)_Iùê§ = frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§(ùê≠+ùê™_Œ±) ketœï_Iùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us first study how the Bloch states transform under lattice translations in real and reciprocal space and, then, deduce how they transform under more complex symmetry operations.","category":"page"},{"location":"theory/#Transformation-under-lattice-translations","page":"Theory","title":"Transformation under lattice translations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Firstly, we are going to consider lattice translations in real space. This can be obtained by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œà_nùê§(ùê´+ùêë) = braketùê´+ùêëœà_nùê§ \n= frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§ùê≠ braketùê´+ùêëœï_nùê≠ \n= frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§ùê≠ braketùê´œï_nùê≠-ùêë \n= e^iùê§ùêë frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§(ùê≠-ùêë) braketùê´œï_nùê≠-ùêë \n= e^iùê§ùêë braketùê´œà_nùê§ = e^iùê§ùêë œà_nùê§(ùê´)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch states transform as Bloch functions under translations in real space, as expected.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Secondly, let us analyze how they transform under reciprocal lattice translations. Remind that the matrix representation ùêá^(2)_ùê§ is periodic under reciprocal lattice translations. This implies that ùê∞^(2)_nùê§+ùêÜ = ùê∞^(2)_nùê§, and E_nùê§+ùêÜ = E_nùê§, i.e., they are periodic under reciprocal lattice translations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Let us deduce how Bloch states will transform under reciprocal lattice translations:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœà_nùê§+ùêÜ = frac1sqrtN sum_Iùê≠ w^(2)_Inùê§+ùêÜ e^i(ùê§+ùêÜ)ùê≠ ketœï_Iùê≠ \n= frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ cancele^iùêÜùê≠ e^iùê§ùê≠ ketœï_Iùê≠ \n= frac1sqrtN sum_Iùê≠ w^(2)_Inùê§ e^iùê§ùê≠ ketœï_Iùê≠ = ketœà_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The Bloch states will remain invariant under reciprocal lattice translations, as it should be.","category":"page"},{"location":"theory/#Transformation-properties-under-symmetry-operations-3","page":"Theory","title":"Transformation properties under symmetry operations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here we analyze how the Bloch states transform under more complex symmetry operations g = RùêØ that might involve translations ùêØ and site-symmetry operations R. The Bloch state will transform under this operations as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒù ketœà_nùê§ = sum_I w^(2)_Inùê§ ƒù ketœÜ^(2)_Iùê§ \n= sum_IJ w^(2)_Inùê§ ùêÉ^(2)_ùê§(g)_JI ketœÜ^(2)_Jgùê§ \n= sum_IJ ùêÉ^(2)_ùê§(g)_JI w^(2)_Inùê§ ketœÜ^(2)_Jgùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We are particularly interested in the transformation under operations ƒù in the little-group G_ùê§ of a particular ùê§-point. This operations will leave invariant the particular ùê§-point up to a lattice translation, i.e., g ùê§ = ùê§ + ùêÜ. How these functions transform under those operation at each high-symmetry point will allow us to assign an irrep to each of the Bloch states at that ùê§-point. Those should coincide with the ones obtained from the original system's band structure. The irrep could be assigned by computing the symmetry eigenvalues associated to each Bloch state. Those are compute by:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"braketœà_nùê§ƒùœà_nùê§ = sum_IJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ braketœÜ^(2)_Iùê§ƒùœÜ^(2)_Jùê§ \n= sum_IJJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ ùêÉ^(2)_ùê§(g)_JJ braketœÜ^(2)_Iùê§œÜ^(2)_Jgùê§ \n= sum_IJJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ ùêÉ^(2)_ùê§(g)_JJ braketœÜ^(2)_Iùê§œÜ^(2)_Jùê§+ùêÜ \n= sum_IJJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ ùêÉ^(2)_ùê§(g)_JJ braketœÜ^(2)_Iùê§œÜ^(2)_Jùê§ \n= sum_IJJ (w^(2)_Inùê§)^* w^(2)_Jnùê§ ùêÉ^(2)_ùê§(g)_JJ Œ¥_IJ \n= sum_IJ (w^(2)_Inùê§)^* ùêÉ^(2)_ùê§(g)_IJ w^(2)_Jnùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that this expression differs from the previous one due to a phase factor. This is the main reason why some authors decided to use Convention 2 instead Convention 1: it is not necessary to account for phase factors in the symmetry eigenvalues computations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Nevertheless, it is interesting to be able to consider both conventions and that is why, in the next section, we develop conversion properties between the two conventions for several convention-dependent expressions.","category":"page"},{"location":"theory/#Conversions-between-Convention-1-and-2","page":"Theory","title":"Conversions between Convention 1 and 2","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"First, let us start with the conversion between the Bloch functions that the different Fourier transformations induce. Since there is just an additional phase factor, we can convert from one convention to the other by adding that extra factor as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ketœÜ^(2)_Iùê§ = e^-iùê§ùê™_Œ± ketœÜ^(1)_Iùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Obviously, the creation and annihilation operators convert in a similar fashion; in particular, as stated previously:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatb_Iùê§^ = e^-iùê§ùê™_Œ± √¢_Iùê§^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Second, the Hamiltonian must be invariant independently of the basis used to define it. Considering this, we can deduce how the matrix ùêá_ùê§, which is representation dependent, converts from one convention to the other. Let us start with the Bloch Hamiltonian:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ§_ùê§ = sum_IJ h^(1)_IJùê§ √¢_Iùê§^ √¢_Jùê§ \n= sum_IJ e^iùê§ùê™_Œ± h^(1)_IJùê§ e^-iùê§ùê™_Œ≤ hatb_Iùê§^ hatb_Jùê§ \n h^(2)_IJùê§ = e^iùê§ùê™_Œ± h^(1)_IJùê§ e^-iùê§ùê™_Œ≤","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This allows us to convert from one representation matrix of the Hamiltonian to the other. It is convenient to rewrite the previous relation in matrix form, which is:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùêá^(2)_ùê§ = Œò^_ùê§ ùêá^(1)_ùê§ Œò_ùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where Œò_ùê§ is a diagonal matrix containing the phase factor as defined previously: Œò_ùê§_II = e^-iùê§ùê™_Œ±. This relation allows us to transform from one representation of the Bloch Hamiltonian into the other.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Finally, we are interested in deducing the conversion properties of the eigenvectors obtained from diagonalizing the representation matrix ùêá_ùê§. Since ùêá^(1)_ùê§ and ùêá^(2)_ùê§ are related by a change of basis, the eigenvectors of both can be related to each other as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ùê∞^(2)_nùê§ = Œò^_ùê§ ùê∞^(1)_nùê§","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"With these relations we are able to go back and forth from one convention to the other, making it possible to use both depending on which is most suitable for each case.","category":"page"},{"location":"theory/#Appendix-B","page":"Theory","title":"Appendix B","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In this appendix we want to show how to build a explicitly real representation for the symmetry operations. If this is true, we can always pick a real basis that transform as the explicitly real representation, i.e.:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"ƒ• ketœï_Iùê≠ = œÅ(h) ketœï_Iùê≠ quad hatùíØ ketœï_Iùê≠ = ketœï_Iùê≠","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"An explicit real, or physically real, form of a set of irrep matrices is one  where the associated matrices œÅ(h) have the following property:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"œÅ(h) = œÅ^*(h)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"for all operations h in the considered site-symmetry group H of the position of the orbital.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The standard listings of irreps is not explicitly real. However, if an irrep is  either intrinsically real ‚Äî or has been made into a corep in the complex or  pseudoreal case ‚Äî it is always equivalent to an intrinsically real form. That is, there exists a unitary transform S such that:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"S œÅ(h) S^-1 = S œÅ(h) S^ = œÅ^*(h)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Suppose we can find this unitary transformation S by some means. What we are  interested in, is finding a related transform W, defining an explicitly real  form of the irrep:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"tildeœÅ(g) = W œÅ(h) W^-1 = W œÅ(h) W^","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where W is some other unitary transformation and where tildeœÅ(h) is an  intrinsically real form of œÅ(h), i.e., where","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"tildeœÅ(h) = tildeœÅ^*(h) quad forall h  H","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Our aim is to find W, assuming we know S. First, note that S is not merely a unitary matrix: rather, since, by assumption œÅ(h) is a \"real\" matrix, what we really mean is that S is also a symmetric unitary matrix, i.e., S = S^mathrmT and S^-1 = S^ (implying, jointly, S^* = S^ = S^-1); this is e.g., derived in Inui p. 74 (bottom) to 75 (top). Accordingly S is also normal, i.e., S S^* = S^* S.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This property in turn implies that we can express S as the square of another  symmetric unitary matrix, say W, in the sense that S = W^2. This follows from the following manipulations (Inui, p. 75 bottom), involving the eigendecomposition S = V Œõ V^-1 where Œõ is a diagonal matrix with unit-modulus values and V are a set of real eigenvectors (real because S is symmetric unitary) and V^-1 = V^ = V^mathrmT (since S is normal).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"S = VŒõV^-1 = VŒõ^12Œõ^12V^mathrmT = (VŒõ^12V^mathrmT)\n(VŒõ^12V^mathrmT)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"so we can pick W = VŒõ^12V^mathrmT (note also that the square root of  Œõ must exist and is well-defined since S is invertible, i.e., has full  rank). Hence W^* = V(Œõ^12)^*V^mathrmT = VŒõ^-12V^mathrmT = W^-1 and W^mathrmT = (VŒõ^12V^mathrmT)^mathrmT = (V^mathrmT)^mathrmT(Œõ^12)^mathrmT V^mathrmT = VŒõ^12V^mathrmT = W. I.e., W is also unitary symmetric and normal.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Now, let us rewrite S œÅ(h) S^-1 = œÅ^*(h) in terms of W:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"WW œÅ(h) W^-1W^-1 = œÅ(h)^* ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Multiply from LHS by W^* and from RHS by W:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"W^*WW œÅ(h) W^-1W^-1 W = W^*œÅ(h)^* W \nLeftrightarrow W œÅ(h) W^-1 = W^*œÅ(h)^* W \nLeftrightarrow W œÅ(h) W^-1 = W^* œÅ(h)^* (W^-1)^*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we have used the properties of W to reduce the expressions. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Identifying tildeœÅ(h) = W œÅ(h) W^-1 we clearly obtain the desired  invariance under complex conjugation since tildeœÅ^*(h) = (W œÅ(h) W^-1)^* = W^* œÅ(h)^* (W^-1)^* = W œÅ(h) W^-1 = tildeœÅ(h).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, whe using a explicitly real representation we can assume our basis functions are also real and the previous property under time reversal holds. This \"realification\" of the representations is performed inside the package Crystalline.jl when we ask for a band representation with time reversal symmetry enforced.","category":"page"},{"location":"band-symmetry/#Band-symmetry-and-topology","page":"Band symmetry","title":"Band symmetry and topology","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Since the theory behind SymmetricTightBinding.jl is anchored in symmetry analysis, the package naturally provides several tools to analyze band symmetry, as well as to use this information to apply the frameworks of topological quantum chemistry and symmetry indicators to analyze band topology.","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"To explore these tools, we first re-build the graphene model previously explored in the tutorial section, instantiating the variables tbm (model), ptbm (coefficient-parameterized model), kpi (interpolated k-path, via Brillouin.jl), and Es (band structure of ptbm, evaluated over kpi).","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"details: Setup details\nusing Crystalline, SymmetricTightBinding\nusing Brillouin, GLMakie           # for k-space path and plotting\nsgnum = 17                         # plane group p6mm\nbrs = calc_bandreps(sgnum, Val(2)) # band representations\ncbr = @composite brs[5]            # (2b|A‚ÇÅ) EBR\ntbm = tb_hamiltonian(cbr)          # tight-binding model (nearest neigbors)\nptbm = tbm([0, 1])                 # zero self-energy, nonzero nearest-neighbor hopping\nRs = directbasis(sgnum, Val(2))    # (conventional) direct lattice basis\nkp = irrfbz_path(sgnum, Rs)        # high-symmetry k-path\nkpi = interpolate(kp, 100)         # interpolated k-path\nEs = spectrum(ptbm, kpi)           # band structure over `kpi`\nnothing # hide","category":"page"},{"location":"band-symmetry/#Annotating-little-group-irrep-labels","page":"Band symmetry","title":"Annotating little group irrep labels","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"To annotate a band structure plot with the little group irrep labels at high-symmetry k-points, we can use collect_irrep_annotations in combination with the annotations keyword argument of the Makie plot extension:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"plot(kpi, Es; annotations = collect_irrep_annotations(ptbm))","category":"page"},{"location":"band-symmetry/#Collecting-compatibility-respecting-band-groups","page":"Band symmetry","title":"Collecting compatibility respecting band groups","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Similarly, we can analyze the compatibility respecting bands contained in ptbm via collect_compatible:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"collect_compatible(ptbm)","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"collect_compatible returns a list of symmetry vectors, from lowest-energy band grouping to highest, each aggregating the symmetry content of a minimal set of compatibility-respecting bands. Here, since our model contains only a single band representation ‚Äì which is additionally an intrinsically connected one ‚Äì such a list can have only one possible element: the only possible band groupings is the original band representation. We can verify this by comparing with the symmetry vector of the band representation used to build tbm:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"SymmetryVector(CompositeBandRep(ptbm))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can set up a more interesting situation by incorporating more band representations (i.e., more orbitals) into our model. E.g., below, we add three s-like orbitals placed at the 3c Wyckoff position (edges of the hexagonal unit cell; i.e., a kagome-like lattice) to the usual graphene model. First, we look at a situation without hybridization and with the bands of the two orbitals sets overlapping:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"cbr‚Ä≤ = @composite brs[3] + brs[5] # (2a|A‚ÇÅ) + (3c|B‚ÇÇ)\ntbm‚Ä≤ = tb_hamiltonian(cbr‚Ä≤)\nptbm‚Ä≤ = tbm‚Ä≤([2.5, 0, 0.2, 0, -1, 0])\nplot(kpi, spectrum(ptbm‚Ä≤, kpi); annotations = collect_irrep_annotations(ptbm‚Ä≤))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Next, we turn on hybridization (controlled by the fifth term of tbm‚Ä≤):","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"ptbm‚Ä≤‚Ä≤ = tbm‚Ä≤([2.5, 0, 0.2, 0, -1, .5])\nplot(kpi, spectrum(ptbm‚Ä≤‚Ä≤, kpi); annotations = collect_irrep_annotations(ptbm‚Ä≤‚Ä≤))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can verify that neither of the band groupings in the hybridized band structure have the same content as either of the underlying band representations. In particular, the band symmetry content of the underlying band representations is:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"SymmetryVector.([brs[3], brs[5]])","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"We can compare this against the band symmetry content of each of the hybridized bands is obtained from collect_compatible (using a compatibility analysis that involves only the high-symmetry k-points):","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"ns = collect_compatible(ptbm‚Ä≤‚Ä≤)","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"In the hybridized model above, the symmetry content of each band grouping differs from any of the original band representations used to build the model: in particular, the assignment of the Œì‚ÇÉ and Œì‚ÇÜ irreps and the M‚ÇÇ and M‚ÇÑ irreps are inverted.","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"details: Recovering an EBR decomposition\nThe new bands can still be interpreted as induced by band representations: the lowest bands correspond to (1aE‚ÇÅ) + (1aA‚ÇÅ), or brs[end]+brs[end-5], while the upper bands are topologically fragile with a possible decomposition of the form (2bA‚ÇÅ) + (1aB‚ÇÇ) + (1aE‚ÇÇ) - (3cA‚ÇÅ), or brs[5] + brs[end-3] + brs[end-1] - brs[1]. These expansions can be obtained using SymmetryBases.jl's decompose function.","category":"page"},{"location":"band-symmetry/#Band-topology","page":"Band symmetry","title":"Band topology","text":"","category":"section"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"Using the extracted symmetry vectors, we can compute the associated symmetry-diagnosable band topology of each band grouping. We can obtain e.g., a coarse topological diagnosis of TRIVIAL (encompassing both trivial and fragile phases) and NONTRIVIAL using Crystalline.jl's calc_topology:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"calc_topology.(ns, Ref(brs))","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"I.e., in this example, both band representations are either a trivial or a fragile phase. To resolve this distinction, we can use SymmetryBases.jl's calc_detailed_topology:","category":"page"},{"location":"band-symmetry/","page":"Band symmetry","title":"Band symmetry","text":"using SymmetryBases\ncalc_detailed_topology.(ns, Ref(brs))","category":"page"},{"location":"#SymmetricTightBinding.jl","page":"Home","title":"SymmetricTightBinding.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymmetricTightBinding.jl provides tools for the construction and manipulation of tight-binding models. The main novelty ‚Äì and principal strength ‚Äì of the package is that every such model is associated with, and specified by, a set of band representations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Put more simply, SymmetricTightBinding.jl will automatically generate all possible tight-binding Hamiltonians that are compatible with a global (space group) symmetry, as well as a selection of orbitals with specified local symmetries (i.e., transforming as specific site symmetry irreps), each situated at specified positions in the unit cell (i.e., at specific Wyckoff positions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying physics is that the Bloch Hamiltonian of a Wannierizable set of bands must transform under under a site-symmetry induced representation (also called band representation) D(g) for operations g in the associated space group. That is, the Bloch Hamiltonian mathbfh(mathbfk) must be symmetric in the sense:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbfD_mathbfk(g) mathbfh_mathbfk mathbfD_mathbfk^dagger(g) = mathbfh_gmathbfk","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfD_mathbfk(g) is the (momentum-)block-diagonal part of the Fourier transformed band representation D(g). This is simply the familiar operator relation g hath_mathbfk g^-1 = hath_gmathbfk cast into the basis of local orbitals.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is registered in the Julia General registry and can be installed from the pkg> command line (entered by pressing ] in the Julia REPL):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SymmetricTightBinding, Crystalline","category":"page"},{"location":"","page":"Home","title":"Home","text":"SymmetricTightBinding.jl is designed to work as a companion package to Crystalline.jl; so we add Crystalline.jl in the above as well. The packages can subsequently be loaded at the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SymmetricTightBinding, Crystalline","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"tutorial.md\", \"band-symmetry.md\", \"symmetry-breaking.md\", \"api.md\", \"internal-api.md\"]\nDepth = 2","category":"page"},{"location":"tutorial/#tutorial","page":"Tutorial","title":"Tutorial example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a first step, we load both Crystalline.jl and SymmetricTightBinding.jl into our current Julia session:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Crystalline, SymmetricTightBinding","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As our first example, we'll build and explore the tight-binding model of graphene. Once we've done that, we'll explore how to create related tight-binding models in the same symmetry setting. Subsequently, we'll take a look at building 3D tight-binding models.","category":"page"},{"location":"tutorial/#Graphene","page":"Tutorial","title":"Graphene","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Graphene is a two-dimensional material, with two carbon atoms arranged in a honeycomb lattice. For our purposes, the important aspect is its crystal symmetry: the lattice has 6-fold rotation symmetry and associated in-plane mirror symmetry. In the language of crystallography, its symmetry is that of plane group p6mm (here, specified by its Hermann‚ÄìMauguin label). This plane group has a conventional numbering assigned ‚Äì namely, plane group ‚ãï17. The mapping between the Hermann‚ÄìMauguin label and the conventional number can e.g., be determined using Crystalline.jl's iuc or looked up in online tables, such as the Bilbao Crystallographic Server.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using Crystalline, we can build the maximal band representations of plane group ‚ãï17:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sgnum = 17 # space group number of p6mm\nbrs = calc_bandreps(sgnum, Val(2)) # `Val(2)` specifies the dimensionality (here, 2D)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The top row of the output lists the possible positions that a symmetrically placed orbital can reside, specified as a Wyckoff position label (e.g., 1a, 2b, 3c). In the second row, the possible local symmetry that an orbital placed there can have (e.g., A‚ÇÅ, A‚ÇÇ, B‚ÇÅ, ‚Ä¶) are listed, specified in Mulikken notation. The remaining rows contain information about the projection of each band representation to band symmetries at high-symmetry k-points and which is not needed in the present context.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Graphene's two p<sub>z</sub> orbitals sit at the 2b Wyckoff position: though odd (i.e., changing sign) under mirror in the out-of-plane direction, the p<sub>z</sub> orbital is even (i.e., invariant) under all in-plane symmetries (rotations and mirrors). The associated site-symmetry irrep is the A‚ÇÅ site-symmetry irrep of the 2b Wyckoff position. In the above tables, this is the fifth column of brs, which we may select by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"brs[1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To construct a tight-binding model, we must construct a CompositeBandRepresentation: this is necessary because we may generally be interested in building models for multiple band representations (say, for placing orbitals at multiple distinct Wyckoff positions). We can construct such a composite representation by @composite a*brs[i] + b*brs[j] + ‚Ä¶ which will contain a times the brs[i] band representation and so on. Here, we just need the (2b|A‚ÇÅ) representation once:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cbr = @composite brs[5]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With this in hand, we can finally use SymmetricTightBinding.jl. In particular, we may use tb_hamiltonian. First, we build the nearest-neighbor tight-binding Hamiltonian:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tbm = tb_hamiltonian(cbr)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The output lists the \"basis terms\" of the tight-binding Bloch Hamiltonian, each implicitly parameterized by a free on-site energy or hopping amplitude. The notation ùïñ(Œ¥·µ¢) is introduced for brevity, a short-hand for the complex momentum-dependent exponential mathrme^mathrmimathbfkcdotboldsymboldelta_i. Here boldsymboldelta_i denotes a hopping vector; in turn, these vectors are expressed above as Œ¥·µ¢, given in the basis of the primitive direct lattice mathbfa_i. I.e., a term like Œ¥‚ÇÅ = [-1/3, 1/3] really means boldsymboldelta_1 = -tfrac13mathbfa_1 + tfrac13mathbfa_2.","category":"page"},{"location":"tutorial/#Visualization","page":"Tutorial","title":"Visualization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It's often helpful to visualize model terms, and SymmetricTightBinding.jl facilitates this via a Makie extension. We may e.g., use GLMakie.jl to plot the second tight-binding term:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GLMakie\nRs = directbasis(sgnum, Val(2)) # a direct lattice basis, to allow plotting in a Cartesian setting\nplot(tbm[2], Rs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, red markers indicate \"source\" sites while blue markers indicat \"drains\"; electrons hop from sources to drains, as also indicated by the arrowheads. The visualization (and the internal representation of tbm) includes only the hoppings for a single unit cell, such that tiling unit cells do not lead to counting hoppings multiple times.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We might want to go beyond nearest-neighbor in our tight-binding model. To do so, we must provide tb_hamiltonian with a second argument that gives a set of possible direct-lattice vector separations of sources and drains (in addition to an intra-lattice term). It is enough to include a representative direct lattice vector; if e.g., [1,0] and [0,1] are symmetry-related, the latter will be automatically included by providing the former.  For the graphene example, we might include direct lattice separations [0,0] (default, if a second argument is not provided) and [1,0]:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tbm = tb_hamiltonian(cbr, [[0,0], [1,0]])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And we now have four terms. We can visualize tbm[3] and tbm[4] as before, individually, or we can visualize all terms at once:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(tbm, Rs)","category":"page"},{"location":"tutorial/#Model-evaluation-and-band-structures","page":"Tutorial","title":"Model evaluation & band structures","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To evaluate the tight-binding model, we must specify a set of (real) hopping amplitudes. To associate coefficients c‚ÇÅ, c‚ÇÇ, c‚ÇÉ, c‚ÇÑ to each of the basis terms of the model tbm, we can invoke it as a functor to create a ParameterizedTightBindingModel:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cs = [0, 1, 0, 0] # set c‚ÇÇ = 1 and all other c·µ¢ to zero\nptbm = tbm(cs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then evaluate the parameterized model ptbm at k-point, again using ptbm as a functor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"k = ReciprocalPoint(1/2, 0) # the M point\nh = ptbm(k)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the k-point coordinates must be given in the basis of the primitive reciprocal lattice vectors mathbfb_i (the dual lattice to mathbfa_i), i.e., the k variable above corresponds to the point mathbfk = tfrac12mathbfb_1 + 0mathbfb_2.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will usually be more interested in the overall behavior of the model across the Brillouin zone than its behavior at any single k-point. E.g., we might be interested in the band structure along high-symmetry lines of the Brillouin zone. To quickly build such a path, we leverage Brillouin.jl's irrfbz_path:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Brillouin\nkp = irrfbz_path(sgnum, Rs)\nkpi = interpolate(kp, 200) # aim for 200 interpolations points","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, to obtain the band structure along the interpolated k-path, we use SymmetricTightBinding.jl's spectrum function and plot the result using the Brillouin.jl's Makie.jl extension:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Es = spectrum(ptbm, kpi); # a 200√ó2 Matrix\nplot(kpi, Es)","category":"page"}]
}
