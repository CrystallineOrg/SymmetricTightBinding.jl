"""
    HoppingOrbit{D}

A structure holding information about symmetry-related spatial hopping vectors.

An orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the
symmetry operations of the underlying space group to a representative vector Œ¥.

For each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site `a` to site
`b`, possibly related by a lattice translation `R`. Each such set of possible hopping term
`(a, b, R)` is for each `Œ¥·µ¢` is stored elements as the `i`th element of the vector
`hoppings`.

## Fields
- `representative :: RVec{D}`: the representative hopping vector Œ¥
- `orbit :: Vector{RVec{D}}`: the Œ¥·µ¢ elements of the orbit generated by Œ¥.
  Generally `orbit[1] == representative`, i.e., `Œ¥‚ÇÅ = Œ¥`
- `hoppings :: Vector{Vector{NTuple{3,RVec{D}}}}`: the `i`th element gives the possible
  physical hopping terms `(a,b,R)` associated to `orbit[i]`. Multiple physical hopping terms
  may correspond to each element of the orbit. 
  For `(a, b, R) = hoppings[i][j]`, we have `orbit[i] = Œ¥·µ¢ = b + R - a`
"""
struct HoppingOrbit{D}
    representative::RVec{D} # representative hopping vector Œ¥
    orbit::Vector{RVec{D}}  # orbit of the hopping vector {Œ¥·µ¢ ‚Ä¶}
    hoppings::Vector{Vector{NTuple{3, RVec{D}}}} # `[(a,b,R), ...]` for every `orbit[i]`
end
representative(s::HoppingOrbit) = s.representative
Crystalline.orbit(s::HoppingOrbit) = s.orbit # extend to avoid clash w/ Crystalline's `orbit`

# ---------------------------------------------------------------------------------------- #
# constructor defined in /src/tightbinding.jl

struct OrbitalOrdering{D} <: AbstractVector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
    ordering::Vector{@NamedTuple{wp::WyckoffPosition{D}, idx::Int}}
end
Base.getindex(o::OrbitalOrdering, i::Int) = o.ordering[i]
Base.size(o::OrbitalOrdering) = size(o.ordering)
Base.setindex!(::OrbitalOrdering, v, i::Int) = error("setindex! is not supported")
Base.IndexStyle(::Type{OrbitalOrdering}) = IndexLinear()
Base.iterate(o::OrbitalOrdering) = iterate(o.ordering)
Base.iterate(o::OrbitalOrdering, i) = iterate(o.ordering, i)

# ---------------------------------------------------------------------------------------- #

"""
    TightBindingElementString

A structure for pretty-printing tight-binding matrix elements.

## Fields
- `s :: String`: the string representing the tight-binding matrix element
- `active :: Bool`: whether the element belongs to an "active" block - i.e., one we want to
  highlight (then shown in blue).
"""
struct TightBindingElementString
    s::String
    active::Bool
end
function Base.show(io::IO, tbe_str::TightBindingElementString)
    s = tbe_str.s
    color = (
        tbe_str.active ? (s == "0" ? :normal : :blue) : (s == "0" ? :light_black : :normal)
    )
    printstyled(io, s; color)
end

"""
    TightBindingBlock{D}

A structure for storing information about a matrix block of a tight-binding Hamiltonian.

A block will represent a hopping terms between two band representations `br1` and `br2`. 
For this hopping we store:

## Fields
- `br1 :: NewBandRep{D}`: first band representation
- `br2 :: NewBandRep{D}`: second band representation
- `ordering1 :: OrbitalOrdering{D}`: ordering of the orbitals in `br1`
- `ordering2 :: OrbitalOrdering{D}`: ordering of the orbitals in `br2`
- `h_orbit :: Union{Nothing,HoppingOrbit{D}}`: hopping orbit associated to the block
- `Mm :: Array{Int,4}`: matrix codifying Hamiltonian
- `t :: Vector{Float64}}`: a basis vector, stored in re/im-doubled format
"""

struct TightBindingBlock{D} <: AbstractMatrix{TightBindingElementString}
    br1::NewBandRep{D}
    br2::NewBandRep{D}
    ordering1::OrbitalOrdering{D}
    ordering2::OrbitalOrdering{D}
    h_orbit::HoppingOrbit{D}
    Mm::Array{Int, 4}
    t::Vector{Float64}
    MmtC::Array{ComplexF64, 3} # MmtC[:,i,j] = M[:,:,i,j] * complex.(t[1:N], t[N+1:end])
    # we include `MmtC` as an optimization: we want `Mm` for structural information (e.g.
    # for plotting), but for computing the block matrix elements, we actually only need
    # the (column-)contracted matrix `MmtC` (see `evaluate_tight_binding_term!`)
end
Base.size(tbb::TightBindingBlock) = (size(tbb.Mm, 3), size(tbb.Mm, 4))
function TightBindingBlock{D}(br1, br2, ordering1, ordering2, h_orbit, Mm, t) where D
    N·µó = length(t) √∑ 2
    tC = complex.((@view t[1:N·µó]), (@view t[N·µó+1:end]))
    MmtC = Array{ComplexF64}(undef, size(Mm, 1), size(Mm, 3), size(Mm, 4))
    for i in axes(Mm, 3), j in axes(Mm, 4)
        MmtC[:, i, j] = (@view Mm[:, :, i, j]) * tC
    end
    return TightBindingBlock{D}(br1, br2, ordering1, ordering2, h_orbit, Mm, t, MmtC)
end

@enum Hermiticity::UInt8 begin
    HERMITIAN
    ANTIHERMITIAN
end

struct TightBindingTerm{D} <: AbstractBlockMatrix{TightBindingElementString}
    axis::BlockedOneTo{Int, Vector{Int}}
    block_ij::NTuple{2, Int}
    block::TightBindingBlock{D}
    hermiticity::Hermiticity
    brs::Vector{NewBandRep{D}}
end

Base.axes(H::TightBindingTerm) = (H.axis, H.axis)
function Base.axes(H::TightBindingTerm, d::Int)
    d > 2 ? Base.BlockedOneTo([1]) :
    d > 0 ? H.axis : error("dimensionality must be greater than 1")
end
Base.size(H::TightBindingTerm) = (N = last(H.axis); (N, N))

function Base.getindex(H::TightBindingTerm, i::Int, j::Int)
    N = size(H, 1)
    @boundscheck 1 ‚â§ i ‚â§ N && 1 ‚â§ j ‚â§ N || error(BoundsError(H, (i, j)))
    tmp = BlockArrays.findblockindex(H.axis, i)
    block_i = only(tmp.I)
    local_i = only(tmp.Œ±)
    tmp = BlockArrays.findblockindex(H.axis, j)
    block_j = only(tmp.I)
    local_j = only(tmp.Œ±)
    if H.block_ij == (block_i, block_j)
        return _getindex(H.block, local_i, local_j)
    elseif H.block_ij == (block_j, block_i) # hermiticity-related block
        return _getindex(
            H.block,
            local_j,
            local_i;
            conjugate = true,
            antihermitian = H.hermiticity == ANTIHERMITIAN,
        )
    else # not a stored block
        return TightBindingElementString("0", false) #=active=#
    end
end

function _getindex(
    tbb::TightBindingBlock,
    i::Int,
    j::Int;
    conjugate::Bool = false,
    antihermitian::Bool = false,
)
    if antihermitian && !conjugate
        error("input has `antihermitian = true` but `conjugate = false`; not intended?")
    end
    @boundscheck 1 ‚â§ i ‚â§ size(tbb.Mm, 3) && 1 ‚â§ j ‚â§ size(tbb.Mm, 4) ||
                 error(BoundsError(tbb, (i, j)))

    io = IOBuffer()
    M‚Å± ≤tC = tbb.MmtC[:, i, j] # = `tbb.Mm[:,:,i,j] * "complexified"(tbb.t)`
    if all(v -> abs(v) < SPARSIFICATION_ATOL_DEFAULT, M‚Å± ≤tC)
        return TightBindingElementString("0", true) #=active=#
    end

    first = true
    for (n, v) in enumerate(M‚Å± ≤tC)
        abs(v) < SPARSIFICATION_ATOL_DEFAULT && continue
        v·¥ø, v·¥µ = reim(v)
        if conjugate
            v·¥µ = -v·¥µ # complex conjugate
            antihermitian && (v·¥ø = -v·¥ø; v·¥µ = -v·¥µ) # additional sign-flip from anti-hermiticity
        end

        v·¥ø‚Ä≤, v·¥ø_str = _stringify_real(v·¥ø)
        v·¥µ‚Ä≤, v·¥µ_str = _stringify_real(v·¥µ)
        if v·¥µ‚Ä≤ == 0     # strictly real
            v_str = isone(abs(v·¥ø‚Ä≤)) ? "" : lstrip(v·¥ø_str, ('-', '+'))
            v_str = (v·¥ø‚Ä≤ < 0 ? "-" : (first ? "" : "+")) * v_str
        elseif v·¥ø‚Ä≤ == 0 # strictly imaginary
            v_str = isone(abs(v·¥µ‚Ä≤)) ? "" : lstrip(v·¥µ_str, ('-', '+'))
            v_str = (v·¥µ‚Ä≤ < 0 ? "-" : (first ? "" : "+")) * v_str * "i"
        else            # complex
            v_str =
                (first ? "" : " + ") *
                "(" *
                _complex_as_compact_string(complex(v·¥ø‚Ä≤, v·¥µ‚Ä≤)) *
                ")"
        end
        print(io, v_str)

        Œ¥ = tbb.h_orbit.orbit[n]
        if !iszero(Œ¥) # print the exponential: our notation is ùïñ(Œ¥) ‚â° exp(2œÄiùê§‚ãÖŒ¥)
            print(io, "ùïñ(")
            # TODO: could do a little better here, since we know that `-Œ¥` is in the orbit?
            conjugate && print(io, "-")
            print(io, "Œ¥", Crystalline.subscriptify(string(n)), ")")
        else
            print(io, "1")
        end

        first = false
    end

    s = String(take!(io))
    return TightBindingElementString(s, true) #=active=#
end

function Base.getindex(tbb::TightBindingBlock, i::Int, j::Int)
    return _getindex(tbb, i, j; conjugate = false, antihermitian = false)
end

Base.setindex!(::TightBindingBlock, v, ij...) = error("setindex! is not supported")

# pretty-printing of scalars

function _stringify_real(c::Real; digits::Int = 3)
    c‚Ä≤ = round(c; digits)
    isinteger(c‚Ä≤) && return c‚Ä≤, string(Int(c‚Ä≤))
    return c‚Ä≤, string(c‚Ä≤)
end

function _complex_as_compact_string(c::Complex) # usual string(::Complex) has spaces; 
    # avoid that
    io = IOBuffer()
    print(io, real(c), Crystalline.signaschar(imag(c)), abs(imag(c)), "i")
    return String(take!(io))
end

# ---------------------------------------------------------------------------------------- #

"""
  TightBindingModel{D}

A structure storing a list of `TightBindingTerm{D}`s. Each term is assumed to associated
with an identical list of EBRs.

To associate a set of coefficients to each term, see
[`ParameterizedTightBindingModel`](@ref), which also allows evaluation at specific momenta.

## Fields

- `terms :: Vector{TightBindingTerm{D}}`: a vector of `TightBindingTerm{D}`s, each of which
  represents a block (or conjugated pairs of blocks) of the Hamiltonian matrix.
- `cbr :: CompositeBandRep{D}`: the composite band representation associated to the model.
- `positions :: Vector{DirectPoint{D}}`: a vector of positions, specified in the lattice
  basis, associated to each orbital of the model.
- `N :: Int`: the total number of orbitals in the model, i.e., the size of the Hamiltonian
  matrix associated to each element of `terms`.
"""
struct TightBindingModel{D} <: AbstractVector{TightBindingTerm{D}}
    terms::Vector{TightBindingTerm{D}}
    cbr::CompositeBandRep{D} # band representation associated to the model
    positions::Vector{DirectPoint{D}} # positions associated to each orbital
    N::Int # total number of orbitals, i.e., matrix size
end
Base.size(tbm::TightBindingModel) = (length(tbm.terms),)
Base.getindex(tbm::TightBindingModel, i::Int) = tbm.terms[i]
Base.setindex!(::TightBindingModel, v, i::Int) = error("setindex! is not supported")
Base.IndexStyle(::Type{TightBindingModel}) = IndexLinear()
orbital_positions(tbm::TightBindingModel) = tbm.positions
Crystalline.CompositeBandRep(tbm::TightBindingModel) = tbm.cbr

function TightBindingModel(
    terms::Vector{TightBindingTerm{D}},
    cbr::CompositeBandRep{D},
) where {D}
    length(terms) == 0 && return TightBindingModel{D}(terms, 0)
    positions = orbital_positions(cbr)
    N = last(first(terms).axis)
    return TightBindingModel{D}(terms, cbr, positions, N)
end
function (tbm::TightBindingModel{D})(cs::AbstractVector{<:Real}) where {D}
    return ParameterizedTightBindingModel{D}(tbm, cs)
end

# ---------------------------------------------------------------------------------------- #

# union-type for valid k-point input; defined to avoid repeating this everywhere
const ReciprocalPointLike{D} = Union{
    AbstractVector{<:Real},
    NTuple{D, <:Real},
    ReciprocalPoint{D}}

# ---------------------------------------------------------------------------------------- #

"""
  ParameterizedTightBindingModel{D}

A coefficient-parameterized tight-binding model, that can be used as a functor for
evaluation at input momenta `k`.

## Fields

- `tbm :: TightBindingModel{D}`: A tight-binding model, consisting of a set of a list of
  `TightBindingTerm{D}`s.
- `cs :: Vector{Float64}`: A vector of coefficients, each associated to a corresponding
  element of `tbm`.
- `scratch :: Matrix{ComplexF64}`: A scratch space for evaluating the Hamiltonian matrix at
  at specific momenta. This is a `N√óN` matrix, where `N` is the number of orbitals in `tbm`
  (i.e., `tbm.N`). The scratch space is instantiated automatically on construction.

## Functor over momenta

A `ParameterizedTightBindingModel` `ptbm` can be be evaluated at any ¬¥D`-dimensional
momentum `k` by using `ptbm` as a functor. That is, `ptbm(k)` returns a numerical
representation of the Hamiltonian matrix for `ptbm` evaluated at momentum `k`.`
"""
struct ParameterizedTightBindingModel{D}
    tbm::TightBindingModel{D}
    cs::Vector{Float64} # coefficients of the tight-binding model
    scratch::Matrix{ComplexF64} # scratch space for evaluation
    # inner constructor w/ checks & conversion of input
    function ParameterizedTightBindingModel{D}(
        tbm::TightBindingModel{D},
        cs::AbstractVector{<:Real},
        scratch::Matrix{ComplexF64} = Matrix{ComplexF64}(undef, tbm.N, tbm.N)
    ) where {D}
        length(tbm.terms) ‚â† length(cs) && _throw_term_coef_length_mismatch(tbm.terms, cs)
        size(scratch) ‚â† (tbm.N, tbm.N) && _throw_scratch_size_mismatch(scratch, tbm.N)
        return new{D}(tbm, convert(Vector{Float64}, cs), scratch)
    end
end
@noinline function _throw_scratch_size_mismatch(scratch, N)
    s_scratch = size(scratch)
    error(DimensionMismatch("scratch size ($s_scratch) does not match model size ($N, $N)"))
end
@noinline function _throw_term_coef_length_mismatch(terms, cs)
    Nt = length(terms)
    Nc = length(cs)
    error("number of coefficients ($Nc) does not match number of model terms ($Nt)")
end

orbital_positions(ptbm::ParameterizedTightBindingModel) = ptbm.tbm.positions
Crystalline.CompositeBandRep(ptbm::ParameterizedTightBindingModel) = ptbm.tbm.cbr

function (ptbm::ParameterizedTightBindingModel{D})(
    k::ReciprocalPointLike{D},
    scratch::Matrix{ComplexF64} = ptbm.scratch,
) where {D}
    if length(k) ‚â† D
        error("momentum `k` must be a $D-dimensional vector to match the model dimension")
    end
    tbm = ptbm.tbm
    size(scratch) ‚â† (tbm.N, tbm.N) && _throw_scratch_size_mismatch(scratch, tbm.N)

    H = scratch # grab & reset scratch space for evaluating Hamiltonian matrix
    fill!(H, 0.0)

    # evaluate each block of the Hamiltonian terms, multiply by coefficients, & store in `H`
    for (tbt, c) in zip(tbm.terms, ptbm.cs)
        evaluate_tight_binding_term!(tbt, k, c, H) # modifies `H` in-place
    end

    return H
end

"""
    evaluate_tight_binding_term!(tbt::TightBindingTerm, k, [c, H])

Evaluate the tight-binding term `tbt` at momentum `k`, possibly multiplied by a scalar
coefficient `c` (unity if omitted). The term is _added_ into the scratch space matrix `H`;
if `H` is not provided, it is initialized as a zero matrix of the appropriate size.

The function returns the modified `H` matrix.
    
## Note
The two-argument form of the function, i.e., returning the value of `tbt` at `k`, can be
more simply achieved via `tbt(k)`.
"""
function evaluate_tight_binding_term!(
    tbt::TightBindingTerm{D},
    k::ReciprocalPointLike{D},
    c::Union{Nothing, <:Number} = nothing,
    H::Matrix{ComplexF64} = zeros(ComplexF64, size(tbt))
) where {D}
    block = tbt.block
    block_i, block_j = tbt.block_ij
    is = tbt.axis[Block(block_i)] # global row indices
    js = tbt.axis[Block(block_j)] # global col indices
    MmtC = block.MmtC # contracted product of `Mm` and (complexified) `t`

    # NB: ‚Üì one more case of assuming no free parameters in `Œ¥`
    v = cispi.(dot.(Ref(2 .* k), constant.(orbit(block.h_orbit))))
    for (local_i, i) in enumerate(is)
        for (local_j, j) in enumerate(js)
            H·µ¢‚±º = @inbounds dot(v, @view MmtC[:, local_i, local_j])
            isnothing(c) || (H·µ¢‚±º *= c) # multiply by coefficient if provided
            H[i, j] += H·µ¢‚±º
            i == j && continue # don't add diagonal elements twice
            H[j, i] += tbt.hermiticity == ANTIHERMITIAN ? -conj(H·µ¢‚±º) : conj(H·µ¢‚±º)
        end
    end

    return H
end

function (tbt::TightBindingTerm{D})(k::ReciprocalPointLike{D}) where {D}
    if length(k) ‚â† D
        error("momentum `k` must be a $D-dimensional vector to match the model dimension")
    end
    return evaluate_tight_binding_term!(tbt, k)
end

function solve(
    ptbm::ParameterizedTightBindingModel{D},
    k::ReciprocalPointLike{D};
    bloch_phase::Union{Val{true}, Val{false}} = Val(true),
    eigen_kws...,
) where D
    length(k) == D || error("dimension mismatch")
    if ptbm.tbm.terms[1].hermiticity == ANTIHERMITIAN
        error("ANTIHERMITIAN model solve not implemented") # TODO: cf. `Hermitian` use below
    end
    H = Hermitian(ptbm(k))
    es, vs = eigen(H; eigen_kws...)
    if bloch_phase === Val(true)
        phases = cispi.(dot.(Ref(2 .* k), orbital_positions(ptbm))) # e^{ik¬∑r}
        vs = Diagonal(phases) * vs # add Bloch phases
        return es, vs
    else
        return es, vs
    end
end

function solve(ptbm::ParameterizedTightBindingModel{D}, k::KVec{D}; kws...) where D
    isspecial(k) || error("input k-point has free parameters, i.e., is not definite")
    solve(ptbm, constant(k); kws...)
end