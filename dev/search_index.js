var documenterSearchIndex = {"docs":
[{"location":"internal-api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"This page lists unexported functionality from SymmetricTightBinding.jl that may be of interest to developers.","category":"page"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"","category":"page"},{"location":"internal-api/#Unexported,-internal-functionality","page":"Internal API","title":"Unexported, internal functionality","text":"","category":"section"},{"location":"internal-api/#SymmetricTightBinding.OrbitalOrdering-Union{Tuple{Crystalline.NewBandRep{D}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.OrbitalOrdering","text":"OrbitalOrdering(br::NewBandRep{D}) --> OrbitalOrdering{D}\n\nEstablishes a canonical, local ordering for the orbitals associated to a band representation br. This is the default ordering used when associating row/column indices in a tight-binding Hamiltonian block to specific orbitals in the associated band representations.\n\nThe canonical orbital ordering is stored in .ordering. The ith elements of ordering, ordering[i], is a NamedTuple with two fields: wp and idx:\n\nwp: stores a Wyckoff position in the orbit of the Wyckoff position associated to br.wp.\nidx: stores the index of the partner function of the site-symmetry irrep associated to br at wp.\n\nI.e., the ith orbital associated to br is located at wp and transforms as the idxth partner function of the site-symmetry irrep of br.siteir. The total number of orbitals associated to a band representation, and hence the length of ordering, is the product of the site-symmetry irrep dimensionality and the number of sites in the Wyckoff position orbit.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.SiteInducedSGRepElement","page":"Internal API","title":"SymmetricTightBinding.SiteInducedSGRepElement","text":"SiteInducedSGRepElement{D}(\n    œÅ::AbstractMatrix,\n    positions::Vector{DirectPoint{D}},\n    op::SymOperation{D}\n)\n\nRepresents a matrix-valued element of a site-induced representation of a space group, including a global momentum-dependent phase factor.\n\nThis structure behaves like a functor: calling it with a momentum k :: AbstractVector  returns the matrix representation at k.\n\nFields (internal)\n\nœÅ :: Matrix{ComplexF64} : The momentum-independent matrix part of the representation.\npositions :: Vector{DirectPoint{D}}: Real-space positions corresponding to the orbitals in the orbit of the associated site-symmetry group.\n\n\n\n\n\n","category":"type"},{"location":"internal-api/#SymmetricTightBinding._maybe_add_hoppings!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding._maybe_add_hoppings!","text":"Computes and adds the symmetry related partners of a hopping term Œ¥ to the Œ¥_orbit.\n\nwarning: Warning\nThis function is an internal helper function for maybe_add_hoppings! and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._permute_symmetry_related_hoppings_under_symmetry_operation-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.SymOperation{D}}} where D","page":"Internal API","title":"SymmetricTightBinding._permute_symmetry_related_hoppings_under_symmetry_operation","text":"Build the P matrix for a particular symmetry operation acting on k-space, which permutes the rows of the M matrix.\n\nFor obtaining the P matrix, we make use that the action is on exponential of the type: ùêûxp(2œÄkŒ¥), to instead act on Œ¥ ‚àà h_orbit.orbit instead of k, which is a symbolic variable. Because of that, we need to use the inverse of the rotation part of the symmetry operation.\n\ndetails: Sketch of proof\nAssume g={R|œÑ} and Crystalline implements gk=(R‚Åª¬π)·µÄk. Then (gk)‚ãÖŒ¥ = ((R‚Åª¬π)·µÄk)‚ãÖŒ¥ + œÑ = k‚ãÖ(R‚Åª¬π)Œ¥.\n\ninfo: Info\nIt is assumed that the operation op is provided in a primitive setting.\n\nwarning: Warning\nThis function is an internal helper function for reciprocal_constraints_matrices and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._poormans_sparsification-Tuple{AbstractMatrix{<:Number}}","page":"Internal API","title":"SymmetricTightBinding._poormans_sparsification","text":"Poor man's \"matrix sparsification\" via the reduced row echelon form.\n\nwarning: Warning\nThis function is an internal helper function for obtain_basis_free_parameters and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding._prune_at_threshold!-Union{Tuple{AbstractVector{<:AbstractVector{T}}}, Tuple{T}} where T<:Complex","page":"Internal API","title":"SymmetricTightBinding._prune_at_threshold!","text":"Prune near-zero elements of vectors in vs.\n\nwarning: Warning\nThis function is an internal helper function for obtain_basis_free_parameters and is not part of the public API.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.add_timereversal_related_orbits!-Union{Tuple{Array{HoppingOrbit{D}, 1}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.add_timereversal_related_orbits!","text":"add_timereversal_related_orbits!(h_orbits::Vector{HoppingOrbit{D}}) where {D}\n\nAdds the time-reversed hopping terms to the hopping orbits in h_orbits. The time-reversed hopping terms are added to the orbit of the hopping term they are related to, and if they are already present in another orbit, the two orbits are merged.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.construct_M_matrix-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.construct_M_matrix","text":"construct_M_matrix(\n    h_orbit::HoppingOrbit{D}, br1::NewBandRep{D}, br2::NewBandRep{D},\n    [ordering1, ordering2]) \n    --> Array{Int,4}\n\nConstruct a set of matrices that encodes a Hamiltonian's term which resembles the hopping from EBR br1 to EBR br2.\n\nThe encoding is stored as a 4D matrix. Its last two axes correspond to elements of the Bloch Hamiltonian H(k); its first axis corresponds to orbit(h_orbit) and the associated complex exponentials stored in v; and its second axis to the elements of the vector t. That is:\n\nH‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º\n\nSee devdocs.md for details.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.evaluate_tight_binding_term!-Union{Tuple{D}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Union{Nothing, Number}}, Tuple{SymmetricTightBinding.TightBindingTerm{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Union{Nothing, Number}, Matrix{ComplexF64}}} where D","page":"Internal API","title":"SymmetricTightBinding.evaluate_tight_binding_term!","text":"evaluate_tight_binding_term!(tbt::TightBindingTerm, k, [c, H])\n\nEvaluate the tight-binding term tbt at momentum k, possibly multiplied by a scalar coefficient c (unity if omitted). The term is added into the scratch space matrix H; if H is not provided, it is initialized as a zero matrix of the appropriate size.\n\nThe function returns the modified H matrix.\n\nNote\n\nThe two-argument form of the function, i.e., returning the value of tbt at k, can be more simply achieved via tbt(k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.inversion-Tuple{Val{3}}","page":"Internal API","title":"SymmetricTightBinding.inversion","text":"inversion(::Val{D}) --> SymOperation{D}\n\nReturn the inversion operation in dimension D.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.maybe_add_hoppings!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding.maybe_add_hoppings!","text":"maybe_add_hoppings!(h_orbits, Œ¥, q‚Çê, q·µ¶, R, ops) --> Vector{HoppingOrbit{D}}\n\nChecks if a hopping term Œ¥ is already in the list of representatives. If not, it adds it and its symmetry related partners. If it is, it only adds the symmetry related partners.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters","text":"obtain_basis_free_parameters(\n    h_orbit::HoppingOrbit{D},\n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D}, \n    [ordering‚Çê = OrbitalOrdering(br‚Çê), ordering·µ¶ = OrbitalOrdering(br·µ¶)]\n    )                            --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}\n\nObtain the basis of free parameters for the hopping terms between br‚Çê and br·µ¶  associated with the hopping orbit h_orbit.\n\nNote\n\nThe presence or absence of time-reversal symmetry is inferred implicitly from br‚Çê and br·µ¶.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters_TRS-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}, AbstractArray{Int64, 4}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters_TRS","text":"obtain_basis_free_parameters_TRS(\n    h_orbit::HoppingOrbit{D}, \n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D}, \n    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),\n    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶),\n    Mm::AbstractArray{4, Int} = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶)\n    )                             --> Tuple{Array{Int,4}, Vector{Vector{ComplexF64}}}}\n\nObtain the basis of free parameters for the hopping terms between br‚Çê and br·µ¶ associated with the hopping orbit h_orbit under time-reversal symmetry.\n\nReal and imaginary parts of the basis vectors are differentiated explicitly: internally, we consider only variables.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.obtain_basis_free_parameters_hermiticity-Union{Tuple{D}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}}, Tuple{HoppingOrbit{D}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, SymmetricTightBinding.OrbitalOrdering{D}, SymmetricTightBinding.OrbitalOrdering{D}, AbstractArray{Int64, 4}}} where D","page":"Internal API","title":"SymmetricTightBinding.obtain_basis_free_parameters_hermiticity","text":"obtain_basis_free_parameters_hermiticity(\n    h_orbit::HoppingOrbit{D},\n    br‚Çê::NewBandRep{D},\n    br·µ¶::NewBandRep{D},\n    ordering‚Çê::OrbitalOrdering{D} = OrbitalOrdering(br‚Çê),\n    ordering·µ¶::OrbitalOrdering{D} = OrbitalOrdering(br·µ¶),\n    Mm::AbstractArray{Int, 4} = construct_M_matrix(h_orbit, br‚Çê, br·µ¶, ordering‚Çê, ordering·µ¶);\n    antihermitian::Bool = false,\n) where {D}\n\nConstructs a basis for the coefficient vectors t‚ÅΩ‚Åø‚Åæ that span the space of Hermitian (or antihermitian if true) TB Hamiltonians H‚Çõ‚Çú(k) = v·µ¢(k) M·µ¢‚±º‚Çõ‚Çú t‚±º = v·µÄ(k) M‚ÅΩÀ¢·µó‚Åæ t. We do this by assuming that each coefficient vector t is sorted into a vector of the form [t·¥ø; it·¥µ] so that we can take the complex conjugate by as t* = œÉ‚ÇÉt, which can then be moved onto M‚ÅΩÀ¢·µó‚Åæ instead of t. The constraint H‚Çõ‚Çú(k) = (H‚Ä†)‚Çõ‚Çú(k) = H‚Çú‚Çõ*(k) can then be expressed as v·µÄ(k) M‚ÅΩÀ¢·µó‚Åæ t‚±º = v*·µÄ(k) M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ t = v·µÄ(k) (P·µÄ M‚ÅΩ·µóÀ¢‚ÅæœÉ‚ÇÉ) t, which requires that t be a solution to the nullspace M‚ÅΩÀ¢·µó‚Åæ - P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ = 0. We cast this as Z - Q = 0, with Z = M‚ÅΩÀ¢·µó‚Åæ and Q = P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ.\n\nNotes\n\nFor anti-Hermitian symmetry, we require H‚Çõ‚Çú(k) = -H‚Çú‚Çõ*(k), which translates to M‚ÅΩÀ¢·µó‚Åæ + P·µÄ M‚ÅΩ·µóÀ¢‚Åæ œÉ‚ÇÉ = 0; i.e., simply swaps the sign of Q\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.pin_free-Union{Tuple{D}, Tuple{Crystalline.NewBandRep{D}, AbstractVector{<:Real}}} where D","page":"Internal API","title":"SymmetricTightBinding.pin_free","text":"pin_free(br::NewBandRep{D}, Œ±Œ≤Œ≥::AbstractVector{<:Real}) where D\n\nPin the free parameters of the Wyckoff position associated with the band representation br to the values in Œ±Œ≤Œ≥. \n\nReturns a new band representation with all other properties, apart from the Wyckoff position, identical to (and sharing memory with) br.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.primitivized_orbit-Union{Tuple{Crystalline.NewBandRep{D}}, Tuple{D}} where D","page":"Internal API","title":"SymmetricTightBinding.primitivized_orbit","text":"primitivized_orbit(br::NewBandRep{D}) where D\n\nReturn the orbit of the Wyckoff position associated with the band representation br. The coordinates of positions in the orbit are given relative to the primitive unit cell.\n\nPositions are returned as a Vector{DirectPoint{D}}.\n\nThe following checks are made, producing an error if violated:\n\nThere are no free parameters associated with the Wyckoff position.\nFor every position, its coordinates, referred to the primitive basis, is in the range [0,1); i.e., every position lies in the parallepiped primitive unit cell [0,1)·¥∞.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.reciprocal_constraints_matrices-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, AbstractArray{Crystalline.SymOperation{D}, 1}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.reciprocal_constraints_matrices","text":"reciprocal_constraints_matrices(\n                                Mm::AbstractArray{Int,4}, \n                                gens::AbstractVector{SymOperation{D}}, \n                                h_orbit::HoppingOrbit{D}\n                                ) --> Vector{Array{Int,4}}\n\nCompute the reciprocal constraints matrices for the generators of the SG. This is done by permuting the rows of the M matrix according to the symmetry operation acting on k-space. See more details in permute_symmetry_related_hoppings_under_symmetry_operation and devdocs.md.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.reciprocal_constraints_trs-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.reciprocal_constraints_trs","text":"reciprocal_constraints_trs(Mm::AbstractArray{Int,4}, h_orbit::HoppingOrbit{D}) \n--> Array{ComplexF64,4}\n\nTime reversal symmetry action on reciprocal space. It is given by the association  k -> -k => H(k) -> H(-k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.representation_constraint_matrices-Union{Tuple{D}, Tuple{AbstractArray{Int64, 4}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}, AbstractArray{Crystalline.SymOperation{D}, 1}}} where D","page":"Internal API","title":"SymmetricTightBinding.representation_constraint_matrices","text":"representation_constraints_matrices(\n    Mm::AbstractArray{Int,4}, \n    br‚Çê::NewBandRep{D},\n    br·µ¶::NewBandRep{D}) --> Vector{Array{ComplexF64,4}}\n\nBuild the Q matrix for a particular symmetry operation (or, equivalently, a particular matrix from the site-symmetry representation), acting on the M matrix. Relative to our white-board notes, Q has swapped indices, in the sense we below give Q[i,j,r,l].\n\n(œÅ‚Çê‚Çê)·µ£‚Çõ H‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ v·µ¢ M·µ¢‚±º‚Çõ‚Çú t‚±º (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó = v·µ¢ (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó t‚±º,\n\nthen we can define: Q·µ¢‚±º·µ£‚Çó = (œÅ‚Çê‚Çê)·µ£‚Çõ M·µ¢‚±º‚Çõ‚Çú (œÅ·µ¶·µ¶‚Åª¬π)‚Çú‚Çó\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.representation_constraint_trs-Union{Tuple{D}, Tuple{AbstractArray{<:Number, 4}, HoppingOrbit{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.representation_constraint_trs","text":"representation_constraint_trs(Mm::AbstractArray{Int,4}, h_orbit::HoppingOrbit{D})\n--> Array{ComplexF64,4}\n\nTime reversal symmetry action on the Hamiltonian. It is given by the association Œ¥ -> -Œ¥ and  the complex conjugation in the free-parameter part: t‚±º - t‚±º*  t‚±º·¥ø it‚±º·¥µ - t‚±º·¥ø -it‚±º·¥µ  H(k) - H*(k).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.sgrep_induced_by_siteir_excl_phase-Union{Tuple{D}, Tuple{Crystalline.NewBandRep{D}, Crystalline.SymOperation{D}}} where D","page":"Internal API","title":"SymmetricTightBinding.sgrep_induced_by_siteir_excl_phase","text":"sgrep_induced_by_siteir_excl_phase(br::NewBandRep, op::SymOperation)\nsgrep_induced_by_siteir_excl_phase(cbr::CompositeBandRep, op::SymOperation)\n    --> Matrix{ComplexF64}\n\nReturn the representation matrix of a symmetry operation op induced by the site symmetry group of a band representation br or composite band representation cbr, excluding the global momentum-dependent phase factor.\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.split_complex-Tuple{AbstractVector{<:Number}}","page":"Internal API","title":"SymmetricTightBinding.split_complex","text":"split_complex(t::Vector{<:Number}) -> Matrix{Real}\n\nConsider Œ±t where Œ± ‚àà ‚ÑÇ and t ‚àà ‚ÑÇ‚Åø and build from t a matrix representation T that allows access to the real and imaginary parts of the product Œ±t without using complex numbers by splitting Œ± into a real 2-vector of its real and imaginary parts.\n\nIn particular, let Œ± = Œ±·¥ø + iŒ±·¥µ and t = t·¥ø + it·¥µ with Œ±·¥ø, Œ±·¥µ ‚àà ‚Ñù and t·¥ø t·¥µ  ‚Ñù‚Åø, then Œ±t can be rewritten as\n\nŒ±t = (Œ±·¥ø + iŒ±·¥µ)(t·¥ø + it·¥µ)\n   = (Œ±·¥øt·¥ø - Œ±·¥µt·¥µ) + i(Œ±·¥øt·¥µ + Œ±·¥µt·¥ø)\n   = t·¥ø t·¥µ·µÄ Œ±·¥ø Œ±·¥µ + i t·¥µ t·¥ø·µÄ Œ±·¥ø Œ±·¥µ\n\nThen, defining T = [t·¥ø -t·¥µ; t·¥µ t·¥ø], the above product can then be reexpressed as: Re(Œ±t) = Œ±·¥øt·¥ø - Œ±·¥µt·¥µ = (T * [Œ±·¥ø; Œ±·¥µ])[1:n] and Im(Œ±t) = Œ±·¥øt·¥µ + Œ±·¥µt·¥ø = (T * [Œ±·¥ø; Œ±·¥µ])[n+1:2n]. I.e., the \"upper half\" of the product T * [real(Œ±), imag(Œ±)] is real(Œ± * t) and the  \"lower half\" is imag(Œ±t).\n\nThis functionality is used to avoid complex numbers in amplitude basis coefficients, which simplifies the application of time-reversal symmetry and hermiticity.\n\nExamples\n\njulia> using SymmetricTightBinding: split_complex\n\njulia> t = [im,0]\n2-element Vector{Complex{Int64}}:\n 0 + 1im\n 0 + 0im\n\njulia> T = split_complex(t)\n4√ó2 Matrix{Int64}:\n 0  -1\n 0   0\n 1   0\n 0   0\n\njulia> Œ± = 0.5+0.2im; Œ±v = [real(Œ±), imag(Œ±)];\n\njulia> (T * Œ±v)[1:2] == real(Œ±*t) && (T * Œ±v)[3:4] == imag(Œ±*t)\n\njulia> t = [1,im]\n2-element Vector{Complex{Int64}}:\n 1 + 0im\n 0 + 1im\n\njulia> split_complex(t)\n4√ó2 Matrix{Int64}:\n 1   0\n 0  -1\n 0   1\n 1   0\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#SymmetricTightBinding.zassenhaus_intersection-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}}, Tuple{AbstractArray{T}, AbstractArray{T}, Real}} where T<:Number","page":"Internal API","title":"SymmetricTightBinding.zassenhaus_intersection","text":"zassenhaus_intersection(U::AbstractArray{<:Number}, W::AbstractArray{<:Number}) \n    --> AbstractArray{<:Number}\n\nFinds the intersection of two bases U and W using the Zassenhaus algorithm. It assumes that the basis are given by columns.\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Zassenhaus_algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#Crystalline.collect_compatible-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, Vararg{Any}}} where D","page":"API","title":"Crystalline.collect_compatible","text":"collect_compatible(ptbm::ParameterizedTightBindingModel{D}; multiplicities_kws...)\n\nDetermine a decomposition of the bands associated with ptbm into a set of SymmetryVectors, with each symmetry vector corresponding to a set of compatibility-respecting (i.e., energy separable along high-symmetry k-lines) bands.\n\nKeyword arguments\n\nmultiplicities_kws...: keyword arguments passed to Crystalline.collect_compatible used in determining the multiplicities of irreps across high-symmetry k-points.\n\nExample\n\njulia> using Crystalline, SymmetricTightBinding\n\njulia> brs = calc_bandreps(221);\n\njulia> cbr = @composite brs[1] + brs[2]\n40-irrep CompositeBandRep{3}:\n (3d|A‚ÇÅg) + (3d|A‚ÇÅ·µ§) (6 bands)\n\njulia> tbm = tb_hamiltonian(cbr); # a 4-term, 6-band model\n\njulia> ptbm = tbm([1.0, 0.1, -1.0, 0.1]); # fix free coefficients\n\njulia> collect_compatible(ptbm)\n2-element Vector{SymmetryVector{3}}:\n [M‚ÇÖ‚Å∫+M‚ÇÅ‚Åª, X‚ÇÉ‚Å∫+X‚ÇÅ‚Åª+X‚ÇÇ‚Åª, Œì‚ÇÅ‚Åª+Œì‚ÇÉ‚Åª, R‚ÇÑ‚Å∫] (3 bands)\n [M‚ÇÅ‚Å∫+M‚ÇÖ‚Åª, X‚ÇÅ‚Å∫+X‚ÇÇ‚Å∫+X‚ÇÉ‚Åª, Œì‚ÇÅ‚Å∫+Œì‚ÇÉ‚Å∫, R‚ÇÑ‚Åª] (3 bands)\n\nIn the above example, the bands separate into two symmetry vectors, one for each of the original EBRs in cbr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.collect_irrep_annotations-Tuple{ParameterizedTightBindingModel}","page":"API","title":"Crystalline.collect_irrep_annotations","text":"collect_irrep_annotations(ptbm::ParameterizedTightBindingModel; kws...)\n\nCollect the irrep labels across the high-symmetry k-points referenced by the underlying composite band representation of ptbm, across the bands of the model.\n\nUseful for annotating irrep labels in band structure plots (via the Makie extension call plot(ks, energies; annotations=collect_irrep_annotations(ptbm)))\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.energy_gradient_wrt_hopping-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{ParameterizedTightBindingModel{D}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, Any}} where D","page":"API","title":"SymmetricTightBinding.energy_gradient_wrt_hopping","text":"energy_gradient_wrt_hopping(\n    ptbm::ParameterizedTightBindingModel{D},\n    k::ReciprocalPointLike{D}\n    (Es, us) = solve(ptbm, k; bloch_phase=Val(false));\n    degen_rtol::Float64 = 1e-12,\n    degen_atol::Float64 = 1e-12\n) where D\n\nReturn the hopping gradient of the energy of each band in ptbm evaluated at momentum k.\n\nThe gradient is computed using the Feynman-Hellmann theorem. For degenerate bands (assessed energetically using relative and absolute tolerances degen_rtol and degen_atol), a degenerate variant is used, equivalent to degenerate perturbation theory.\n\nThe gradient is returned as column vectors, one for each band, with each column containing the gradient of the corresponding energy with respect to the hopping coefficients of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.gradient_wrt_hopping-Tuple{TightBindingModel}","page":"API","title":"SymmetricTightBinding.gradient_wrt_hopping","text":"gradient_wrt_hopping(tbm :: TightBindingModel)\ngradient_wrt_hopping(ptbm :: ParameterizedTightBindingModel)\n\nReturn a structure that encodes the gradient of a tight-binding model tbm or ptbm with respect to the hopping coefficients.\n\nTo evaluate the gradient at a particular momentum k, use the returned structure as a functor at k. I.e., gradient(tbm)(k) returns the gradient of the tight-binding Hamiltonian with respect to all hoppping coefficients at momentum k. This gradient is a vector of matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.obtain_symmetry_related_hoppings-Union{Tuple{V}, Tuple{D}, Tuple{AbstractVector{V}, Crystalline.NewBandRep{D}, Crystalline.NewBandRep{D}}} where {D, V<:Union{Crystalline.RVec{D}, AbstractVector{<:Integer}}}","page":"API","title":"SymmetricTightBinding.obtain_symmetry_related_hoppings","text":"obtain_symmetry_related_hoppings(\n    Rs::AbstractVector{V}, \n    br‚Çê::NewBandRep{D}, \n    br·µ¶::NewBandRep{D},\n) --> Vector{HoppingOrbit{D}}\n\nCompute the symmetry related hopping terms from the points in WP of br‚Çê to the  WP of br·µ¶ displaced a set of primitive lattice vectors representatives Rs.\n\nImplementation\n\nTake a point a in the WP of br‚Çê and a point b in the WP of br·µ¶. We \n\ncompute the displacement vector Œ¥ = b + R - a, where R ‚àà Rs.\n\nIf Œ¥ ‚àà representatives then we add Œ¥ => (a, b, R) to the list of hoppings   of that representative and continue. If not then, we search inside of all the   representatives for the one that Œ¥ => (a, b, R) in the list of hoppings.   If not found, then we add Œ¥ as a new representative and add Œ¥ => (a, b, R)   to its list of hoppings.\nTake g ‚àà generators and compute Œ¥' = g Œ¥ and (a', b', R') = (g a, g b, g R),   and repeat step 2.\nRepeat all steps 1 to 3 for all pair of points in the WPs of br‚Çê and br·µ¶.\n\nAdditionally, if we have time-reversal symmetry, we check if orbits that relate Œ¥ and  -Œ¥ are present; if not, we add them. The presence or absence of time-reversal symmetry is automatically inferred from br‚Çê and br·µ¶ (which must be identical).\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.pin_free!-Tuple{Crystalline.Collection{<:Crystalline.NewBandRep}, AbstractVector{<:Pair{Int64, <:AbstractVector{<:Real}}}}","page":"API","title":"SymmetricTightBinding.pin_free!","text":"pin_free!(\n    brs::Collection{NewBandRep{D}},\n    idx2Œ±Œ≤Œ≥::Pair{Int, <:AbstractVector{<:Real}}\n)\n\npin_free!(\n    brs::Collection{NewBandRep{D}},\n    idx2Œ±Œ≤Œ≥s::AbstractVector{<:Pair{Int, <:AbstractVector{<:Real}}}\n)\n\nFor idx2Œ±Œ≤Œ≥ = idx => Œ±Œ≤Œ≥, update brs[idx] such that the free parameters of its associated Wyckoff positions are pinned to Œ±Œ≤Œ≥.\n\nA vector of pairs idx2Œ±Œ≤Œ≥s can also be provided, to pin multiple distinct band representations.\n\nSee also pin_free for non-mutated input.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.sgrep_induced_by_siteir-Union{Tuple{D}, Tuple{Union{Crystalline.CompositeBandRep{D}, Crystalline.NewBandRep{D}}, Crystalline.SymOperation{D}}, Tuple{Union{Crystalline.CompositeBandRep{D}, Crystalline.NewBandRep{D}}, Crystalline.SymOperation{D}, Array{Bravais.DirectPoint{D}, 1}}} where D","page":"API","title":"SymmetricTightBinding.sgrep_induced_by_siteir","text":"sgrep_induced_by_siteir(\n    br::Union{NewBandRep, CompositeBandRep},\n    op::SymOperation, [positions::Vector{<:DirectPoint}]\n)\nsgrep_induced_by_siteir(\n    tbm::Union{TightBindingModel,ParameterizedTightBindingModel}, op::SymOperation\n)\n    --> SiteInducedSGRepElement\n\nComputes the representation matrix of a symmetry operation op induced by the site symmetry group associated with an elementary or composite band representation br , including the global momentum-dependent phase factor, returning a SiteInducedSGRepElement, which is a functor over momentum inputs.\n\nA (possibly parameterized) tight-binding model tbm can be specified instead of a band representation, in which case the latter is inferred from the former.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.spectrum-Tuple{ParameterizedTightBindingModel, Any}","page":"API","title":"SymmetricTightBinding.spectrum","text":"spectrum(ptbm::ParameterizedTightBindingModel, ks; transform = identity)\n\nEvaluate the spectrum, i.e., energies, of the tight-binding model ptbm over an iterable of input momenta ks. \n\nEnergies are returned as a matrix, with rows running over momenta and columns over distinct bands.\n\nKeyword arguments\n\ntransform: a function to apply to the resulting matrix of energies, defaulting to the identity function. This can be used to e.g., convert the energies to a different scaling.\n\nExample\n\nAs an example, we evaluating the band structure of graphene. Below, we first construct and parameterize a tight-binding model for the the (2b|A‚ÇÅ) EBR in plane group 17, corresponding to the highest-lying orbitals in graphene. Next, we construct a path along high-symmetry directions of the Brillouin zone using Brillouin.jl, calculate the spectrum across this path; and finally, plot the band structure using Brillouin and GLMakie (or PlotlyJS):\n\njulia> using Crystalline, SymmetricTightBinding\n\njulia> brs = calc_bandreps(17, Val(2));\n\njulia> cbr = @composite brs[5]\n13-irrep CompositeBandRep{2}:\n (2b|A‚ÇÅ) (2 bands)\n\njulia> ptbm = tb_hamiltonian(cbr, [zeros(Int, dim(cbr))])([0.0, 1.0]);\n\njulia> using Brillouin, GLMakie\n\njulia> kpi = interpolate(irrfbz_path(17, directbasis(17, Val(2))), 100);\n\njulia> plot(kpi, spectrum(ptbm, kpi))\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.spectrum-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, AbstractVector{<:Real}}} where D","page":"API","title":"SymmetricTightBinding.spectrum","text":"spectrum(ptbm::ParameterizedTightBindingModel, k::AbstractVector{<:Real})\n\nEvaluate the spectrum, i.e., energies, of the tight-binding model ptbm at a single momentum k, across all the bands of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.symmetry_eigenvalues-Union{Tuple{D}, Tuple{ParameterizedTightBindingModel{D}, AbstractArray{Crystalline.SymOperation{D}, 1}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}}, Tuple{ParameterizedTightBindingModel{D}, AbstractArray{Crystalline.SymOperation{D}, 1}, Union{NTuple{D, var\"#s40\"} where var\"#s40\"<:Real, AbstractVector{<:Real}}, AbstractArray{SymmetricTightBinding.SiteInducedSGRepElement{D}, 1}}} where D","page":"API","title":"SymmetricTightBinding.symmetry_eigenvalues","text":"symmetry_eigenvalues(\n    ptbm::ParameterizedTightBindingModel{D},\n    ops::AbstractVector{SymOperation{D}},\n    k::ReciprocalPointLike{D},\n    [sgreps::AbstractVector{SiteInducedSGRepElement{D}}]\n)\nsymmetry_eigenvalues(\n    ptbm::ParameterizedTightBindingModel{D},\n    lg::LittleGroup{D},\n    [sgreps::AbstractVector{SiteInducedSGRepElement{D}}]\n)\n    --> Matrix{ComplexF64}\n\nCompute the symmetry eigenvalues of a coefficient-parameterized tight-binding model ptbm at the k-point k for the symmetry operations ops. A LittleGroup can also be provided instead of ops and k.\n\nRepresentations of the symmetry operations ops as acting on the orbitals of the tight-binding setting can optionally be provided in sgreps (see sgrep_induced_by_siteir) and are otherwise initialized by the function.\n\nThe symmetry eigenvalues are returned as a matrix, with rows running over the elements of ops and columns running over the bands of ptbm.\n\n\n\n\n\n","category":"method"},{"location":"api/#SymmetricTightBinding.tb_hamiltonian-Union{Tuple{Crystalline.CompositeBandRep{D}}, Tuple{D}, Tuple{Crystalline.CompositeBandRep{D}, AbstractVector{Vector{Int64}}}} where D","page":"API","title":"SymmetricTightBinding.tb_hamiltonian","text":"tb_hamiltonian(cbr::CompositeBandRep{D}, Rs::AbstractVector{Vector{Int}}) \n    --> Vector{TightBindingTerm{D}}\n\nConstruct the TB Hamiltonian matrix from a given composite band representation cbr and a set of global translation-representatives Rs. The Hamiltonian is constructed block by block according to the symmetry-related hoppings between the band representations in cbr. Several models returned, each representing a term that is closed under the symmetry operations of  the underlying space group.\n\n\n\n\n\n","category":"method"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#SymmetricTightBinding.HoppingOrbit","page":"API","title":"SymmetricTightBinding.HoppingOrbit","text":"HoppingOrbit{D}\n\nA structure holding information about symmetry-related spatial hopping vectors.\n\nAn orbit includes all symmetry related vectors {Œ¥} = {Œ¥‚ÇÅ, Œ¥‚ÇÇ, ‚Ä¶} obtained by applying the symmetry operations of the underlying space group to a representative vector Œ¥.\n\nFor each element of the orbit Œ¥·µ¢ there may be multiple hopping terms, from site a to site b, possibly related by a lattice translation R. Each such set of possible hopping term (a, b, R) is for each Œ¥·µ¢ is stored elements as the ith element of the vector hoppings.\n\nFields\n\nrepresentative :: RVec{D}: the representative hopping vector Œ¥\norbit :: Vector{RVec{D}}: the Œ¥·µ¢ elements of the orbit generated by Œ¥. Generally orbit[1] == representative, i.e., Œ¥‚ÇÅ = Œ¥\nhoppings :: Vector{Vector{NTuple{3,RVec{D}}}}: the ith element gives the possible physical hopping terms (a,b,R) associated to orbit[i]. Multiple physical hopping terms may correspond to each element of the orbit.  For (a, b, R) = hoppings[i][j], we have orbit[i] = Œ¥·µ¢ = b + R - a\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.ParameterizedTightBindingModel","page":"API","title":"SymmetricTightBinding.ParameterizedTightBindingModel","text":"ParameterizedTightBindingModel{D}\n\nA coefficient-parameterized tight-binding model, that can be used as a functor for evaluation at input momenta k.\n\nFields\n\ntbm :: TightBindingModel{D}: A tight-binding model, consisting of a set of a list of TightBindingTerm{D}s.\ncs :: Vector{Float64}: A vector of coefficients, each associated to a corresponding element of tbm.\nscratch :: Matrix{ComplexF64}: A scratch space for evaluating the Hamiltonian matrix at at specific momenta. This is a N√óN matrix, where N is the number of orbitals in tbm (i.e., tbm.N). The scratch space is instantiated automatically on construction.\n\nFunctor over momenta\n\nA ParameterizedTightBindingModel ptbm can be be evaluated at any ¬¥D-dimensional momentumkby usingptbmas a functor. That is,ptbm(k)returns a numerical representation of the Hamiltonian matrix forptbmevaluated at momentumk.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.TightBindingElementString","page":"API","title":"SymmetricTightBinding.TightBindingElementString","text":"TightBindingElementString\n\nA structure for pretty-printing tight-binding matrix elements.\n\nFields\n\ns :: String: the string representing the tight-binding matrix element\nactive :: Bool: whether the element belongs to an \"active\" block - i.e., one we want to highlight (then shown in blue).\n\n\n\n\n\n","category":"type"},{"location":"api/#SymmetricTightBinding.TightBindingModel","page":"API","title":"SymmetricTightBinding.TightBindingModel","text":"TightBindingModel{D}\n\nA structure storing a list of TightBindingTerm{D}s. Each term is assumed to associated with an identical list of EBRs.\n\nTo associate a set of coefficients to each term, see ParameterizedTightBindingModel, which also allows evaluation at specific momenta.\n\nFields\n\nterms :: Vector{TightBindingTerm{D}}: a vector of TightBindingTerm{D}s, each of which represents a block (or conjugated pairs of blocks) of the Hamiltonian matrix.\ncbr :: CompositeBandRep{D}: the composite band representation associated to the model.\npositions :: Vector{DirectPoint{D}}: a vector of positions, specified in the lattice basis, associated to each orbital of the model.\nN :: Int: the total number of orbitals in the model, i.e., the size of the Hamiltonian matrix associated to each element of terms.\n\n\n\n\n\n","category":"type"},{"location":"#SymmetricTightBinding.jl","page":"Home","title":"SymmetricTightBinding.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymmetricTightBinding.jl enables the construction and manipulation of tight-binding models. The main novelty - and principal strength - of SymmetricTightBinding.jl is that each model is associated with, and specified by, a set of band representations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Put more simply, SymmetricTightBinding.jl will automatically parameterize all possible tight-binding Hamiltonians that are compatible with a selection of orbitals with specified local symmetries (i.e., transforming as specific site symmetry irreps), each situated at specified positions in the unit cell (i.e., at specific Wyckoff positions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying physics is that the Bloch Hamiltonian of a Wannierizable set of bands must transform under under a site-symmetry induced representation (also called band representation) D(g) for operations g in the associated space group. That is, the Bloch Hamiltonian mathbfh(mathbfk) is symmetric in the sense:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbfD_mathbfk(g) mathbfh_mathbfk mathbfD_mathbfk^dagger(g) = mathbfh_gmathbfk","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfD_mathbfk(g) is the (momentum-)block-diagonal part of the Fourier transformed band representation D(g).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is registered in the Julia General registry and can be installed from the pkg> command line (entered by pressing ] in the Julia REPL):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SymmetricTightBinding, Crystalline","category":"page"},{"location":"","page":"Home","title":"Home","text":"SymmetricTightBinding.jl is designed to work as a companion package to Crystalline.jl; so we add Crystalline.jl in the above as well.","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a first step, we load both Crystalline.jl and SymmetricTightBinding.jl into our current Julia session:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Crystalline, SymmetricTightBinding","category":"page"},{"location":"","page":"Home","title":"Home","text":"As our first example, we'll build the tight-binding model of graphene. Once we've done that, we'll explore how to create related tight-binding models in the same symmetry setting.","category":"page"},{"location":"#Graphene","page":"Home","title":"Graphene","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Graphene is a two-dimensional material, with two carbon atoms arranged in a honeycomb lattice. For the present purposes, the important aspects is its crystal symmetry: the lattice has 6-fold rotation symmetry and associated in-plane mirror symmetry. In the language of crystallography, its symmetry is that of plane group p6mm (here, specified by its Hermann-Mauguin label). This plane group has a conventional numbering assigned‚Äì-namely, plane group ‚ãï17. The mapping between the Hermann-Mauguin label and the conventional number can e.g., be determined using Crystalline.jl's iuc or looked up in online tables, such as the Bilbao Crystallographic Server.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using Crystalline, we can build the maximal band representations in plane group ‚ãï17:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sgnum = 17 # space group number of p6mm\nbrs = calc_bandreps(sgnum, Val(2)) # `Val(2)` specifies the dimensionality (here, 2D)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The top row of the output lists the possible positions that a symmetrically placed orbital can reside, specified as a Wyckoff position label (e.g., 1a, 2b, 3c). In the second row, the possible local symmetry that an orbital placed there can have (e.g., A‚ÇÅ, A‚ÇÇ, B‚ÇÅ, ‚Ä¶) are listed, specified in Mulikken notation. The remaining rows contain information about the projection of each band representation to band symmetries at high-symmetry k-points and which is not needed in the present context.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graphene's two p<sub>z</sub> orbitals sit at the 2b Wyckoff position: though odd (i.e., changing sign) under mirror in the out-of-plane direction, the p<sub>z</sub> orbital is even (i.e., invariant) under all in-plane symmetries (rotations and mirrors). The associated site-symmetry irrep is the A‚ÇÅ site-symmetry irrep of the 2b Wyckoff position. In the above tables, this is the fifth column of brs, which we may select by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"brs[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"To construct a tight-binding model, we must construct a CompositeBandRepresentation: this is necessary because we may generally be interested in building models for multiple band representations (say, for placing orbitals at multiple distinct Wyckoff positions). We can construct such a composite representation by @composite a*brs[i] + b*brs[j] + ‚Ä¶ which will contain a times the brs[i] band representation and so on. Here, we just need the (2b|A‚ÇÅ) representation once:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cbr = @composite brs[5]","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this in hand, we can finally use SymmetricTightBinding.jl. In particular, we may use tb_hamiltonian. First, we build the nearest-neighbor tight-binding Hamiltonian:","category":"page"},{"location":"","page":"Home","title":"Home","text":"tbm = tb_hamiltonian(cbr)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output lists the \"basis terms\" of the tight-binding Bloch Hamiltonian, each implicitly parameterized by a free on-site energy or hopping amplitude. The notation ùïñ(Œ¥·µ¢) is introduced for brevity, a short-hand for the complex momentum-dependent exponential mathrme^mathrmimathbfkcdotboldsymboldelta_i. Here boldsymboldelta_i denotes a hopping vector; in turn, these vectors are expressed above as Œ¥·µ¢, given in the basis of the primitive direct lattice mathbfa_i. I.e., a term like Œ¥‚ÇÅ = [-1/3, 1/3] really means boldsymboldelta_1 = -tfrac13mathbfa_1 + tfrac13mathbfa_2.","category":"page"},{"location":"#Visualization","page":"Home","title":"Visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It's often helpful to visualize model terms, and SymmetricTightBinding.jl facilitates this via a Makie extension. We may e.g., use GLMakie.jl to plot the second tight-binding term:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie\nRs = directbasis(sgnum, Val(2)) # a direct lattice basis, to allow plotting in a Cartesian setting\nplot(tbm[2], Rs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, red markers indicate \"source\" sites while blue markers indicat \"drains\"; electrons hop from sources to drains, as also indicated by the arrowheads. The visualization (and the internal representation of tbm) includes only the hoppings for a single unit cell, such that tiling unit cells do not lead to counting hoppings multiple times.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We might want to go beyond nearest-neighbor in our tight-binding model. To do so, we must provide tb_hamiltonian with a second argument that gives a set of possible direct-lattice vector separations of sources and drains (in addition to an intra-lattice term). It is enough to include a representative direct lattice vector; if e.g., [1,0] and [0,1] are symmetry-related, the latter will be automatically included by providing the former.  For the graphene example, we might include direct lattice separations [0,0] (default, if a second argument is not provided) and [1,0]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"tbm = tb_hamiltonian(cbr, [[0,0], [1,0]])","category":"page"},{"location":"","page":"Home","title":"Home","text":"And we now have four terms. We can visualize tbm[3] and tbm[4] as before, individually, or we can visualize all terms at once:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(tbm, Rs)","category":"page"},{"location":"#Model-evaluation-and-band-structures","page":"Home","title":"Model evaluation & band structures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To evaluate the tight-binding model, we must specify a set of (real) hopping amplitudes. To associate coefficients c‚ÇÅ, c‚ÇÇ, c‚ÇÉ, c‚ÇÑ to each of the basis terms of the model tbm, we can invoke it as a functor to create a ParameterizedTightBindingModel:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cs = [0, 1, 0, 0] # set c‚ÇÇ = 1 and all other c·µ¢ to zero\nptbm = tbm(cs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then evaluate the parameterized model ptbm at k-point, again using ptbm as a functor:","category":"page"},{"location":"","page":"Home","title":"Home","text":"k = ReciprocalPoint(1/2, 0) # the M point\nh = ptbm(k)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the k-point coordinates must be given in the basis of the primitive reciprocal lattice vectors mathbfb_i (the dual lattice to mathbfa_i), i.e., the k variable above corresponds to the point mathbfk = tfrac12mathbfb_1 + 0mathbfb_2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will usually be more interested in the overall behavior of the model across the Brillouin zone than its behavior at any single k-point. E.g., we might be interested in the band structure along high-symmetry lines of the Brillouin zone. To quickly build such a path, we leverage Brillouin.jl's irrfbz_path:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Brillouin\nkp = irrfbz_path(sgnum, Rs)\nkpi = interpolate(kp, 200) # aim for 200 interpolations points","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, to obtain the band structure along the interpolated k-path, we use SymmetricTightBinding.jl's spectrum function and plot the result using the Brillouin.jl's Makie.jl extension:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Es = spectrum(ptbm, kpi); # a 200√ó2 Matrix\nplot(kpi, Es)","category":"page"},{"location":"#Band-symmetry","page":"Home","title":"Band symmetry","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since the theory behind SymmetricTightBinding.jl is anchored in symmetry analysis, the package also provides several tools to analyze band symmetry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance, we can label the previously constructed band structure with the little group irrep labels at high-symmetry k-points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(kpi, Es; annotations = collect_irrep_annotations(ptbm))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, we can analyze the compatibility respecting bands contained in ptbm via collect_compatible:","category":"page"},{"location":"","page":"Home","title":"Home","text":"collect_compatible(ptbm)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, since our model contains only a single band representation ‚Äì which is additioanlly an intrinsically connected one ‚Äì such an analysis has only one possible answer (the connected band representation itself): the only possible band groupings is the original band representation. We can verify this by comparing with cbr:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SymmetryVector(cbr)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can set up a more interesting situation, however, by incorporating more band representations (i.e., more orbitals) into our model. E.g., below, we add three s-like orbitals placed at the 3c Wyckoff position (edges of the hexagonal unit cell) to the usual graphene model, and pick a reasonably large hybridization between the graphene and 3c orbitals:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cbr‚Ä≤ = @composite brs[5] + brs[1]\ntbm‚Ä≤ = tb_hamiltonian(cbr‚Ä≤)\nptbm‚Ä≤ = tbm‚Ä≤([-4, -0, -0.1, 0.0, 1.0, -1.0, 1.0])\nplot(kpi, spectrum(ptbm‚Ä≤, kpi); annotations = collect_irrep_annotations(ptbm‚Ä≤))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The band structures features two connected groups of bands. We can obtain the same result (via a compatibility-analysis involving only the high-symmetry k-points) via collect_compatible:","category":"page"},{"location":"","page":"Home","title":"Home","text":"collect_compatible(ptbm‚Ä≤)","category":"page"}]
}
